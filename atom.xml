<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.yexingcheng.com</id>
    <title>永不陨落的星辰</title>
    <subtitle></subtitle>
    <icon>https://www.yexingcheng.com/images/favicon.ico</icon>
    <link href="https://www.yexingcheng.com" />
    <author>
      <name>叶星辰</name>
    </author>
    <updated>2022-11-14T12:49:25.617Z</updated>
    <category term="github vue typescript" />
    <entry>
        <id>https://www.yexingcheng.com/JavaScript/promise/</id>
        <title>详解JsPromise</title>
        <link rel="alternate" href="https://www.yexingcheng.com/JavaScript/promise/"/>
        <content type="html">&lt;h1 id=&#34;什么是promise&#34;&gt;&lt;a href=&#34;#什么是promise&#34; class=&#34;headerlink&#34; title=&#34;什么是promise?&#34;&gt;&lt;/a&gt;什么是promise?&lt;/h1&gt;&lt;p&gt;来看看官方解释：&lt;/p&gt;
&lt;p&gt;Promise 是目前 JS 异步编程的一种解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。&lt;br&gt;Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基本过程&lt;/strong&gt;：&lt;br&gt;初始化 Promise 状态（pending）&lt;br&gt;立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理&lt;br&gt;执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）&lt;br&gt;Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。&lt;/p&gt;
</content>
        <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
        <category term="Js" scheme="https://www.yexingcheng.com/tags/Js/" />
        <updated>2022-11-14T12:49:25.617Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/JavaScript/object-oriented/</id>
        <title>Js面向对象详解</title>
        <link rel="alternate" href="https://www.yexingcheng.com/JavaScript/object-oriented/"/>
        <content type="html"></content>
        <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
        <category term="Js" scheme="https://www.yexingcheng.com/tags/Js/" />
        <updated>2022-11-14T12:28:45.829Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/algorithm/sort/</id>
        <title>基础排序算法总结</title>
        <link rel="alternate" href="https://www.yexingcheng.com/algorithm/sort/"/>
        <content type="html">&lt;h1 id=&#34;冒泡排序：&#34;&gt;&lt;a href=&#34;#冒泡排序：&#34; class=&#34;headerlink&#34; title=&#34;冒泡排序：&#34;&gt;&lt;/a&gt;冒泡排序：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;从开始位置两两比较，持续n轮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基础版：&#34;&gt;&lt;a href=&#34;#基础版：&#34; class=&#34;headerlink&#34; title=&#34;基础版：&#34;&gt;&lt;/a&gt;基础版：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function bubbleSort(arr)&amp;#123;
    for(let i = 0; i &amp;lt;arr.length; i++)&amp;#123;
        for(let j = 0; j &amp;lt;arr.length; j++)&amp;#123;
            if(arr[j]&amp;gt;arr[j+1])&amp;#123;
                let tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;改进版&#34;&gt;&lt;a href=&#34;#改进版&#34; class=&#34;headerlink&#34; title=&#34;改进版&#34;&gt;&lt;/a&gt;改进版&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function bubleSort(arr)&amp;#123;
    for(let i = arr.length-1;i&amp;gt;0;i--)&amp;#123;
        for(let j = 0; j&amp;lt;i;j++)&amp;#123;
            if(arr[j]&amp;gt;arr[j+1])&amp;#123;
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;选择排序：&#34;&gt;&lt;a href=&#34;#选择排序：&#34; class=&#34;headerlink&#34; title=&#34;选择排序：&#34;&gt;&lt;/a&gt;选择排序：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;每次选出最大&amp;#x2F;最小值 持续n轮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基础班&#34;&gt;&lt;a href=&#34;#基础班&#34; class=&#34;headerlink&#34; title=&#34;基础班&#34;&gt;&lt;/a&gt;基础班&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function selectSort(arr)&amp;#123;
    for(let i = 0i&amp;lt;arr.length; i &amp;lt; ++)&amp;#123;
        let index = i;

        for(let j = i;j&amp;lt;arr.length;j++)&amp;#123;
            if(arr[index]&amp;gt;arr[j])&amp;#123;
                index = j;
        &amp;#125;
    &amp;#125;
    [arr[i], arr[index]] = [arr[index],arr[i]]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;改进版-1&#34;&gt;&lt;a href=&#34;#改进版-1&#34; class=&#34;headerlink&#34; title=&#34;改进版&#34;&gt;&lt;/a&gt;改进版&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function selectSort (arr) &amp;#123;
  for (let i = 0, len_i = arr.length - 1; i &amp;lt; len_i; i++) &amp;#123;
    let index = i
    for (let j = i + 1, len_j = arr.length; j &amp;lt; len_j; j++) &amp;#123;
      if (arr[index] &amp;gt; arr[j]) &amp;#123;
        index = j
      &amp;#125;
    &amp;#125;
    if (index !== i) &amp;#123;
      [arr[i], arr[index]] = [arr[index], arr[i]]
    &amp;#125;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;插入排序&#34;&gt;&lt;a href=&#34;#插入排序&#34; class=&#34;headerlink&#34; title=&#34;插入排序&#34;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;h1 id=&#34;希尔排序&#34;&gt;&lt;a href=&#34;#希尔排序&#34; class=&#34;headerlink&#34; title=&#34;希尔排序&#34;&gt;&lt;/a&gt;希尔排序&lt;/h1&gt;&lt;h1 id=&#34;归并排序&#34;&gt;&lt;a href=&#34;#归并排序&#34; class=&#34;headerlink&#34; title=&#34;归并排序&#34;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h1 id=&#34;快速排序&#34;&gt;&lt;a href=&#34;#快速排序&#34; class=&#34;headerlink&#34; title=&#34;快速排序&#34;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h1 id=&#34;堆排序&#34;&gt;&lt;a href=&#34;#堆排序&#34; class=&#34;headerlink&#34; title=&#34;堆排序&#34;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;</content>
        <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
        <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
        <updated>2022-11-13T18:17:16.850Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/algorithm/concurrent-requests/</id>
        <title>并发请求</title>
        <link rel="alternate" href="https://www.yexingcheng.com/algorithm/concurrent-requests/"/>
        <content type="html">&lt;h1 id=&#34;并发请求：&#34;&gt;&lt;a href=&#34;#并发请求：&#34; class=&#34;headerlink&#34; title=&#34;并发请求：&#34;&gt;&lt;/a&gt;并发请求：&lt;/h1&gt;&lt;p&gt;给定一个url数组，每一项都是一个url地址，然后给出一个最大的并发请求数，直到所有请求发送完毕，然后把所有的返回结果归并到一个数组里面，并且顺序和url地址顺序相同&lt;/p&gt;
&lt;p&gt;首先，请求肯定是异步的，所以我们返回一个Promise,并且这个Promise一定是成功的，并且我们准备好一个返回数组，并且排除特殊情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
    &amp;#125;)
        let result = []

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次我们取出一个url地址，然后发送请求，因为我们不用等待请求结果，所以可以看作是并发的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        function request()&amp;#123;
            const url = urls[index];
            index++;
            fetch(url)
        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在以及可以发送请求了，但是在他请求完了之后，不管是成功还是失败，我们都加入到返回数组中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        async function request()&amp;#123;
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;

        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个请求完成了，就要开始发送下一个请求了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                request()
            &amp;#125;

        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后要判断所有请求是否都完成了，我们每完成一次请求就记录一次数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标
        let count = 0;//完成的请求数量
        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                count++
                if(count===urls.length)&amp;#123;
                    resolve(result)
                &amp;#125;
                request()
            &amp;#125;

        &amp;#125;
    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们请求的函数就有了，但是要调用几次呢，就是调用最大并发数的次数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标
        let count = 0;//完成的请求数量
        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                count++
                if(count===urls.length)&amp;#123;
                    resolve(result)
                &amp;#125;
                request()
            &amp;#125;

        &amp;#125;

        let times = Math.min(urls.length,maxNum)

        for(let i = 0; i &amp;lt; times; i++)&amp;#123;
            request()
        &amp;#125;
    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里这道面试题就完成了&lt;/p&gt;
</content>
        <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
        <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
        <updated>2022-11-13T17:54:00.855Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/data-structures/stack/</id>
        <title>栈代码面试题</title>
        <link rel="alternate" href="https://www.yexingcheng.com/data-structures/stack/"/>
        <content type="html">&lt;h1 id=&#34;使用临时堆栈对堆栈进行排序&#34;&gt;&lt;a href=&#34;#使用临时堆栈对堆栈进行排序&#34; class=&#34;headerlink&#34; title=&#34;使用临时堆栈对堆栈进行排序&#34;&gt;&lt;/a&gt;使用临时堆栈对堆栈进行排序&lt;/h1&gt;&lt;p&gt;给定一堆整数，使用另一个临时堆栈按升序对其进行排序。&lt;/p&gt;
&lt;h2 id=&#34;例子：&#34;&gt;&lt;a href=&#34;#例子：&#34; class=&#34;headerlink&#34; title=&#34;例子：&#34;&gt;&lt;/a&gt;例子：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入 ：[34、3、31、98、92、23]&lt;br&gt;输出：[3、23、31、34、92、98]&lt;/p&gt;
&lt;p&gt;输入：[3、5、1、4、2、8]&lt;br&gt;输出：[1、2、3、4、5、8]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;算法：&#34;&gt;&lt;a href=&#34;#算法：&#34; class=&#34;headerlink&#34; title=&#34;算法：&#34;&gt;&lt;/a&gt;算法：&lt;/h2&gt;&lt;p&gt;1、创建一个临时堆栈为tmpStack&lt;br&gt;2、虽然输入堆栈不为空，但请执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从输入堆栈弹出一个元素，成为temp&lt;/li&gt;
&lt;li&gt;当临时堆栈不为空且临时堆栈顶部大于 temp 时， 临时堆栈中弹出并将其推送到输入堆栈&lt;/li&gt;
&lt;li&gt;将temp推入临时堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、排序后的数字在tempStack&lt;/p&gt;
&lt;h2 id=&#34;执行：&#34;&gt;&lt;a href=&#34;#执行：&#34; class=&#34;headerlink&#34; title=&#34;执行：&#34;&gt;&lt;/a&gt;执行：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function sortStack(input)&amp;#123;

    let tempStack = [];
    while(input.length &amp;gt; 0)&amp;#123;

        let temp = input.pop();

    while(tempStack.length &amp;gt; 0 &amp;amp;&amp;amp; tempStack[tempStack.length-1]&amp;gt;temp)&amp;#123;

        input.push(tempStack[tempStack.length-1]);

        tempStack.pop();
    &amp;#125;   

    tempStack.push(temp);

    &amp;#125;
    return tempStack;
&amp;#125;


const arr = [34, 3, 31, 98, 92, 23]

console.log(sortStack(arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[34, 3, 31, 98, 92, 23]&lt;/p&gt;
&lt;p&gt;取出的元素：23&lt;br&gt;输入：[34, 3, 31, 98, 92]&lt;br&gt;tmpStack：[23]&lt;/p&gt;
&lt;p&gt;取出的元素：92&lt;br&gt;输入：[34, 3, 31, 98]&lt;br&gt;tmpStack: [23, 92]&lt;/p&gt;
&lt;p&gt;取出元素: 98&lt;br&gt;输入: [34, 3, 31]&lt;br&gt;tmpStack: [23, 92, 98]&lt;/p&gt;
&lt;p&gt;取出元素: 31&lt;br&gt;输入: [34, 3, 98, 92]&lt;br&gt;tmpStack: [23, 31]&lt;/p&gt;
&lt;p&gt;取出元素: 92&lt;br&gt;输入: [34, 3, 98]&lt;br&gt;tmpStack: [23, 31, 92]&lt;/p&gt;
&lt;p&gt;取出元素: 98&lt;br&gt;输入: [34, 3]&lt;br&gt;tmpStack: [23, 31, 92 , 98]&lt;/p&gt;
&lt;p&gt;取出的元素：3&lt;br&gt;输入：[34, 98, 92, 31, 23]&lt;br&gt;tmpStack：[3]&lt;/p&gt;
&lt;p&gt;取出的元素：23&lt;br&gt;输入：[34, 98, 92, 31]&lt;br&gt;tmpStack: [3, 23]&lt;/p&gt;
&lt;p&gt;取出元素: 31&lt;br&gt;输入: [34, 98, 92]&lt;br&gt;tmpStack: [3, 23, 31]&lt;/p&gt;
&lt;p&gt;取出元素: 92&lt;br&gt;输入: [34, 98]&lt;br&gt;tmpStack: [3, 23, 31 , 92]&lt;/p&gt;
&lt;p&gt;取出的元素：98&lt;br&gt;输入：[34]&lt;br&gt;tmpStack：[3, 23, 31, 92, 98]&lt;/p&gt;
&lt;p&gt;取出的元素：34&lt;br&gt;输入：[98, 92]&lt;br&gt;tmpStack：[3, 23, 31, 34]&lt;/p&gt;
&lt;p&gt;元素取出：92&lt;br&gt;输入：[98]&lt;br&gt;tmpStack：[3,23,31,34,92]&lt;/p&gt;
&lt;p&gt;取出元素：98&lt;br&gt;输入：[]&lt;br&gt;tmpStack：[3,23,31,34,92,98]&lt;/p&gt;
&lt;p&gt;最终排序列表： [3、23、31、34、92、98]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;输出&#34;&gt;&lt;a href=&#34;#输出&#34; class=&#34;headerlink&#34; title=&#34;输出&#34;&gt;&lt;/a&gt;输出&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;98 92 34 31 23 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; O(n 2 )其中 n 是给定堆栈中的整数总数。&lt;br&gt;&lt;strong&gt;辅助空间：&lt;/strong&gt; O(n)&lt;/p&gt;
</content>
        <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <category term="stack" scheme="https://www.yexingcheng.com/tags/stack/" />
        <updated>2022-11-12T13:27:30.117Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/data-structures/array/</id>
        <title>数组代码面试题</title>
        <link rel="alternate" href="https://www.yexingcheng.com/data-structures/array/"/>
        <content type="html">&lt;h1 id=&#34;查找数组中最小和次小的元素&#34;&gt;&lt;a href=&#34;#查找数组中最小和次小的元素&#34; class=&#34;headerlink&#34; title=&#34;查找数组中最小和次小的元素&#34;&gt;&lt;/a&gt;查找数组中最小和次小的元素&lt;/h1&gt;&lt;h2 id=&#34;实例：&#34;&gt;&lt;a href=&#34;#实例：&#34; class=&#34;headerlink&#34; title=&#34;实例：&#34;&gt;&lt;/a&gt;实例：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;输入：arr[] = &amp;#123;12, 13, 1, 10, 34, 1&amp;#125;
输出：最小元素是 1 
     第二个最小的元素是 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法1（简单方法）&#34;&gt;&lt;a href=&#34;#方法1（简单方法）&#34; class=&#34;headerlink&#34; title=&#34;方法1（简单方法）&#34;&gt;&lt;/a&gt;方法1（简单方法）&lt;/h3&gt;&lt;p&gt;一个简单的解决方案是按照升序对数组进行排序。排序数组中的前两个元素将是两个最小的元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;let arr = [111, 13, 25, 9, 34, 1];

arr.sort((a,b)=&amp;gt;a-b)

console.log(arr[0],arr[1]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果最小元素出现不止一次，那么我们将不得不使用循环来打印唯一的最小元素和次小元素。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; O(N*logN)&lt;br&gt;&lt;strong&gt;辅助空间：&lt;/strong&gt; O(1)&lt;/p&gt;
&lt;h3 id=&#34;方法2&#34;&gt;&lt;a href=&#34;#方法2&#34; class=&#34;headerlink&#34; title=&#34;方法2&#34;&gt;&lt;/a&gt;方法2&lt;/h3&gt;&lt;p&gt;更好的&lt;strong&gt;解决方案&lt;/strong&gt;是扫描阵列两次。在第一次遍历中找到最小元素。设此元素为 x。在第二次遍历中，找到大于 x 的最小元素。&lt;/p&gt;
&lt;p&gt;使用这种方法，我们可以克服方法 1 的问题，即最小元素在数组中出现多次时出现的问题。&lt;br&gt;上述解决方案需要对输入数组进行两次遍历。 &lt;/p&gt;
</content>
        <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
        <category term="Array" scheme="https://www.yexingcheng.com/tags/Array/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <updated>2022-11-11T14:11:17.368Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/data-structures/main/</id>
        <title>面试需要了解的八个数据结构</title>
        <link rel="alternate" href="https://www.yexingcheng.com/data-structures/main/"/>
        <content type="html">&lt;p&gt;1976 年，一个瑞士计算机科学家写一本书《Algorithms + Data Structures &amp;#x3D; Programs》。即：算法 + 数据结构 &amp;#x3D; 程序。40 多年过去了，这个等式依然成立。&lt;/p&gt;
&lt;p&gt;很多代码面试题都要求候选者深入理解数据结构，不管你来自大学计算机专业还是编程培训机构，也不管你有多少年编程经验。有时面试题会直接提到数据结构，比如“给我实现一个二叉树”，然而有时则不那么明显，比如“统计一下每个作者写的书的数量”。&lt;/p&gt;
&lt;h1 id=&#34;什么是数据结构？&#34;&gt;&lt;a href=&#34;#什么是数据结构？&#34; class=&#34;headerlink&#34; title=&#34;什么是数据结构？&#34;&gt;&lt;/a&gt;什么是数据结构？&lt;/h1&gt;&lt;p&gt;数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要数据结构&#34;&gt;&lt;a href=&#34;#为什么我们需要数据结构&#34; class=&#34;headerlink&#34; title=&#34;为什么我们需要数据结构&#34;&gt;&lt;/a&gt;为什么我们需要数据结构&lt;/h2&gt;&lt;p&gt;数据是程序的核心要素，因此数据结构的价值不言而喻。无论你在写什么程序，你都需要与数据打交道，比如员工工资、股票价格、杂货清单或者电话本。在不同场景下，数据需要以特定的方式存储，我们有不同的数据结构可以满足我们的需求。&lt;/p&gt;
&lt;h1 id=&#34;8种常用的数据结构&#34;&gt;&lt;a href=&#34;#8种常用的数据结构&#34; class=&#34;headerlink&#34; title=&#34;8种常用的数据结构&#34;&gt;&lt;/a&gt;8种常用的数据结构&lt;/h1&gt;&lt;p&gt;1.数组&lt;br&gt;2.栈&lt;br&gt;3.队列&lt;br&gt;4.链表&lt;br&gt;5.图&lt;br&gt;6.树&lt;br&gt;7.前缀树&lt;br&gt;8.哈希表&lt;/p&gt;
&lt;h2 id=&#34;1、数组&#34;&gt;&lt;a href=&#34;#1、数组&#34; class=&#34;headerlink&#34; title=&#34;1、数组&#34;&gt;&lt;/a&gt;1、数组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;(Array)大概是最简单，也是最常用的数据结构了。其他数据结构，比如栈和队列都是由数组衍生出来的&lt;/p&gt;
&lt;p&gt;下面展示了一个数组，他有四个元素&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/data-structures/main/image-20221111221359307.png&#34; alt=&#34;image-20221111221359307&#34;&gt;&lt;/p&gt;
&lt;p&gt;每一个元素的位置由数字编号，称为下标或者索引。大多数编程语言的第一个元素的下标为0。&lt;/p&gt;
&lt;p&gt;根据维度区分，有2种不同的数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一维数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数组的基本操作&#34;&gt;&lt;a href=&#34;#数组的基本操作&#34; class=&#34;headerlink&#34; title=&#34;数组的基本操作&#34;&gt;&lt;/a&gt;数组的基本操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Insert - 在某个索引处插入元素&lt;/li&gt;
&lt;li&gt;Get - 读取某个索引处的元素&lt;/li&gt;
&lt;li&gt;Delete - 删除某个索引处的元素&lt;/li&gt;
&lt;li&gt;Size - 获取数组的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;/data-structures/array/&#34;&gt;常见的数组代码面试题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-栈&#34;&gt;&lt;a href=&#34;#2-栈&#34; class=&#34;headerlink&#34; title=&#34;2. 栈&#34;&gt;&lt;/a&gt;2. 栈&lt;/h2&gt;&lt;p&gt;撤回，即 Ctrl+Z，是我们最常见的操作之一，大多数应用都会支持这个功能。你知道它是怎么实现的吗？答案是这样的：把之前的应用状态(限制个数)保存到内存中，最近的状态放到第一个。这时，我们需要栈(stack)来实现这个功能。&lt;/p&gt;
&lt;p&gt;栈中的元素采用 LIFO (Last In First Out)，即后进先出。&lt;/p&gt;
&lt;p&gt;下图的栈有 3 个元素，3 在最上面，因此它会被第一个移除&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/data-structures/main/image-20221112212908111.png&#34; alt=&#34;image-20221112212908111&#34;&gt;&lt;/p&gt;
&lt;p&gt;栈的基本操作 &lt;/p&gt;
&lt;p&gt;栈的基本操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Push —  在栈的最上方插入元素&lt;/li&gt;
&lt;li&gt;Pop — 返回栈最上方的元素，并将其删除&lt;/li&gt;
&lt;li&gt;isEmpty —  查询栈是否为空&lt;/li&gt;
&lt;li&gt;Top —  返回栈最上方的元素，并不删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;/data-structures/stack/&#34;&gt;常见的数组代码面试题&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <updated>2022-11-11T13:59:56.618Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/JavaScript/wrapper-object/</id>
        <title>js中包装对象</title>
        <link rel="alternate" href="https://www.yexingcheng.com/JavaScript/wrapper-object/"/>
        <content type="html">&lt;h1 id=&#34;先来看定义&#34;&gt;&lt;a href=&#34;#先来看定义&#34; class=&#34;headerlink&#34; title=&#34;先来看定义&#34;&gt;&lt;/a&gt;先来看定义&lt;/h1&gt;&lt;p&gt;对象是javascript语言最主要的数据类型，三种原始类型的值————Number,string,boolean在一定条件下，也会自动转为对象，也就是原始类型的&lt;code&gt;包装对象&lt;/code&gt;(wrapper)&lt;/p&gt;
&lt;p&gt;所谓&lt;code&gt;包装对象&lt;/code&gt; 指的是Number,string,boolean分别对应的Number,String,Boolean三个原生对象。这三个原生对象可以把原始类型的值变成(包装成)对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var v1 = new Number(123);
var v2 = new String(&amp;#39;abc&amp;#39;);
var v3 = new Boolean(true);

typeof v1 // &amp;quot;object&amp;quot;
typeof v2 // &amp;quot;object&amp;quot;
typeof v3 // &amp;quot;object&amp;quot;

v1 === 123 // false
v2 === &amp;#39;abc&amp;#39; // false
v3 === true // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，v1、v2、v3都是对象，且与对应的简单类型值不相等。&lt;/p&gt;
&lt;p&gt;包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Boolean&lt;/code&gt;这三个原生对象，如果不作为构造函数调用（即调用时不加new），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 字符串转为数值
Number(&amp;#39;123&amp;#39;) // 123

// 数值转为字符串
String(123) // &amp;quot;123&amp;quot;

// 数值转为布尔值
Boolean(123) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。&lt;/p&gt;
&lt;h1 id=&#34;实例方法&#34;&gt;&lt;a href=&#34;#实例方法&#34; class=&#34;headerlink&#34; title=&#34;实例方法&#34;&gt;&lt;/a&gt;实例方法&lt;/h1&gt;&lt;p&gt;三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从Object对象继承的方法:&lt;code&gt;valueOf()&lt;/code&gt;和&lt;code&gt;toString()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valueOf()&lt;br&gt;&lt;code&gt;valueOf()&lt;/code&gt;方法返回包装对象实例对应的原始类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new Number(123).valueOf()  // 123
new String(&amp;#39;abc&amp;#39;).valueOf() // &amp;quot;abc&amp;quot;
new Boolean(true).valueOf() // true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;toString()&lt;br&gt;&lt;code&gt;toString()&lt;/code&gt;方法返回对应的字符串形式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new Number(123).toString() // &amp;quot;123&amp;quot;
new String(&amp;#39;abc&amp;#39;).toString() // &amp;quot;abc&amp;quot;
new Boolean(true).toString() // &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原始类型与实例对象的自动转换&#34;&gt;&lt;a href=&#34;#原始类型与实例对象的自动转换&#34; class=&#34;headerlink&#34; title=&#34;原始类型与实例对象的自动转换&#34;&gt;&lt;/a&gt;原始类型与实例对象的自动转换&lt;/h2&gt;&lt;p&gt;某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。&lt;/p&gt;
&lt;p&gt;比如，字符串可以调用&lt;code&gt;length&lt;/code&gt;属性，返回字符串的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;abc&amp;#39;.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;abc&lt;/code&gt;是一个字符串，本身不是对象，不能调用&lt;code&gt;length&lt;/code&gt;属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用&lt;code&gt;length&lt;/code&gt;属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var str = &amp;#39;abc&amp;#39;;
str.length // 3

// 等同于
var strObj = new String(str)
// String &amp;#123;
//   0: &amp;quot;a&amp;quot;, 1: &amp;quot;b&amp;quot;, 2: &amp;quot;c&amp;quot;, length: 3, [[PrimitiveValue]]: &amp;quot;abc&amp;quot;
// &amp;#125;
strObj.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s = &amp;#39;Hello World&amp;#39;;
s.x = 123;
s.x // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。&lt;/p&gt;
&lt;h2 id=&#34;自定义方法&#34;&gt;&lt;a href=&#34;#自定义方法&#34; class=&#34;headerlink&#34; title=&#34;自定义方法&#34;&gt;&lt;/a&gt;自定义方法&lt;/h2&gt;&lt;p&gt;除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。&lt;/p&gt;
&lt;p&gt;比如，我们可以新增一个double方法，使得字符串和数字翻倍。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;String.prototype.double = function () &amp;#123;
  return this.valueOf() + this.valueOf();
&amp;#125;;

&amp;#39;abc&amp;#39;.double() // abcabc

Number.prototype.double = function () &amp;#123;
  return this.valueOf() + this.valueOf();
&amp;#125;;

(123).double() // 246
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码在String和Number这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后的123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。&lt;/p&gt;
&lt;h1 id=&#34;Boolean对象&#34;&gt;&lt;a href=&#34;#Boolean对象&#34; class=&#34;headerlink&#34; title=&#34;Boolean对象&#34;&gt;&lt;/a&gt;Boolean对象&lt;/h1&gt;&lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述:&#34;&gt;&lt;/a&gt;概述:&lt;/h2&gt;&lt;p&gt;Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var b = new Boolean(true);

typeof b // &amp;quot;object&amp;quot;
b.valueOf() // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的变量b是一个&lt;code&gt;Boolean&lt;/code&gt;对象的实例，它的类型是对象，值为布尔值&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;false&lt;/code&gt;对应的包装对象实例，布尔运算结果也是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;if (new Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true

if (new Boolean(false).valueOf()) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始值，本例为false。&lt;/p&gt;
&lt;h2 id=&#34;Boolean-函数的类型转换作用&#34;&gt;&lt;a href=&#34;#Boolean-函数的类型转换作用&#34; class=&#34;headerlink&#34; title=&#34;Boolean 函数的类型转换作用&#34;&gt;&lt;/a&gt;Boolean 函数的类型转换作用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt;对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时&lt;code&gt;Boolean&lt;/code&gt;就是一个单纯的工具方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(&amp;#39;&amp;#39;) // false
Boolean(NaN) // false

Boolean(1) // true
Boolean(&amp;#39;false&amp;#39;) // true
Boolean([]) // true
Boolean(&amp;#123;&amp;#125;) // true
Boolean(function () &amp;#123;&amp;#125;) // true
Boolean(/foo/) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中几种得到true的情况，都值得认真记住。&lt;/p&gt;
&lt;p&gt;顺便提一下，使用双重的否运算符（!）也可以将任意值转为对应的布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;!!undefined // false
!!null // false
!!0 // false
!!&amp;#39;&amp;#39; // false
!!NaN // false

!!1 // true
!!&amp;#39;false&amp;#39; // true
!![] // true
!!&amp;#123;&amp;#125; // true
!!function()&amp;#123;&amp;#125; // true
!!/foo/ // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，对于一些特殊值，&lt;code&gt;Boolean&lt;/code&gt;对象前面加不加&lt;code&gt;new&lt;/code&gt;，会得到完全相反的结果，必须小心。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;if (Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出

if (new Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true

if (Boolean(null)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出

if (new Boolean(null)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Number-对象&#34;&gt;&lt;a href=&#34;#Number-对象&#34; class=&#34;headerlink&#34; title=&#34;Number 对象&#34;&gt;&lt;/a&gt;Number 对象&lt;/h1&gt;&lt;h2 id=&#34;概述-1&#34;&gt;&lt;a href=&#34;#概述-1&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。&lt;/p&gt;
&lt;p&gt;作为构造函数时，它用于生成值为数值的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var n = new Number(1);
typeof n // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;Number&lt;/code&gt;对象作为构造函数使用，返回一个值为1的对象。&lt;/p&gt;
&lt;p&gt;作为工具函数时，它可以将任何类型的值转为数值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;Number(true) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;静态属性&#34;&gt;&lt;a href=&#34;#静态属性&#34; class=&#34;headerlink&#34; title=&#34;静态属性&#34;&gt;&lt;/a&gt;静态属性&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;对象拥有以下一些静态属性（即直接定义在&lt;code&gt;Number&lt;/code&gt;对象上的属性，而不是定义在实例上的属性）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;：正的无限，指向Infinity。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.NEGATIVE_INFINITY&lt;/code&gt;：负的无限，指向-Infinity。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.NaN&lt;/code&gt;：表示非数值，指向NaN。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MIN_VALUE&lt;/code&gt;：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应- 的，最接近0的负数为-&lt;code&gt;Number.MIN_VALUE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;：表示能够精确表示的最大整数，即9007199254740991。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt;：表示能够精确表示的最小整数，即-9007199254740991。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例方法&lt;br&gt;&lt;code&gt;Number&lt;/code&gt;对象有4个实例方法，都跟将数值转换成指定格式有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number.prototype.toString()&lt;/strong&gt;&lt;br&gt;&lt;code&gt;Numbe&lt;/code&gt;r对象部署了自己的&lt;code&gt;toString&lt;/code&gt;方法，用来将一个数值转为字符串形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(10).toString() // &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(10).toString(2) // &amp;quot;1010&amp;quot;
(10).toString(8) // &amp;quot;12&amp;quot;
(10).toString(16) // &amp;quot;a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10.toString(2)
// SyntaxError: Unexpected token ILLEGAL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为10加上括号，还可以在&lt;code&gt;10&lt;/code&gt;后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10..toString(2) // &amp;quot;1010&amp;quot;

// 其他方法还包括
10 .toString(2) // &amp;quot;1010&amp;quot;
10.0.toString(2) // &amp;quot;1010&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这实际上意味着，可以直接对一个小数使用&lt;code&gt;toString&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10.5.toString() // &amp;quot;10.5&amp;quot;
10.5.toString(2) // &amp;quot;1010.1&amp;quot;
10.5.toString(8) // &amp;quot;12.4&amp;quot;
10.5.toString(16) // &amp;quot;a.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过方括号运算符也可以调用&lt;code&gt;toString&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10[&amp;#39;toString&amp;#39;](2) // &amp;quot;1010&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用&lt;code&gt;parseInt&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number.prototype.toFixed()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toPrecision方法用于将一个数转为指定位数的有效数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(12.34).toPrecision(1) // &amp;quot;1e+1&amp;quot;
(12.34).toPrecision(2) // &amp;quot;12&amp;quot;
(12.34).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.34).toPrecision(4) // &amp;quot;12.34&amp;quot;
(12.34).toPrecision(5) // &amp;quot;12.340&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toPrecision&lt;/code&gt;方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出&lt;code&gt;RangeError&lt;/code&gt;错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toPrecision&lt;/code&gt;方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(12.35).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.25).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.15).toPrecision(3) // &amp;quot;12.2&amp;quot;
(12.45).toPrecision(3) // &amp;quot;12.4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;String-对象&#34;&gt;&lt;a href=&#34;#String-对象&#34; class=&#34;headerlink&#34; title=&#34;String 对象&#34;&gt;&lt;/a&gt;String 对象&lt;/h1&gt;&lt;h2 id=&#34;概述-2&#34;&gt;&lt;a href=&#34;#概述-2&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s1 = &amp;#39;abc&amp;#39;;
var s2 = new String(&amp;#39;abc&amp;#39;);

typeof s1 // &amp;quot;string&amp;quot;
typeof s2 // &amp;quot;object&amp;quot;

s2.valueOf() // &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串对象是一个类似数组的对象（很像数组，但不是数组）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new String(&amp;#39;abc&amp;#39;)
// String &amp;#123;0: &amp;quot;a&amp;quot;, 1: &amp;quot;b&amp;quot;, 2: &amp;quot;c&amp;quot;, length: 3&amp;#125;

(new String(&amp;#39;abc&amp;#39;))[1] // &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例属性&#34;&gt;&lt;a href=&#34;#实例属性&#34; class=&#34;headerlink&#34; title=&#34;实例属性&#34;&gt;&lt;/a&gt;实例属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;String.prototype.length&lt;/strong&gt;&lt;br&gt;字符串实例的length属性返回字符串的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;abc&amp;#39;.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;静态方法&#34;&gt;&lt;a href=&#34;#静态方法&#34; class=&#34;headerlink&#34; title=&#34;静态方法:&#34;&gt;&lt;/a&gt;静态方法:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;String.prototype.match()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;at&amp;#39;) // [&amp;quot;at&amp;quot;]
&amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;xt&amp;#39;) // null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回的数组还有&lt;code&gt;index&lt;/code&gt;属性和&lt;code&gt;input&lt;/code&gt;属性，分别表示匹配字符串开始的位置和原始字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var matches = &amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;at&amp;#39;);
matches.index // 1
matches.input // &amp;quot;cat, bat, sat, fat&amp;quot;
match方法还可以使用正则表达式作为参数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;String.prototype.localeCompare()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;localeCompare&lt;/code&gt;方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;apple&amp;#39;.localeCompare(&amp;#39;banana&amp;#39;) // -1
&amp;#39;apple&amp;#39;.localeCompare(&amp;#39;apple&amp;#39;) // 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;B&amp;#39; &amp;gt; &amp;#39;a&amp;#39; // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，字母B小于字母a。因为 JavaScript 采用的是 Unicode 码点比较，B的码点是&lt;code&gt;66&lt;/code&gt;，而a的码点是&lt;code&gt;97&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;localeCompare&lt;/code&gt;方法会考虑自然语言的排序情况，将B排在a的前面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;B&amp;#39;.localeCompare(&amp;#39;a&amp;#39;) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;localeCompare&lt;/code&gt;方法返回整数1，表示B较大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;localeCompare&lt;/code&gt;还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;ä&amp;#39;.localeCompare(&amp;#39;z&amp;#39;, &amp;#39;de&amp;#39;) // -1
&amp;#39;ä&amp;#39;.localeCompare(&amp;#39;z&amp;#39;, &amp;#39;sv&amp;#39;) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，de表示德语，sv表示瑞典语。德语中，ä小于z，所以返回-1；瑞典语中，ä大于z，所以返回1。&lt;/p&gt;
</content>
        <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <updated>2022-11-08T13:08:22.631Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/JavaScript/Variable-recycling/</id>
        <title>JS变量回收机制</title>
        <link rel="alternate" href="https://www.yexingcheng.com/JavaScript/Variable-recycling/"/>
        <content type="html">&lt;h1 id=&#34;先看题目&#34;&gt;&lt;a href=&#34;#先看题目&#34; class=&#34;headerlink&#34; title=&#34;先看题目:&#34;&gt;&lt;/a&gt;先看题目:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下列代码有几个变量没有被回收？&lt;code&gt;点我查看&lt;/code&gt; [3]{.gap}。 {.quiz .fill}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即i和add,局部变量有一个i，因为局部变量被另一个作用域引用，所以局部变量i也不回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var i = 1;
var i = 2;
var add = function() &amp;#123;
    var i = 0;
    return function()
&amp;#123;
        i++;
        console.log(i);
    &amp;#125;
&amp;#125;();
add();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;变量回收原则&#34;&gt;&lt;a href=&#34;#变量回收原则&#34; class=&#34;headerlink&#34; title=&#34;变量回收原则:&#34;&gt;&lt;/a&gt;变量回收原则:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;全局变量不会回收&lt;/li&gt;
&lt;li&gt;局部变量会被回收,也就是函数一旦运行完后，函数内部的东西都会被销毁&lt;/li&gt;
&lt;li&gt;只要被另外一个作用域引用就不会被回收&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var i = 1;   // 全局变量不会被回收
var i = 2;   // 这里重复声明变量i,因此var声明被忽略，只是把i赋值为2
var add = function() &amp;#123;  // 全局变量不会被回收
    var i = 0;  // 局部变量
    return function() &amp;#123;
        i++;
        console.log(i); // 被另一个作用域引用导致不会被回收
    &amp;#125;
&amp;#125;();
add();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;JS的垃圾回收机制&#34;&gt;&lt;a href=&#34;#JS的垃圾回收机制&#34; class=&#34;headerlink&#34; title=&#34;JS的垃圾回收机制&#34;&gt;&lt;/a&gt;JS的垃圾回收机制&lt;/h1&gt;&lt;h2 id=&#34;标记清除&#34;&gt;&lt;a href=&#34;#标记清除&#34; class=&#34;headerlink&#34; title=&#34;标记清除&#34;&gt;&lt;/a&gt;标记清除&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;js中最常见的垃圾回收方式是标记清除&lt;br&gt;标记清除就是从根部出发，看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它。&lt;br&gt;这个过程大致分为三步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器创建roots列表,roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局变量window作为root,也就是所谓的跟部&lt;/li&gt;
&lt;li&gt;从根部出发检查所有的roots,所有的children也会被递归检查，能从root到达的都会被标记为active&lt;/li&gt;
&lt;li&gt;未被标记为active的数据被认定为不再需要，垃圾回收器开始释放他们&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:&lt;br&gt;当一个对象&lt;code&gt;零引用&lt;/code&gt;时，我们从根部&lt;code&gt;一定无法到达&lt;/code&gt;。&lt;br&gt;但反过来，从&lt;code&gt;根部无法到达&lt;/code&gt;的&lt;code&gt;不一定&lt;/code&gt;是严格意义上的零引用，比如循环引用，所以标记清除要&lt;code&gt;更优于引用计数&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;引用计数&#34;&gt;&lt;a href=&#34;#引用计数&#34; class=&#34;headerlink&#34; title=&#34;引用计数&#34;&gt;&lt;/a&gt;引用计数&lt;/h2&gt;&lt;p&gt;工作原理:工作原理：跟踪记录每个值被引用的次数。&lt;/p&gt;
&lt;h2 id=&#34;什么情况会引起内存泄漏-无法释放已经不使用的内存&#34;&gt;&lt;a href=&#34;#什么情况会引起内存泄漏-无法释放已经不使用的内存&#34; class=&#34;headerlink&#34; title=&#34;什么情况会引起内存泄漏(无法释放已经不使用的内存)?&#34;&gt;&lt;/a&gt;什么情况会引起内存泄漏(无法释放已经不使用的内存)?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、意外的全局变量引起的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：全局变量，不会被回收。&lt;br&gt;解决：使用严格模式避免。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2、闭包引起的内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：闭包可以维持函数内局部变量，使其得不到释放。&lt;br&gt;解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3、没有清理的DOM元素引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：虽然别的地方删除了，但是对象中还存在对dom的引用&lt;br&gt;解决：手动删除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4、被遗忘的定时器或者回调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。&lt;br&gt;解决：手动删除定时器和dom。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5、子元素存在引用引起的内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。&lt;br&gt;解决：手动删除清空。&lt;/p&gt;
</content>
        <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <updated>2022-11-06T16:09:01.945Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/algorithm/toTree/</id>
        <title>扁平数据结构转tree</title>
        <link rel="alternate" href="https://www.yexingcheng.com/algorithm/toTree/"/>
        <content type="html">&lt;h1 id=&#34;题目要求&#34;&gt;&lt;a href=&#34;#题目要求&#34; class=&#34;headerlink&#34; title=&#34;题目要求&#34;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;首先来看下题目:打平的数据内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;let arr = [
    &amp;#123;id: 1, name: &amp;#39;部门1&amp;#39;, pid: 0&amp;#125;,
    &amp;#123;id: 2, name: &amp;#39;部门2&amp;#39;, pid: 1&amp;#125;,
    &amp;#123;id: 3, name: &amp;#39;部门3&amp;#39;, pid: 1&amp;#125;,
    &amp;#123;id: 4, name: &amp;#39;部门4&amp;#39;, pid: 3&amp;#125;,
    &amp;#123;id: 5, name: &amp;#39;部门5&amp;#39;, pid: 4&amp;#125;,
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想要的输出结果如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;[
    &amp;#123;
        &amp;quot;id&amp;quot;: 1,
        &amp;quot;name&amp;quot;: &amp;quot;部门1&amp;quot;,
        &amp;quot;pid&amp;quot;: 0,
        &amp;quot;children&amp;quot;: [
            &amp;#123;
                &amp;quot;id&amp;quot;: 2,
                &amp;quot;name&amp;quot;: &amp;quot;部门2&amp;quot;,
                &amp;quot;pid&amp;quot;: 1,
                &amp;quot;children&amp;quot;: []
            &amp;#125;,
            &amp;#123;
                &amp;quot;id&amp;quot;: 3,
                &amp;quot;name&amp;quot;: &amp;quot;部门3&amp;quot;,
                &amp;quot;pid&amp;quot;: 1,
                &amp;quot;children&amp;quot;: [
                    // 结果 ,,,
                ]
            &amp;#125;
        ]
    &amp;#125;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先我们要了解一个概念，衡量一个算法的好坏，主要看算法的时间复杂度和空间复杂度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 随着n的不断增大，时间复杂度不断增大，算法花费时间越多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;时间复杂度&#34;&gt;&lt;a href=&#34;#时间复杂度&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度&#34;&gt;&lt;/a&gt;时间复杂度&lt;/h2&gt;&lt;h3 id=&#34;计算方法&#34;&gt;&lt;a href=&#34;#计算方法&#34; class=&#34;headerlink&#34; title=&#34;计算方法&#34;&gt;&lt;/a&gt;计算方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;选取相对增长最高的项&lt;/li&gt;
&lt;li&gt;最高项系数是都化为1&lt;/li&gt;
&lt;li&gt;若是常数的话用O(1)表示 举个例子：如f(n)&amp;#x3D;3*n^4+3n+300 则 O(n)&amp;#x3D;n^4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 举例如下：代码执行100次，是一个常数，复杂度也是O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    let x = 1;
    while (x &amp;lt;100) &amp;#123;
     x++;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;  for (i = 0; i &amp;lt; n; i++)&amp;#123;
         for (j = 0; j &amp;lt; n; j++) &amp;#123;
             // ...code
         &amp;#125;
     &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;循环不仅与n有关，还与执行循环判断条件有关。举例如下：在代码中，如果arr[i]不等于1的话，时间复杂度是O(n)。如果arr[i]等于1的话，循环不执行，时间复杂度是O(0)。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    for(var i = 0; i&amp;lt;n &amp;amp;&amp;amp; arr[i] !=1; i++) &amp;#123;
    // ...code
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;空间复杂度&#34;&gt;&lt;a href=&#34;#空间复杂度&#34; class=&#34;headerlink&#34; title=&#34;空间复杂度&#34;&gt;&lt;/a&gt;空间复杂度&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算方法-1&#34;&gt;&lt;a href=&#34;#计算方法-1&#34; class=&#34;headerlink&#34; title=&#34;计算方法&#34;&gt;&lt;/a&gt;计算方法&lt;/h3&gt;&lt;p&gt;1、 忽略常数，用O(1)表示&lt;/p&gt;
&lt;p&gt;2、 递归算法的空间复杂度 &amp;#x3D; （递归深度n）*(每次递归所要的辅助空间)&lt;/p&gt;
&lt;p&gt;计算空间复杂度的简单几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅仅只复制单个变量，空间复杂度为O(1)。 以下例子空间复杂度为O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;   let a = 1;
   let b = 2;
   let c = 3;
   console.log(&amp;#39;输出a,b,c&amp;#39;, a, b, c);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;递归实现，调用fun函数，每次都创建一个变量K，调用n次，空间复杂度O(n*1) &amp;#x3D; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    function fun(n) &amp;#123;
       let k = 10;
       if (n == k) &amp;#123;
           return n;
       &amp;#125; else &amp;#123;
           return fun(++n)
       &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;不考虑性能实现，递归遍历查找&#34;&gt;&lt;a href=&#34;#不考虑性能实现，递归遍历查找&#34; class=&#34;headerlink&#34; title=&#34;不考虑性能实现，递归遍历查找&#34;&gt;&lt;/a&gt;不考虑性能实现，递归遍历查找&lt;/h1&gt;</content>
        <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
        <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
        <updated>2022-11-04T02:11:00.788Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/JavaScript/Array.Methods/</id>
        <title>JS中数组方法总结</title>
        <link rel="alternate" href="https://www.yexingcheng.com/JavaScript/Array.Methods/"/>
        <content type="html">&lt;h1 id=&#34;concat&#34;&gt;&lt;a href=&#34;#concat&#34; class=&#34;headerlink&#34; title=&#34;concat()&#34;&gt;&lt;/a&gt;concat()&lt;/h1&gt;&lt;p&gt;**&lt;code&gt;concat()&lt;/code&gt;**此方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;&lt;a href=&#34;#参数&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;p&gt;一个或多个数组&lt;/p&gt;
&lt;h2 id=&#34;返回值&#34;&gt;&lt;a href=&#34;#返回值&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h2&gt;&lt;p&gt;一个新数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const array1 = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;];
const array2 = [&amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;];
const array3 = array1.concat(array2);

console.log(array3);
// expected output: Array [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;copyWithin&#34;&gt;&lt;a href=&#34;#copyWithin&#34; class=&#34;headerlink&#34; title=&#34;copyWithin()&#34;&gt;&lt;/a&gt;copyWithin()&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;copyWithin()&lt;/code&gt;&lt;/strong&gt; 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;copyWithin(target, start, end)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数-1&#34;&gt;&lt;a href=&#34;#参数-1&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;target&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;0 为基底的索引，复制序列到该位置。如果是负数，&lt;code&gt;target&lt;/code&gt; 将从末尾开始计算。如果 &lt;code&gt;target&lt;/code&gt; 大于等于 &lt;code&gt;arr.length&lt;/code&gt;，将不会发生拷贝。如果 &lt;code&gt;target&lt;/code&gt; 在 &lt;code&gt;start&lt;/code&gt; 之后，复制的序列将被修改以符合 &lt;code&gt;arr.length&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;start&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;0 为基底的索引，开始复制元素的起始位置。如果是负数，&lt;code&gt;start&lt;/code&gt; 将从末尾开始计算。如果 &lt;code&gt;start&lt;/code&gt; 被忽略，&lt;code&gt;copyWithin&lt;/code&gt; 将会从 0 开始复制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;0 为基底的索引，开始复制元素的结束位置。&lt;code&gt;copyWithin&lt;/code&gt; 将会拷贝到该位置，但不包括 &lt;code&gt;end&lt;/code&gt; 这个位置的元素。如果是负数， &lt;code&gt;end&lt;/code&gt; 将从末尾开始计算。如果 &lt;code&gt;end&lt;/code&gt; 被忽略，&lt;code&gt;copyWithin&lt;/code&gt; 方法将会一直复制至数组结尾（默认为 &lt;code&gt;arr.length&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;返回值-1&#34;&gt;&lt;a href=&#34;#返回值-1&#34; class=&#34;headerlink&#34; title=&#34;返回值 :&#34;&gt;&lt;/a&gt;返回值 :&lt;/h2&gt;&lt;p&gt;改变后的数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;[1, 2, 3, 4, 5].copyWithin(-2)
// [1, 2, 3, 1, 2]

[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]

[1, 2, 3, 4, 5].copyWithin(-2, -3, -1)
// [1, 2, 3, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;filter&#34;&gt;&lt;a href=&#34;#filter&#34; class=&#34;headerlink&#34; title=&#34;filter()&#34;&gt;&lt;/a&gt;filter()&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/strong&gt; 方法创建给定数组一部分的浅拷贝 ,其包含通过所提供函数实现的测试的所有元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 箭头函数
filter((element) =&amp;gt; &amp;#123; /* … */ &amp;#125; )
filter((element, index) =&amp;gt; &amp;#123; /* … */ &amp;#125; )
filter((element, index, array) =&amp;gt; &amp;#123; /* … */ &amp;#125; )

// 回调函数
filter(callbackFn)
filter(callbackFn, thisArg)

// 内联回调函数
filter(function(element) &amp;#123; /* … */ &amp;#125;)
filter(function(element, index) &amp;#123; /* … */ &amp;#125;)
filter(function(element, index, array)&amp;#123; /* … */ &amp;#125;)
filter(function(element, index, array) &amp;#123; /* … */ &amp;#125;, thisArg)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数：&#34;&gt;&lt;a href=&#34;#参数：&#34; class=&#34;headerlink&#34; title=&#34;参数：&#34;&gt;&lt;/a&gt;参数：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;callbackFn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用来测试数组中每个元素的函数。返回 &lt;code&gt;true&lt;/code&gt; 表示该元素通过测试，保留该元素，&lt;code&gt;false&lt;/code&gt; 则不保留。它接受以下三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;element&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组中当前正在处理的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;正在处理的元素在数组中的索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;array&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用了 &lt;code&gt;filter()&lt;/code&gt; 的数组本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;thisArg&lt;/code&gt;可选&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;callbackFn&lt;/code&gt; 时，用于 &lt;code&gt;this&lt;/code&gt; 的值。&lt;/p&gt;
&lt;h2 id=&#34;返回值-2&#34;&gt;&lt;a href=&#34;#返回值-2&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h2&gt;&lt;p&gt;​	一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。&lt;/p&gt;
&lt;h1 id=&#34;flat&#34;&gt;&lt;a href=&#34;#flat&#34; class=&#34;headerlink&#34; title=&#34;flat()&#34;&gt;&lt;/a&gt;flat()&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;flat()&lt;/code&gt;&lt;/strong&gt; 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
// expected output: [0, 1, 2, [3, 4]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数-2&#34;&gt;&lt;a href=&#34;#参数-2&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;depth&lt;/code&gt; 可选&lt;/p&gt;
&lt;p&gt;指定要提取嵌套数组的结构深度，默认值为 1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;返回值-3&#34;&gt;&lt;a href=&#34;#返回值-3&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h2&gt;&lt;p&gt;一个包含将数组与子数组中所有元素的新数组。&lt;/p&gt;
&lt;h1 id=&#34;flatMap&#34;&gt;&lt;a href=&#34;#flatMap&#34; class=&#34;headerlink&#34; title=&#34;flatMap()&#34;&gt;&lt;/a&gt;flatMap()&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;flatMap()&lt;/code&gt;&lt;/strong&gt; 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFw&#34;&gt;map&lt;/span&gt; 连着深度值为 1 的 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdA==&#34;&gt;flat&lt;/span&gt; 几乎相同，但 &lt;code&gt;flatMap&lt;/code&gt; 通常在合并成一种方法的效率稍微高一些。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;const arr1 = [1, 2, [3], [4, 5], 6, []];

const flattened = arr1.flatMap(num =&amp;gt; num);

console.log(flattened);
// expected output: Array [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数-3&#34;&gt;&lt;a href=&#34;#参数-3&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;callback&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以生成一个新数组中的元素的函数，可以传入三个参数：&lt;code&gt;currentValue&lt;/code&gt;当前正在数组中处理的元素&lt;code&gt;index&lt;/code&gt;可选可选的。数组中正在处理的当前元素的索引。&lt;code&gt;array&lt;/code&gt;可选可选的。被调用的 &lt;code&gt;map&lt;/code&gt; 数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thisArg&lt;/code&gt;可选&lt;/p&gt;
&lt;p&gt;可选的。执行 &lt;code&gt;callback&lt;/code&gt; 函数时 使用的&lt;code&gt;this&lt;/code&gt; 值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;返回值-4&#34;&gt;&lt;a href=&#34;#返回值-4&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h2&gt;&lt;p&gt;一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 &lt;code&gt;depth&lt;/code&gt; 值为 1。&lt;/p&gt;
&lt;h2 id=&#34;map-和flatMap-的区别&#34;&gt;&lt;a href=&#34;#map-和flatMap-的区别&#34; class=&#34;headerlink&#34; title=&#34;map()和flatMap()的区别&#34;&gt;&lt;/a&gt;map()和flatMap()的区别&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var arr1 = [1, 2, 3, 4];

arr1.map(x =&amp;gt; [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x =&amp;gt; [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap(x =&amp;gt; [[x * 2]]);
// [[2], [4], [6], [8]]
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
        <category term="Array" scheme="https://www.yexingcheng.com/tags/Array/" />
        <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
        <updated>2022-11-03T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/Screeps/action1/</id>
        <title>screeps日记 part1</title>
        <link rel="alternate" href="https://www.yexingcheng.com/Screeps/action1/"/>
        <content type="html"></content>
        <category term="screeps" scheme="https://www.yexingcheng.com/categories/screeps/" />
        <category term="javascript" scheme="https://www.yexingcheng.com/tags/javascript/" />
        <category term="screeps" scheme="https://www.yexingcheng.com/tags/screeps/" />
        <updated>2022-10-30T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/Screeps/chinese/</id>
        <title>screeps汉化（steam)</title>
        <link rel="alternate" href="https://www.yexingcheng.com/Screeps/chinese/"/>
        <content type="html">&lt;p&gt;如果你对 screeps 有所了解的话，那么你应该曾经听说过这个游戏的 steam 版本是基于 node 和 nw.js 进行开发的，说白了就是一个套壳浏览器，本质上还是一个 web 应用。既然是 web 应用，那么就可以用我们的 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dyZWFzeWZvcmsub3JnL3poLUNOL3NjcmlwdHMvNDE2NjUxLXNjcmVlcHMtY2hpbmVzZS1wYWNr&#34;&gt;web 端汉化补丁&lt;/span&gt; 进行汉化。&lt;/p&gt;
&lt;p&gt;这里我们看到默认是全英文版本，但由于本人是英语小白，又懒得去一个一个翻译，所以就想翻译这个界面&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221102235142846.png&#34; alt=&#34;image-20221102235142846&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;汉化步骤&#34;&gt;&lt;a href=&#34;#汉化步骤&#34; class=&#34;headerlink&#34; title=&#34;汉化步骤&#34;&gt;&lt;/a&gt;汉化步骤&lt;/h1&gt;&lt;p&gt;实际操作也非常的简单，首先我们通过 steam 打开 screeps 的本地目录：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221102235357536.png&#34; alt=&#34;image-20221102235357536&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221102235416601.png&#34; alt=&#34;image-20221102235416601&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后，你应该可以 &lt;strong&gt;找到一个名为 package.nw 的文件&lt;/strong&gt;，这个就是游戏的源码包。&lt;/p&gt;
&lt;p&gt;然后用压缩文件的格式打开，这里我用的是WINRAR&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221102235616013.png&#34; alt=&#34;image-20221102235616013&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开之后我们可以 &lt;strong&gt;找到一个名为 index.html 的文件，对其右键并选择编辑&lt;/strong&gt;，同理不要进行解压。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221102235706903.png&#34; alt=&#34;image-20221102235706903&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后我们添加汉化脚本到里面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;script src=&amp;quot;https://screeps-cn.gitee.io/screeps-chinese-pack-release/main.js&amp;quot; async defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们进入游戏发现已经汉化完毕&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/Screeps/chinese/image-20221103000423147.png&#34; alt=&#34;image-20221103000423147&#34;&gt;&lt;/p&gt;
</content>
        <category term="screeps" scheme="https://www.yexingcheng.com/categories/screeps/" />
        <category term="javascript" scheme="https://www.yexingcheng.com/tags/javascript/" />
        <category term="screeps" scheme="https://www.yexingcheng.com/tags/screeps/" />
        <updated>2022-10-29T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/React/react-router-params/</id>
        <title>React路由传参的几种方式</title>
        <link rel="alternate" href="https://www.yexingcheng.com/React/react-router-params/"/>
        <content type="html">&lt;h1 id=&#34;一、函数式组件&#34;&gt;&lt;a href=&#34;#一、函数式组件&#34; class=&#34;headerlink&#34; title=&#34;一、函数式组件&#34;&gt;&lt;/a&gt;一、函数式组件&lt;/h1&gt;&lt;p&gt;首先新建两个页面并导入到app.tsx页面中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React,  from &amp;quot;react&amp;quot;;

const From = () =&amp;gt; &amp;#123;
  return &amp;lt;&amp;gt;
  &amp;lt;h1&amp;gt;函数式组件传值&amp;lt;/h1&amp;gt;
  &amp;lt;/&amp;gt;;
&amp;#125;;

export default From;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React,  from &amp;#39;react&amp;#39;;


const To = () =&amp;gt; &amp;#123;


  return (
    &amp;lt;&amp;gt;
    
    &amp;lt;h1&amp;gt;函数式组件接受值&amp;lt;/h1&amp;gt;
    &amp;lt;/&amp;gt;
  )

&amp;#125;;

export default To;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;tsx&#34;&gt;import React from &amp;#39;react&amp;#39;;
import &amp;#123; Route, Routes &amp;#125; from &amp;#39;react-router-dom&amp;#39;
import From from &amp;#39;./From-function&amp;#39;;
import To from &amp;#39;./To-function&amp;#39;;

const App= () =&amp;gt; &amp;#123;


  return (

    &amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;#39;/&amp;#39; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125;&amp;gt;&amp;lt;/Route&amp;gt;
      &amp;lt;Route path=&amp;#39;to&amp;#39; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125;&amp;gt;&amp;lt;/Route&amp;gt;
    &amp;lt;/Routes&amp;gt;
  )

&amp;#125;;

export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import App from &amp;#39;./router-params/App&amp;#39;
const root = ReactDOM.createRoot(document.getElementById(&amp;#39;root&amp;#39;));
root.render(
  &amp;lt;BrowserRouter&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/BrowserRouter&amp;gt;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1、params传参&#34;&gt;&lt;a href=&#34;#1、params传参&#34; class=&#34;headerlink&#34; title=&#34;1、params传参&#34;&gt;&lt;/a&gt;1、params传参&lt;/h2&gt;&lt;p&gt;优点：刷新页面，参数不丢失&lt;/p&gt;
&lt;p&gt;缺点：1.只能传字符串，传值过多url会变得很长 2. 参数必须在路由上配置&lt;/p&gt;
&lt;p&gt;是通过在路由后面写&amp;#x2F;:参数名将路径配合?name&amp;#x3D;xxx的形式&lt;/p&gt;
&lt;p&gt;通过useParams来获取路径参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;&amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to:number&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;From组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React from &amp;quot;react&amp;quot;;
import &amp;#123; useNavigate &amp;#125; from &amp;#39;react-router-dom&amp;#39;;
const From = () =&amp;gt; &amp;#123;

  const navigate = useNavigate()

  const to =()=&amp;gt;&amp;#123;
    navigate(&amp;#39;to:666&amp;#39;)
  &amp;#125;
  return (&amp;lt;&amp;gt;
  &amp;lt;h1&amp;gt;函数式组件传值&amp;lt;/h1&amp;gt;
  &amp;lt;button onClick=&amp;#123;()=&amp;gt;&amp;#123;to()&amp;#125;&amp;#125;&amp;gt;传参&amp;lt;/button&amp;gt;
  &amp;lt;/&amp;gt;)
&amp;#125;;

export default From;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; FC &amp;#125; from &amp;#39;react&amp;#39;;
import &amp;#123;useParams&amp;#125; from &amp;#39;react-router-dom&amp;#39;

const To = () =&amp;gt; &amp;#123;
  const params = useParams()  
  console.log(params)

  return (
    &amp;lt;&amp;gt;

    &amp;lt;h1&amp;gt;函数式组件接受值&amp;lt;/h1&amp;gt;
    传递的参数为&amp;#123;params.number&amp;#125;
    &amp;lt;/&amp;gt;
  )

&amp;#125;;

export default To;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030173426778.png&#34; alt=&#34;image-20221030173426778&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2、-search传参&#34;&gt;&lt;a href=&#34;#2、-search传参&#34; class=&#34;headerlink&#34; title=&#34;2、. search传参&#34;&gt;&lt;/a&gt;2、. search传参&lt;/h2&gt;&lt;p&gt;优点：刷新页面，参数不丢失&lt;/p&gt;
&lt;p&gt;缺点：只能传字符串，传值过多url会变得很长，获取参数需要自定义hooks&lt;/p&gt;
&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;    &amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;from组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import React from &amp;quot;react&amp;quot;;
import &amp;#123; useNavigate &amp;#125; from &amp;#39;react-router-dom&amp;#39;;
const From = () =&amp;gt; &amp;#123;

  const navigate = useNavigate()


  const search =()=&amp;gt;&amp;#123;
    navigate(&amp;#39;to/?num=666&amp;#39;)
  &amp;#125;


  return (&amp;lt;&amp;gt;
  &amp;lt;h1&amp;gt;函数式组件传值&amp;lt;/h1&amp;gt;
  &amp;lt;button onClick=&amp;#123;()=&amp;gt;&amp;#123;search()&amp;#125;&amp;#125;&amp;gt;search传参&amp;lt;/button&amp;gt;

  &amp;lt;/&amp;gt;)
&amp;#125;;

export default From;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import React from &amp;#39;react&amp;#39;;
import &amp;#123; useParams, useSearchParams ,useLocation&amp;#125; from &amp;#39;react-router-dom&amp;#39;;

const To = () =&amp;gt; &amp;#123;
const [search] = useSearchParams()
console.log(search.get(&amp;#39;num&amp;#39;));


  return (
    &amp;lt;&amp;gt;

    &amp;lt;h1&amp;gt;函数式组件接受值&amp;lt;/h1&amp;gt;
    
    search传递的参数为
   
    &amp;lt;/&amp;gt;
  )

&amp;#125;;

export default To;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030190608909.png&#34; alt=&#34;image-20221030190608909&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3、state传参&#34;&gt;&lt;a href=&#34;#3、state传参&#34; class=&#34;headerlink&#34; title=&#34;3、state传参&#34;&gt;&lt;/a&gt;3、state传参&lt;/h2&gt;&lt;p&gt;优点：可以传对象&lt;/p&gt;
&lt;p&gt;缺点： &lt;code&gt;&amp;lt;HashRouter&amp;gt;&lt;/code&gt;刷新页面，参数丢失&lt;/p&gt;
&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;&amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;from&lt;/code&gt;组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React from &amp;quot;react&amp;quot;;
import &amp;#123; useNavigate &amp;#125; from &amp;#39;react-router-dom&amp;#39;;
const From = () =&amp;gt; &amp;#123;

  const navigate = useNavigate()



  const state = ()=&amp;gt;&amp;#123;

    navigate(&amp;#39;to&amp;#39;,&amp;#123;state:&amp;#123;
      name:&amp;#39;叶星辰&amp;#39;,
      age:&amp;#39;18&amp;#39;,
      hobby:&amp;quot;敲代码&amp;quot;
    &amp;#125;
  
    &amp;#125;)
  &amp;#125;
  return (&amp;lt;&amp;gt;
  &amp;lt;h1&amp;gt;函数式组件传值&amp;lt;/h1&amp;gt;

  &amp;lt;button onClick=&amp;#123;()=&amp;gt;&amp;#123;state()&amp;#125;&amp;#125;&amp;gt;state传参&amp;lt;/button&amp;gt;
  &amp;lt;/&amp;gt;)
&amp;#125;;

export default From;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React from &amp;#39;react&amp;#39;;
import &amp;#123; useParams, useSearchParams ,useLocation&amp;#125; from &amp;#39;react-router-dom&amp;#39;;

const To = () =&amp;gt; &amp;#123;

const &amp;#123; state: &amp;#123; name, age, hobby &amp;#125; &amp;#125; = useLocation()

  return (
    &amp;lt;&amp;gt;
    statec传递的参数为姓名&amp;#123;name&amp;#125;年纪&amp;#123;age&amp;#125;爱好&amp;#123;hobby&amp;#125;
    &amp;lt;/&amp;gt;
  )

&amp;#125;;

export default To;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030180814827.png&#34; alt=&#34;image-20221030180814827&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二、类组件&#34;&gt;&lt;a href=&#34;#二、类组件&#34; class=&#34;headerlink&#34; title=&#34;二、类组件&#34;&gt;&lt;/a&gt;二、类组件&lt;/h1&gt;&lt;p&gt;类组件不能用到useNavigate等hooks,所以采用NavLink的方式跳转路由，同理，函数式组件中也可以用NavLink的方式跳转路由&lt;/p&gt;
&lt;p&gt;如果不用withRouter，发现组件的this.props是一个空对象&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030194100624.png&#34; alt=&#34;image-20221030194100624&#34;&gt;&lt;/p&gt;
&lt;p&gt;经过各方查阅，我们在react-router-dom v6版本中，已经去除了withRouter，所以在这里我们可以自己封装，但还是推荐使用函数式组件hooks&lt;/p&gt;
&lt;p&gt;js版本:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;import &amp;#123; useLocation, useNavigate &amp;#125; from &amp;quot;react-router-dom&amp;quot;;
export function withRouter( Child ) &amp;#123;
  return ( props ) =&amp;gt; &amp;#123;
    const location = useLocation();
    const navigate = useNavigate();
    const params = useParams();
    return &amp;lt;Child &amp;#123; ...props &amp;#125; navigate=&amp;#123; navigate &amp;#125; location=&amp;#123; location &amp;#125; params=&amp;#123; params &amp;#125;/&amp;gt;;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ts版本:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;ts&#34;&gt;import React from &amp;quot;react&amp;quot;;
import &amp;#123; NavigateFunction, useLocation, useNavigate, useParams &amp;#125; from &amp;quot;react-router&amp;quot;;

export interface RoutedProps&amp;lt;Params = any, State = any&amp;gt; &amp;#123;
    location: State;
    navigate: NavigateFunction;
    params: Params;
&amp;#125;


export function withRouter&amp;lt;P extends RoutedProps&amp;gt;( Child: React.ComponentClass&amp;lt;P&amp;gt; ) &amp;#123;
    return ( props: Omit&amp;lt;P, keyof RoutedProps&amp;gt; ) =&amp;gt; &amp;#123;
        const location = useLocation();
        const navigate = useNavigate();
        const params = useParams();
        return &amp;lt;Child &amp;#123; ...props as P &amp;#125; navigate=&amp;#123; navigate &amp;#125; location=&amp;#123; location &amp;#125; params=&amp;#123; params &amp;#125;/&amp;gt;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1、params传参-1&#34;&gt;&lt;a href=&#34;#1、params传参-1&#34; class=&#34;headerlink&#34; title=&#34;1、params传参&#34;&gt;&lt;/a&gt;1、params传参&lt;/h2&gt;&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;&amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to:number&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;From组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; NavLink, Link &amp;#125; from &amp;quot;react-router-dom&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
class FromClass extends Component &amp;#123;
  render() &amp;#123;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;类组件传参&amp;lt;/h1&amp;gt;
        &amp;lt;Link to=&amp;#123;&amp;quot;/to:666&amp;quot;&amp;#125;&amp;gt;详情&amp;lt;/Link&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(FromClass);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
class ToClass extends Component &amp;#123;
  render() &amp;#123;
    return (
      &amp;lt;div&amp;gt;
        params传递的参数为&amp;#123;this.props.params.number&amp;#125;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(ToClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030195320898.png&#34; alt=&#34;image-20221030195320898&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2、-search传参-1&#34;&gt;&lt;a href=&#34;#2、-search传参-1&#34; class=&#34;headerlink&#34; title=&#34;2、. search传参&#34;&gt;&lt;/a&gt;2、. search传参&lt;/h2&gt;&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;    &amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;from组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; NavLink, Link &amp;#125; from &amp;quot;react-router-dom&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
class FromClass extends Component &amp;#123;
  render() &amp;#123;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;类组件传参&amp;lt;/h1&amp;gt;
        &amp;lt;Link to=&amp;#123;&amp;quot;/to/?number=666&amp;quot;&amp;#125;&amp;gt;详情&amp;lt;/Link&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(FromClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于search传递的参数比较特殊，所以用query-string解析一下就行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
import qs from &amp;quot;query-string&amp;quot;;
class ToClass extends Component &amp;#123;
  render() &amp;#123;
    console.log(qs.parse(this.props.location.search));
    return (
      &amp;lt;div&amp;gt;
        search传递的参数为&amp;#123;qs.parse(this.props.location.search).number&amp;#125;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(ToClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/React/react-router-params/image-20221030200459605.png&#34; alt=&#34;image-20221030200459605&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3、state传参-1&#34;&gt;&lt;a href=&#34;#3、state传参-1&#34; class=&#34;headerlink&#34; title=&#34;3、state传参&#34;&gt;&lt;/a&gt;3、state传参&lt;/h2&gt;&lt;p&gt;&lt;code&gt;路由配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;&amp;lt;Routes&amp;gt;
      &amp;lt;Route path=&amp;quot;/&amp;quot; element=&amp;#123;&amp;lt;From /&amp;gt;&amp;#125; /&amp;gt;
      &amp;lt;Route path=&amp;quot;to&amp;quot; element=&amp;#123;&amp;lt;To /&amp;gt;&amp;#125; /&amp;gt;
    &amp;lt;/Routes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;from&lt;/code&gt;组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; NavLink, Link &amp;#125; from &amp;quot;react-router-dom&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
class FromClass extends Component &amp;#123;
  render() &amp;#123;
    const path = &amp;#123;
      pathname: &amp;quot;to&amp;quot;,
      state: &amp;#123;
        name: &amp;quot;叶星辰&amp;quot;,
        age: 18
      &amp;#125;
    &amp;#125;;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;类组件传参&amp;lt;/h1&amp;gt;
        &amp;lt;Link to=&amp;#123;path&amp;#125;&amp;gt;传参&amp;lt;/Link&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(FromClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to组件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;jsx&#34;&gt;import React, &amp;#123; Component &amp;#125; from &amp;quot;react&amp;quot;;
import &amp;#123; withRouter &amp;#125; from &amp;quot;./withRouter&amp;quot;;
import qs from &amp;quot;query-string&amp;quot;;
class ToClass extends Component &amp;#123;
  render() &amp;#123;
    console.log(this.props);
    return (
      &amp;lt;div&amp;gt;
       
        state传递的参数为&amp;#123;this.props.location.state&amp;#125;
      &amp;lt;/div&amp;gt;
    );
  &amp;#125;
&amp;#125;

export default withRouter(ToClass);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;扩展延伸:react-router-dom中&lt;code&gt;NavLink&lt;/code&gt;和&lt;code&gt;Link&lt;/code&gt;的区别&lt;/p&gt;
&lt;p&gt;在 ReactJS 中，有三种不同的链接。这些是&lt;code&gt;NavLink&lt;/code&gt;、、&lt;code&gt;Link&lt;/code&gt;和&lt;code&gt;a&lt;/code&gt;链接，它们都有不同的用途。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**&lt;code&gt;NavLink&lt;/code&gt;**：当您想要突出显示当前或活动链接时使用此选项。这与&lt;code&gt;activeClassName&lt;/code&gt;启用它的属性一起使用。请参见下面的示例。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;NavLink to=&amp;quot;/home&amp;quot; activeClassName=&amp;quot;active&amp;quot; &amp;gt;Home&amp;lt;/NavLink&amp;gt;&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;code&gt;CSS&lt;/code&gt;可以根据您在&lt;code&gt;App.css&lt;/code&gt;文件中的选择设置样式。让我们将文本颜色设为红色以使其简单。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.active&amp;#123;
  color:red;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;**&lt;code&gt;Link&lt;/code&gt;**：当您的链接没有特殊样式或突出显示时使用。请参见下面的示例。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Link to=&amp;quot;/not-active&amp;quot;&amp;gt;Not Active &amp;lt;/Link&amp;gt;&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：当您需要链接到属于您的应用程序的页面时，请使用&lt;code&gt;NavLink&lt;/code&gt;或。&lt;code&gt;Link&lt;/code&gt;对于外部链接，&lt;code&gt;a&lt;/code&gt;是首选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;**锚标记&lt;code&gt;a&lt;/code&gt;**：这用于网页外的链接。&lt;br&gt;请参见下面的示例。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;https://www.educative.io/edpresso&amp;quot;&amp;gt;Visit Edpresso &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;&lt;a href=&#34;#结论&#34; class=&#34;headerlink&#34; title=&#34;结论&#34;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;当&lt;code&gt;NavLink&lt;/code&gt;您想要将链接突出显示为活动时使用。因此，在每次路由到页面时，链接都会根据&lt;code&gt;activeClassName&lt;/code&gt;. &lt;code&gt;Link&lt;/code&gt;用于不需要突出显示的链接。并且&lt;code&gt;a&lt;/code&gt;用于外部链接。&lt;/p&gt;
</content>
        <category term="react" scheme="https://www.yexingcheng.com/categories/react/" />
        <category term="react" scheme="https://www.yexingcheng.com/tags/react/" />
        <category term="router" scheme="https://www.yexingcheng.com/tags/router/" />
        <updated>2022-10-29T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/computer/rightPointNewMd/</id>
        <title>如何在右键菜单下添加一个新建markdown文件选项</title>
        <link rel="alternate" href="https://www.yexingcheng.com/computer/rightPointNewMd/"/>
        <content type="html">&lt;h1 id=&#34;在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧&#34;&gt;&lt;a href=&#34;#在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧&#34; class=&#34;headerlink&#34; title=&#34;在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧&#34;&gt;&lt;/a&gt;在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧&lt;/h1&gt;&lt;h2 id=&#34;第一种方法：修改注册表&#34;&gt;&lt;a href=&#34;#第一种方法：修改注册表&#34; class=&#34;headerlink&#34; title=&#34;第一种方法：修改注册表&#34;&gt;&lt;/a&gt;第一种方法：修改注册表&lt;/h2&gt;&lt;h3 id=&#34;一、win-R输入【regedit】&#34;&gt;&lt;a href=&#34;#一、win-R输入【regedit】&#34; class=&#34;headerlink&#34; title=&#34;一、win + R输入【regedit】&#34;&gt;&lt;/a&gt;一、win + R输入【regedit】&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030035511584.png&#34; alt=&#34;image-20221030035511584&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;二、定位路径-【计算机-HKEY-CLASSES-ROOT-md】&#34;&gt;&lt;a href=&#34;#二、定位路径-【计算机-HKEY-CLASSES-ROOT-md】&#34; class=&#34;headerlink&#34; title=&#34;二、定位路径 【计算机\HKEY_CLASSES_ROOT.md】&#34;&gt;&lt;/a&gt;二、定位路径 【计算机\HKEY_CLASSES_ROOT.md】&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030035632249.png&#34; alt=&#34;image-20221030035632249&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;三、右键-md文件夹-x3D-gt-新建-x3D-gt-项，把新建的项命名为【ShellNew】&#34;&gt;&lt;a href=&#34;#三、右键-md文件夹-x3D-gt-新建-x3D-gt-项，把新建的项命名为【ShellNew】&#34; class=&#34;headerlink&#34; title=&#34;三、右键.md文件夹 &amp;#x3D;&amp;gt; 新建 &amp;#x3D;&amp;gt; 项，把新建的项命名为【ShellNew】&#34;&gt;&lt;/a&gt;三、右键.md文件夹 &amp;#x3D;&amp;gt; 新建 &amp;#x3D;&amp;gt; 项，把新建的项命名为【ShellNew】&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030035755119.png&#34; alt=&#34;image-20221030035755119&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;四、右键ShellNew-x3D-gt-新建-x3D-gt-字符串值，将该字符串值名称改为【NullFile】&#34;&gt;&lt;a href=&#34;#四、右键ShellNew-x3D-gt-新建-x3D-gt-字符串值，将该字符串值名称改为【NullFile】&#34; class=&#34;headerlink&#34; title=&#34;四、右键ShellNew &amp;#x3D;&amp;gt; 新建 &amp;#x3D;&amp;gt; 字符串值，将该字符串值名称改为【NullFile】&#34;&gt;&lt;/a&gt;四、右键ShellNew &amp;#x3D;&amp;gt; 新建 &amp;#x3D;&amp;gt; 字符串值，将该字符串值名称改为【NullFile】&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030035848133.png&#34; alt=&#34;image-20221030035848133&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果没有生效，请尝试注销重启系统。&lt;/p&gt;
&lt;h2 id=&#34;二、注册表导入&#34;&gt;&lt;a href=&#34;#二、注册表导入&#34; class=&#34;headerlink&#34; title=&#34;二、注册表导入&#34;&gt;&lt;/a&gt;二、注册表导入&lt;/h2&gt;&lt;p&gt;我们可以新建文本文文档，将以下命名复制进去，将txt后缀名改为reg格式，直接双击reg文件进行注册表导入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;powershell&#34;&gt;Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\.md]
@=&amp;quot;Marktext.exe&amp;quot;

[HKEY_CLASSES_ROOT\.md\ShellNew]
&amp;quot;NullFile&amp;quot;=&amp;quot;&amp;quot;

[HKEY_CLASSES_ROOT\Marktext.exe]
@=&amp;quot;Markdown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030040857071.png&#34; alt=&#34;image-20221030040857071&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三、通过-Reg-注册表命令添加&#34;&gt;&lt;a href=&#34;#三、通过-Reg-注册表命令添加&#34; class=&#34;headerlink&#34; title=&#34;三、通过 Reg 注册表命令添加&#34;&gt;&lt;/a&gt;三、通过 Reg 注册表命令添加&lt;/h2&gt;&lt;p&gt;更深入一些，我们也可以通过 reg 注册表命令来进行修改。&lt;/p&gt;
&lt;p&gt;必须以管理员权限启动 CMD 窗口，输如下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;powershell&#34;&gt;reg add &amp;quot;HKEY_CLASSES_ROOT\.md&amp;quot; /d &amp;quot;Marktext.exe&amp;quot; /f
reg add &amp;quot;HKEY_CLASSES_ROOT\.md\ShellNew&amp;quot; /v &amp;quot;NullFile&amp;quot; /t &amp;quot;REG_SZ&amp;quot;  /f
reg add &amp;quot;HKEY_CLASSES_ROOT\Marktext.exe&amp;quot; /d &amp;quot;Markdown&amp;quot; /f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030041025319.png&#34; alt=&#34;image-20221030041025319&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;最终我们发现可以在右键菜单下有了这个选项&#34;&gt;&lt;a href=&#34;#最终我们发现可以在右键菜单下有了这个选项&#34; class=&#34;headerlink&#34; title=&#34;最终我们发现可以在右键菜单下有了这个选项&#34;&gt;&lt;/a&gt;最终我们发现可以在右键菜单下有了这个选项&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&#34;/computer/rightPointNewMd/image-20221030042132599.png&#34; alt=&#34;image-20221030042132599&#34;&gt;&lt;/p&gt;
</content>
        <category term="计算机相关" scheme="https://www.yexingcheng.com/categories/computer/" />
        <category term="windows" scheme="https://www.yexingcheng.com/tags/windows/" />
        <category term="windows11" scheme="https://www.yexingcheng.com/tags/windows11/" />
        <updated>2022-10-29T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://www.yexingcheng.com/Blog_introduction/Blog_introduction/</id>
        <title>Welcome!</title>
        <link rel="alternate" href="https://www.yexingcheng.com/Blog_introduction/Blog_introduction/"/>
        <content type="html">&lt;p&gt;如因为网络原因,如果有文章加载不出来的情况，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iZWl6ZV9hZG1pbi5naXRlZS5pby8=&#34;&gt;请点此访问&lt;/span&gt;&lt;/p&gt;
</content>
        <category term="index" scheme="https://www.yexingcheng.com/categories/index/" />
        <category term="index" scheme="https://www.yexingcheng.com/tags/index/" />
        <updated>2022-09-30T16:00:00.000Z</updated>
    </entry>
</feed>
