<!-- build time:Thu Nov 03 2022 20:52:24 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/atom.xml"><link rel="alternate" type="application/json" title="永不陨落的星辰" href="https://www.yexingcheng.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="wxapp,ts"><link rel="canonical" href="https://www.yexingcheng.com/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"><title>微信公众号的开发 - 微信小程序 | 永不陨落的星辰 = 永不陨落的星辰</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">微信公众号的开发</h1><div class="meta"><span class="item" title="创建时间：2022-11-03 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-03T00:00:00+08:00">2022-11-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>31k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>28 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">永不陨落的星辰</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciundwu5j20zk0m8n9e.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclx6phq6j20zk0m8e36.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" itemprop="item" rel="index" title="分类于 微信小程序"><span itemprop="name">微信小程序</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.yexingcheng.com/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="叶星辰"><meta itemprop="description" content=", 温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="永不陨落的星辰"></span><div class="body md" itemprop="articleBody"><h1 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a>微信公众号开发</h1><p>混入开发范畴</p><p>nativeapp</p><p>webapp</p><p>Hybrid app</p><p>webView 这个控件属于 android &#x2F; ios 原生自带的，它是浏览器，而js需要运行在浏览器，通过webview即可完成js和原生之间的通讯</p><h1 id="1-傻瓜式配置"><a href="#1-傻瓜式配置" class="headerlink" title="1.傻瓜式配置"></a>1.傻瓜式配置</h1><h1 id="2-代码配置"><a href="#2-代码配置" class="headerlink" title="2.代码配置"></a>2.代码配置</h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p><h2 id="1-安装koa"><a href="#1-安装koa" class="headerlink" title="1.安装koa"></a>1.安装koa</h2><p><span class="exturl" data-url="aHR0cHM6Ly9rb2EuYm9vdGNzcy5jb20v">https://koa.bootcss.com/</span></p><pre><code class="powershell">yarn init -y
yarn add koa
</code></pre><h2 id="2-构建服务器"><a href="#2-构建服务器" class="headerlink" title="2.构建服务器"></a>2.构建服务器</h2><pre><code class="js">// wxpage_app/app.js
const Koa = require(&#39;koa&#39;)
const app = new Koa()

// 自定义中间件
app.use(async (ctx, next) =&gt; &#123;
  ctx.body = &#39;hello world&#39;
  await next()
&#125;)

// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><pre><code class="json">// package.json
&#123;
  &quot;name&quot;: &quot;wxpage-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;nodemon app.js&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;koa&quot;: &quot;^2.13.4&quot;
  &#125;
&#125;
</code></pre><pre><code class="sh">$ cnpm run dev
</code></pre><h2 id="3-实现微信公众号自动回复"><a href="#3-实现微信公众号自动回复" class="headerlink" title="3.实现微信公众号自动回复"></a>3.实现微信公众号自动回复</h2><h3 id="1-接口测试账号申请"><a href="#1-接口测试账号申请" class="headerlink" title="1.接口测试账号申请"></a>1.接口测试账号申请</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL2RlYnVnL2NnaS1iaW4vc2FuZGJveD90PXNhbmRib3gvbG9naW4mYW1wO3Rva2VuPTIxNDc0MDkwNzEmYW1wO2xhbmc9emhfQ04=">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&amp;token=2147409071&amp;lang=zh_CN</span></p><h3 id="2-接口信息配置"><a href="#2-接口信息配置" class="headerlink" title="2.接口信息配置"></a>2.接口信息配置</h3><h4 id="1-必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）"><a href="#1-必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）" class="headerlink" title="1.必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）"></a>1.必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）</h4><p>本地新建_server&#x2F;<span class="exturl" data-url="aHR0cDovL3d3dy5jb25mLw==">www.conf</span></p><blockquote><p>服务器一定要在安全组规则配置7788端口</p></blockquote><pre><code>upstream tunel&#123;
  server localhost:7788;
&#125;

server&#123;
  # 监听端口
  listen 80;
  server_name localhost;
  # 根目录下
  location / &#123;
    # 选择哪个服务器列表
    proxy_pass http://tunel;
  &#125;

&#125;
</code></pre><p>打开&#x2F;etc&#x2F;nginx&#x2F;nginx.config，注释原来的 80端口</p><pre><code class="powershell">cd /etc/nginx
cd conf.d
传递上一个文件
nginx -s reload
</code></pre><pre><code class="powershell">ssh -vnNt -R 7788:localhost:3333 root@47.93.246.252
</code></pre><blockquote><p>如果测试成功重新更换服务器的操作系统以后，再次操作，可能会报错（本地记录了上一次的远程服务器信息）</p><p>本地运行以下命令，清除上一次的缓存</p><p>ssh-keygen -R ‘远程服务器的IP地址’</p></blockquote><p>浏览器输入 <span class="exturl" data-url="aHR0cDovLzQ3LjkzLjI0Ni4yNTLljbPlj68v">http://47.93.246.252即可</span></p><h4 id="2-验证消息来自微信服务器"><a href="#2-验证消息来自微信服务器" class="headerlink" title="2.验证消息来自微信服务器"></a>2.验证消息来自微信服务器</h4><p>在开发具体的功能之前，需要先进行token的验证，验证消息来自于微信服务器，验证方法是提交接口配置信息时，微信服务器会发送一个get请求到我们自己的服务器，get请求携带signature:,timestamp:,nonce:,echostr:参数，通过检验signature对请求进行校验，若此次get请求来自微信服务器，就原样返回echostr参数内容</p><p>检验流程</p><pre><code>*	将token，timestamp,nonce三个参数进行字典序排序
*	将三个参数字符串拼接程一个字符串进行sha1加密
*	将加密后的字符串与signature对比，相等则表示请求来自微信服务器
*	将echostr返回
</code></pre><p>Server.js</p><pre><code class="js">const Koa = require(&#39;koa&#39;)
const app = new Koa()

// 使用中间件,koa默认是异步的，使用async以及await来构建应用
// 
app.use(async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
   /**
   * &#123;
        signature: &#39;8bd9a5eb51774442313a7e09b55b44ae6e0e711e&#39;,
        echostr: &#39;5864048842654539467&#39;,
        timestamp: &#39;1638944331&#39;,
        nonce: &#39;844212276&#39;
      &#125;
   */
  // 给前端返回数据
  ctx.body = &#39;hello world&#39;
  await next()
&#125;)

app.listen(3333, &#39;localhost&#39;, () =&gt; &#123;
  console.log(&#39;server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><blockquote><p>点击微信公众号服务器的基本配置，查看本地日志</p></blockquote><pre><code class="js">const Koa = require(&#39;koa&#39;)
const app = new Koa()

// 使用中间件,koa默认是异步的，使用async以及await来构建应用
// 
app.use(async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  const &#123;
    signature,
    echostr,
    timestamp,
    nonce
  &#125; = query
  console.log(query)
  // 给前端返回数据，返回echostr表示成功
  ctx.body = echostr
  await next()
&#125;)

app.listen(3333, &#39;localhost&#39;, () =&gt; &#123;
  console.log(&#39;server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><blockquote><p>本次提交时发现成功,但是肯定不行的，无法得知是来自微信公众号平台的</p><p>1）将token、timestamp、nonce三个参数进行字典序排序</p><p>2）将三个参数字符串拼接成一个字符串进行sha1加密</p><p>3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p></blockquote><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const crypto = require(&#39;crypto&#39;)
const app = new Koa()

// 自定义中间件
app.use(async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;)

// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><p>改造抽离中间件</p><pre><code class="js">// controllers/index.js
const crypto = require(&#39;crypto&#39;)
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

module.exports = &#123;
  sign
&#125;
</code></pre><p>添加路由</p><pre><code>yarn add @koa/router
</code></pre><pre><code class="js">// routes/index.js
const Router = require(&#39;@koa/router&#39;) // var express = require(&#39;express&#39;);
const &#123; sign &#125; = require(&#39;../controllers/index&#39;)
const router = new Router() // var router = express.Router();

// router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;&#125;)
router.get(&#39;/&#39;, sign)

module.exports = router
</code></pre><p>注册路由</p><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
// const crypto = require(&#39;crypto&#39;)
const router = require(&#39;./routes/index&#39;)
const app = new Koa()

// 注册路由
app.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);
// // 自定义中间件


// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><blockquote><p>测试项目</p></blockquote><h4 id="3-自动回复文本消息"><a href="#3-自动回复文本消息" class="headerlink" title="3.自动回复文本消息"></a>3.自动回复文本消息</h4><p>当用户发送消息给微信公众号时（或者某些特定的用户操作引发的事件推送时）,会产生一个post请求，开发者可以特定XML结构，来对该消息进行响应（现支持回复文本，图片，图文，语音，视频，音乐）</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L01lc3NhZ2VfTWFuYWdlbWVudC9SZWNlaXZpbmdfc3RhbmRhcmRfbWVzc2FnZXMuaHRtbA==">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html</span></p><p>添加新的回复路由</p><p>&#x2F;&#x2F; post	请求</p><blockquote><p>yarn add koa-body</p></blockquote><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const koaBody = require(&#39;koa-body&#39;)
// const crypto = require(&#39;crypto&#39;)
const router = require(&#39;./routes/index&#39;)
const app = new Koa()

// 一定要放在路由之前
app.use(koaBody())

// 注册路由
app.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);


// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><pre><code class="js">// controllers/index.js
const crypto = require(&#39;crypto&#39;)
// 验证消息来自微信服务器
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

// 回复消息
const reply = async (ctx, next) =&gt; &#123;
  const body = ctx.request.body
  console.log(body)

  await next()
&#125;

module.exports = &#123;
  sign,
  reply
&#125;
</code></pre><pre><code class="js">// routes/index.js 添加post请求
const Router = require(&#39;@koa/router&#39;) // var express = require(&#39;express&#39;);
const &#123; sign, reply &#125; = require(&#39;../controllers/index&#39;)
const router = new Router() // var router = express.Router();

// router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;&#125;)
router.get(&#39;/&#39;, sign)
router.post(&#39;/&#39;, reply) // 当普通微信用户向公众账号发消息时，微信服务器将 POST 消息的 XML 数据包到开发者填写的 URL 上。

module.exports = router
</code></pre><blockquote><p>从上面的记录中得知，获取到的数据是基于 xml 格式的，不便于处理</p><p>将xml文件转换为js文件</p></blockquote><blockquote><p>yarn add xml-js</p></blockquote><pre><code class="js">// controllers/index.js
const crypto = require(&#39;crypto&#39;)
var convert = require(&#39;xml-js&#39;);
// 验证消息来自微信服务器
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

// 回复消息
const reply = async (ctx, next) =&gt; &#123;
  const body = ctx.request.body
  console.log(body)

  const result = convert.xml2js(body, &#123;
    compact: true,
    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value
    textKey: &#39;value&#39;// 将对象中的 _text 变成value
  &#125;).xml

  // object.keys -- 数组  - reduce 
  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;
    resObj[key] = result[key].value
    return resObj
  &#125;, &#123;&#125;)
  console.log(obj)


  // 给用户回馈信息
  ctx.body = `
    &lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[$&#123;obj.FromUserName&#125;]]&gt;&lt;/ToUserName&gt;
    &lt;FromUserName&gt;&lt;![CDATA[$&#123;obj.ToUserName&#125;]]&gt;&lt;/FromUserName&gt;
    &lt;CreateTime&gt;$&#123;obj.CreateTime&#125;&lt;/CreateTime&gt;
    &lt;MsgType&gt;&lt;![CDATA[$&#123;obj.MsgType&#125;]]&gt;&lt;/MsgType&gt;
    &lt;Content&gt;&lt;![CDATA[武汉好程序员1期宣誓：我最强，我最棒，我是no.1]]&gt;&lt;/Content&gt;
    &lt;MsgId&gt;$&#123;obj.MsgId&#125;&lt;/MsgId&gt;
  &lt;/xml&gt;
  `
  await next()
&#125;

module.exports = &#123;
  sign,
  reply
&#125;
</code></pre><blockquote><p>扫码微信公众号测试账号，发送任何消息，发现会自动回复消息</p></blockquote><h2 id="3-添加模版消息"><a href="#3-添加模版消息" class="headerlink" title="3.添加模版消息"></a>3.添加模版消息</h2><pre><code>yarn add koa-views koa-ejs -S
</code></pre><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const koaBody = require(&#39;koa-body&#39;)
// const crypto = require(&#39;crypto&#39;)
const router = require(&#39;./routes/index&#39;)
const views = require(&#39;koa-views&#39;)
const ejs = require(&#39;koa-ejs&#39;)
const app = new Koa()

// 设置模版 
app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;
  extension: &#39;ejs&#39;
&#125;))

// 一定要放在路由之前
app.use(koaBody())

// 注册路由
app.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);


// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><pre><code class="xml">// views/index.ejs
&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&lt;%- FromUserName%&gt;]]&gt;&lt;/ToUserName&gt;
  &lt;FromUserName&gt;&lt;![CDATA[&lt;%- ToUserName%&gt;]]&gt;&lt;/FromUserName&gt;
  &lt;CreateTime&gt;&lt;%- CreateTime%&gt;&lt;/CreateTime&gt;
  &lt;MsgType&gt;&lt;![CDATA[&lt;%- MsgType%&gt;]]&gt;&lt;/MsgType&gt;
  &lt;Content&gt;&lt;![CDATA[&lt;a href=&quot;https://www.baidu.com&quot;&gt;打开百度&lt;/a&gt;]]&gt;&lt;/Content&gt;
  &lt;MsgId&gt;&lt;%- MsgId%&gt;&lt;/MsgId&gt;
&lt;/xml&gt;
</code></pre><pre><code class="js">// controller/index.js
const crypto = require(&#39;crypto&#39;)
var convert = require(&#39;xml-js&#39;);
// 验证消息来自微信服务器
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

// 回复消息
const reply = async (ctx, next) =&gt; &#123;
  const body = ctx.request.body
  console.log(body)

  const result = convert.xml2js(body, &#123;
    compact: true,
    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value
    textKey: &#39;value&#39;// 将对象中的 _text 变成value
  &#125;).xml

  // object.keys -- 数组  - reduce 
  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;
    resObj[key] = result[key].value
    return resObj
  &#125;, &#123;&#125;)
  console.log(obj)


  // 使用模版发送消息
  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId&#125; = obj

  // express res.render(&#39;index&#39;, &#123;&#125;)
  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId &#125;)
  await next()
&#125;

module.exports = &#123;
  sign,
  reply
&#125;
</code></pre><blockquote><p>模拟数据回复</p></blockquote><pre><code class="xml">// views/index.ejs
&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&lt;%- FromUserName%&gt;]]&gt;&lt;/ToUserName&gt;
  &lt;FromUserName&gt;&lt;![CDATA[&lt;%- ToUserName%&gt;]]&gt;&lt;/FromUserName&gt;
  &lt;CreateTime&gt;&lt;%- CreateTime%&gt;&lt;/CreateTime&gt;
  &lt;MsgType&gt;&lt;![CDATA[&lt;%- MsgType%&gt;]]&gt;&lt;/MsgType&gt;
  &lt;Content&gt;&lt;![CDATA[&lt;%- Content %&gt;]]&gt;&lt;/Content&gt;
  &lt;MsgId&gt;&lt;%- MsgId%&gt;&lt;/MsgId&gt;
&lt;/xml&gt;
</code></pre><pre><code class="js">// controllers/index.js
const crypto = require(&#39;crypto&#39;)
var convert = require(&#39;xml-js&#39;);
// 验证消息来自微信服务器
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

// 回复消息
const reply = async (ctx, next) =&gt; &#123;
  const body = ctx.request.body
  console.log(body)
 
  const result = convert.xml2js(body, &#123;
    compact: true,
    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value
    textKey: &#39;value&#39;// 将对象中的 _text 变成value
  &#125;).xml

  // object.keys -- 数组  - reduce 
  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;
    resObj[key] = result[key].value
    return resObj
  &#125;, &#123;&#125;)
  console.log(obj)
 
  // 使用模版发送消息
  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content&#125; = obj
  let str = &#39;你是最棒的&#39;
  switch (Content) &#123;
    case &#39;1&#39;:
      str = &#39;中&#39;
      break;
    case &#39;2&#39;:
      str = &#39;得劲&#39;
      break;
    case &#39;3&#39;:
      str = &#39;美的很&#39;
      break;
    case &#39;4&#39;:
      str = &#39;你个信球&#39;
      break;
    default:
      break;
  &#125;
  // express res.render(&#39;index&#39;, &#123;&#125;)
  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content: str &#125;)
  await next()
&#125;

module.exports = &#123;
  sign,
  reply
&#125;
</code></pre><h1 id="3-拍照"><a href="#3-拍照" class="headerlink" title="3.拍照"></a>3.拍照</h1><p>回复自己的页面，不回复百度了</p><h2 id="1-Koa-实现静态资源目录"><a href="#1-Koa-实现静态资源目录" class="headerlink" title="1.Koa 实现静态资源目录"></a>1.Koa 实现静态资源目录</h2><pre><code>yarn add koa-static
</code></pre><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const koaBody = require(&#39;koa-body&#39;)
// const crypto = require(&#39;crypto&#39;)
const router = require(&#39;./routes/index&#39;)
const views = require(&#39;koa-views&#39;)
const ejs = require(&#39;koa-ejs&#39;)
const static = require(&#39;koa-static&#39;)
const path = require(&#39;path&#39;)
const app = new Koa()

// 设置模版 
app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;
  extension: &#39;ejs&#39;
&#125;))
// 设置静态资源目录
app.use(static(path.resolve(__dirname, &#39;./public&#39;)))

// 一定要放在路由之前
app.use(koaBody())

// 注册路由
app.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);
// // 自定义中间件


// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><pre><code class="html">&lt;!--public/index.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;嗨购商城&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  嗨购商城
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>&#x2F;&#x2F; 浏览器访问ip地址即可 <span class="exturl" data-url="aHR0cDovLzQ3LjkzLjI0Ni4yNTIv">http://47.93.246.252/</span></p><p><strong>消息回复提示</strong></p><pre><code class="js">// controllers/index.js
const crypto = require(&#39;crypto&#39;)
var convert = require(&#39;xml-js&#39;);
// 验证消息来自微信服务器
const sign = async (ctx, next) =&gt; &#123;
  const query = ctx.request.query
  console.log(query)
  const &#123; signature, echostr, timestamp, nonce &#125; = query
  // 1.将token、timestamp、nonce三个参数进行字典序排序
  const token = &#39;whgp01&#39;
  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]
  console.log(arr)
  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 
  const str = arr.join(&#39;&#39;)
  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密
  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信
  if (sign === signature) &#123;
    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器
  &#125; else &#123;
    ctx.body = &#39;出错了&#39;
  &#125;
  await next()
&#125;

// 回复消息
const reply = async (ctx, next) =&gt; &#123;
  const body = ctx.request.body
  console.log(body)

  const result = convert.xml2js(body, &#123;
    compact: true,
    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value
    textKey: &#39;value&#39;// 将对象中的 _text 变成value
  &#125;).xml

  // object.keys -- 数组  - reduce 
  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;
    resObj[key] = result[key].value
    return resObj
  &#125;, &#123;&#125;)
  console.log(obj)


  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content&#125; = obj
  let str = `
    亲，你可以输入以下数字分别打开不同的网页：
    [1] 打开嗨购商城
    [2] 打开百度

  `
  switch (Content) &#123;
    case &#39;1&#39;:
      str = `&lt;a href=&quot;http://47.93.246.252/&quot;&gt;嗨购商城&lt;/a&gt;`
      break;
    case &#39;2&#39;:
      str = `&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;`
      break;
    default:
      break;
  &#125;
  // express res.render(&#39;index&#39;, &#123;&#125;)
  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content: str &#125;)
  await next()
&#125;

module.exports = &#123;
  sign,
  reply
&#125;
</code></pre><blockquote><p>目前可以在公众号中打开自己写网页— 微信公众号的开发</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html</span></p></blockquote><h2 id="2-生成签名"><a href="#2-生成签名" class="headerlink" title="2.生成签名"></a>2.生成签名</h2><blockquote><p>最好生成一个新的路由，配置子路由</p></blockquote><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const koaBody = require(&#39;koa-body&#39;)
// const crypto = require(&#39;crypto&#39;)
const routerIndex = require(&#39;./routes/index&#39;)
const views = require(&#39;koa-views&#39;)
const ejs = require(&#39;koa-ejs&#39;)
const static = require(&#39;koa-static&#39;)
const path = require(&#39;path&#39;)
const Router = require(&#39;@koa/router&#39;) // ++++++
const app = new Koa()
const router = new Router()// ++++++
// 设置模版 
app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;
  extension: &#39;ejs&#39;
&#125;))
// 设置静态资源目录
app.use(static(path.resolve(__dirname, &#39;./public&#39;)))

// 一定要放在路由之前
app.use(koaBody())

// 注册路由
router.use(&#39;/wx&#39;, routerIndex.routes())// ++++++
app.use(router.routes())

// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><blockquote><p>此时需要修改测试公众号的 配置，添加&#x2F;wx 验证token</p></blockquote><p><strong>构建生成签名的路由的中间件</strong></p><pre><code class="js">// controllers/sign.js
const sign = async (ctx, next) =&gt; &#123;
  ctx.body=&quot;签名&quot;
  await next()
&#125;

module.exports = &#123;
  sign
&#125;
</code></pre><pre><code class="js">// routes/sign.js
const Router = require(&#39;@koa/router&#39;)
const router = new Router()
const &#123; sign &#125; = require(&#39;../controllers/sign&#39;)

router.get(&#39;/sign&#39;, sign)

module.exports = router
</code></pre><pre><code class="js">// app.js
const Koa = require(&#39;koa&#39;)
const koaBody = require(&#39;koa-body&#39;)
// const crypto = require(&#39;crypto&#39;)
const routerIndex = require(&#39;./routes/index&#39;)
const routerSign = require(&#39;./routes/sign&#39;)
const views = require(&#39;koa-views&#39;)
const ejs = require(&#39;koa-ejs&#39;)
const static = require(&#39;koa-static&#39;)
const path = require(&#39;path&#39;)
const Router = require(&#39;@koa/router&#39;) // ++++++
const app = new Koa()
const router = new Router()// ++++++
// 设置模版 
app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;
  extension: &#39;ejs&#39;
&#125;))
// 设置静态资源目录
app.use(static(path.resolve(__dirname, &#39;./public&#39;)))

// 一定要放在路由之前
app.use(koaBody())

// 注册路由
router.use(&#39;/wx&#39;, routerIndex.routes()) 
router.use(&#39;/api&#39;, routerSign.routes()) 
app.use(router.routes())


// 监听端口号
app.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;
  console.log(&#39;your server is running at http://localhost:3333&#39;)
&#125;)
</code></pre><p>打开网页 <span class="exturl" data-url="aHR0cDovLzQ3LjkzLjI0Ni4yNTIvYXBpL3NpZ24=">http://47.93.246.252/api/sign</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1sIzYy">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0dldF9hY2Nlc3NfdG9rZW4uaHRtbA==">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html</span></p><pre><code>yarn add axios randomstring
</code></pre><pre><code class="js">// controllers/sign.js
const axios = require(&#39;axios&#39;)
const randomstring = require(&#39;randomstring&#39;)
const querystring = require(&#39;querystring&#39;)
const crypto = require(&#39;crypto&#39;)
const sign = async (ctx, next) =&gt; &#123;
  const appid = &#39;wxbbdbe14f3df54d1a&#39;
  const secret = &#39;522dbfad863073c6e02364b5544e5861&#39;
  // 1.获取access_token
  const &#123; data: &#123; access_token &#125;&#125; = await axios.get(&#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&#39;, &#123; params: &#123; appid, secret &#125;&#125;)
  // console.log(access_token) // http://47.93.246.252/api/sign 得知
  // 2.获取jsapi_ticket
  const &#123; data: &#123; ticket &#125;&#125; = await axios.get(&#39;https://api.weixin.qq.com/cgi-bin/ticket/getticket&#39;, &#123; params: &#123; type: &#39;jsapi&#39;, access_token &#125;&#125;)
  // console.log(ticket) //  http://47.93.246.252/api/sign 得知

  const noncestr = randomstring.generate(32)
  // console.log(noncestr)
  const jsapi_ticket = ticket
  const timestamp = new Date().getTime()
  // console.log(timestamp)
  const url = &#39;http://47.93.246.252/&#39;

  const obj = &#123;
    noncestr, jsapi_ticket, timestamp,  url
  &#125;
  // 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后
  const newObj = Object.keys(obj).sort().reduce((o, key) =&gt; &#123;
    o[key] = obj[key]
    return o
  &#125;, &#123;&#125;)
  // console.log(newObj)
  // 使用 URL 键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1
  // const string1 = querystring.stringify(newObj)
  // console.log(string1) // 发现 url地址进行了转义 http%3A%2F%2F47.93.246.252%2F
  const string1 = querystring.stringify(newObj, null, null, &#123;
    encodeURIComponent: (val) =&gt; decodeURIComponent(val)
  &#125; )
  // console.log(string1)
  // 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义
  const signature = crypto.createHash(&#39;sha1&#39;).update(string1).digest(&#39;hex&#39;)
  ctx.body = &#123;
    appId: appid,
    timestamp,
    nonceStr: noncestr,
    signature
  &#125;
  // ctx.body=&quot;签名&quot;
  await next()
&#125;

module.exports = &#123;
  sign
&#125;
</code></pre><h2 id="3-前端调用接口"><a href="#3-前端调用接口" class="headerlink" title="3.前端调用接口"></a>3.前端调用接口</h2><pre><code class="html">// public/index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;嗨购商城&lt;/title&gt;
  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  嗨购商城
  &lt;button id=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
    console.log(res)
    wx.config(&#123;
      debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。
      appId: res.appId, // 必填，公众号的唯一标识
      timestamp: res.timestamp, // 必填，生成签名的时间戳
      nonceStr: res.nonceStr, // 必填，生成签名的随机串
      signature: res.signature,// 必填，签名
      jsApiList: [
        &#39;updateAppMessageShareData&#39;,
        &#39;updateTimelineShareData&#39;,
        &#39;onMenuShareWeibo&#39;,
        &#39;onMenuShareQZone&#39;,
        &#39;startRecord&#39;,
        &#39;stopRecord&#39;,
        &#39;onVoiceRecordEnd&#39;,
        &#39;playVoice&#39;,
        &#39;pauseVoice&#39;,
        &#39;stopVoice&#39;,
        &#39;onVoicePlayEnd&#39;,
        &#39;uploadVoice&#39;,
        &#39;downloadVoice&#39;,
        &#39;chooseImage&#39;,
        &#39;previewImage&#39;,
        &#39;uploadImage&#39;,
        &#39;downloadImage&#39;,
        &#39;translateVoice&#39;,
        &#39;getNetworkType&#39;,
        &#39;openLocation&#39;,
        &#39;getLocation&#39;,
        &#39;hideOptionMenu&#39;,
        &#39;showOptionMenu&#39;,
        &#39;hideMenuItems&#39;,
        &#39;showMenuItems&#39;,
        &#39;hideAllNonBaseMenuItem&#39;,
        &#39;showAllNonBaseMenuItem&#39;,
        &#39;closeWindow&#39;,
        &#39;scanQRCode&#39;,
        &#39;chooseWXPay&#39;,
        &#39;openProductSpecificView&#39;,
        &#39;addCard&#39;,
        &#39;chooseCard&#39;,
        &#39;openCard&#39;
      ] // 必填，需要使用的 JS 接口列表
    &#125;);
  &#125;)

  wx.ready(function()&#123;
    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中。
  

  &#125;);


&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="4-最终测试-扫一扫"><a href="#4-最终测试-扫一扫" class="headerlink" title="4.最终测试-扫一扫"></a>4.最终测试-扫一扫</h2><pre><code class="html">// public/index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;嗨购商城&lt;/title&gt;
  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  嗨购商城
  &lt;button id=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
    console.log(res)
    wx.config(&#123;
      debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。
      appId: res.appId, // 必填，公众号的唯一标识
      timestamp: res.timestamp, // 必填，生成签名的时间戳
      nonceStr: res.nonceStr, // 必填，生成签名的随机串
      signature: res.signature,// 必填，签名
      jsApiList: [
        &#39;updateAppMessageShareData&#39;,
        &#39;updateTimelineShareData&#39;,
        &#39;onMenuShareWeibo&#39;,
        &#39;onMenuShareQZone&#39;,
        &#39;startRecord&#39;,
        &#39;stopRecord&#39;,
        &#39;onVoiceRecordEnd&#39;,
        &#39;playVoice&#39;,
        &#39;pauseVoice&#39;,
        &#39;stopVoice&#39;,
        &#39;onVoicePlayEnd&#39;,
        &#39;uploadVoice&#39;,
        &#39;downloadVoice&#39;,
        &#39;chooseImage&#39;,
        &#39;previewImage&#39;,
        &#39;uploadImage&#39;,
        &#39;downloadImage&#39;,
        &#39;translateVoice&#39;,
        &#39;getNetworkType&#39;,
        &#39;openLocation&#39;,
        &#39;getLocation&#39;,
        &#39;hideOptionMenu&#39;,
        &#39;showOptionMenu&#39;,
        &#39;hideMenuItems&#39;,
        &#39;showMenuItems&#39;,
        &#39;hideAllNonBaseMenuItem&#39;,
        &#39;showAllNonBaseMenuItem&#39;,
        &#39;closeWindow&#39;,
        &#39;scanQRCode&#39;,
        &#39;chooseWXPay&#39;,
        &#39;openProductSpecificView&#39;,
        &#39;addCard&#39;,
        &#39;chooseCard&#39;,
        &#39;openCard&#39;
      ] // 必填，需要使用的 JS 接口列表
    &#125;);
  &#125;)

  wx.ready(function()&#123;
    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中。
    document.getElementById(&#39;scan&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;
      wx.scanQRCode(&#123;
        needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，
        scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有
        success: function (res) &#123;
          var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果
        &#125;
      &#125;);


    &#125;, false)

  &#125;);


&lt;/script&gt;
&lt;/html&gt;
</code></pre><blockquote><p>扫描测试公众号，输入1，点击嗨购商城，点击扫一扫测试</p></blockquote><h1 id="4-vue结合微信公众号开发"><a href="#4-vue结合微信公众号开发" class="headerlink" title="4.vue结合微信公众号开发"></a>4.vue结合微信公众号开发</h1><h2 id="1-实现扫码和拍照功能"><a href="#1-实现扫码和拍照功能" class="headerlink" title="1.实现扫码和拍照功能"></a>1.实现扫码和拍照功能</h2><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;嗨购商城&lt;/title&gt;
  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;嗨购商城&lt;/h1&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;
    &lt;button @click=&quot;takephoto&quot;&gt;拍照&lt;/button&gt;
    &lt;img :src=&quot;img&quot; alt=&quot;&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
  

  new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
      img: &#39;&#39;
    &#125;,
    mounted() &#123;
      fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
        console.log(res)
        wx.config(&#123;
          debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。
          appId: res.appId, // 必填，公众号的唯一标识
          timestamp: res.timestamp, // 必填，生成签名的时间戳
          nonceStr: res.nonceStr, // 必填，生成签名的随机串
          signature: res.signature,// 必填，签名
          jsApiList: [
            &#39;updateAppMessageShareData&#39;,
            &#39;updateTimelineShareData&#39;,
            &#39;onMenuShareWeibo&#39;,
            &#39;onMenuShareQZone&#39;,
            &#39;startRecord&#39;,
            &#39;stopRecord&#39;,
            &#39;onVoiceRecordEnd&#39;,
            &#39;playVoice&#39;,
            &#39;pauseVoice&#39;,
            &#39;stopVoice&#39;,
            &#39;onVoicePlayEnd&#39;,
            &#39;uploadVoice&#39;,
            &#39;downloadVoice&#39;,
            &#39;chooseImage&#39;,
            &#39;previewImage&#39;,
            &#39;uploadImage&#39;,
            &#39;downloadImage&#39;,
            &#39;translateVoice&#39;,
            &#39;getNetworkType&#39;,
            &#39;openLocation&#39;,
            &#39;getLocation&#39;,
            &#39;hideOptionMenu&#39;,
            &#39;showOptionMenu&#39;,
            &#39;hideMenuItems&#39;,
            &#39;showMenuItems&#39;,
            &#39;hideAllNonBaseMenuItem&#39;,
            &#39;showAllNonBaseMenuItem&#39;,
            &#39;closeWindow&#39;,
            &#39;scanQRCode&#39;,
            &#39;chooseWXPay&#39;,
            &#39;openProductSpecificView&#39;,
            &#39;addCard&#39;,
            &#39;chooseCard&#39;,
            &#39;openCard&#39;
          ] // 必填，需要使用的 JS 接口列表
        &#125;);
      &#125;)
    &#125;,
    methods: &#123;
      scan () &#123;
        wx.scanQRCode(&#123;
          needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，
          scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有
          success: function (res) &#123;
            var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果
          &#125;
        &#125;);
      &#125;,
      takephoto () &#123;
        wx.chooseImage(&#123;
          count: 1, // 默认9
          sizeType: [&#39;original&#39;, &#39;compressed&#39;], // 可以指定是原图还是压缩图，默认二者都有
          sourceType: [&#39;album&#39;, &#39;camera&#39;], // 可以指定来源是相册还是相机，默认二者都有
          success: (res) =&gt; &#123;
            var localIds = res.localIds; // 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片
            console.log(localIds[0])
            this.img = localIds[0]
          &#125;
        &#125;);


      &#125;
    &#125;,
  &#125;)

 


&lt;/script&gt;
&lt;/html&gt;
</code></pre><h2 id="2-分享"><a href="#2-分享" class="headerlink" title="2.分享"></a>2.分享</h2><blockquote><p>网页 — 直接分享到朋友圈 — 分享的内容就为你当前的网页</p><p>网页 – 按钮 — 点击分享到朋友圈。— 再通过朋友圈分享 —- 自定义分享的内容</p></blockquote><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;嗨购商城&lt;/title&gt;
  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;嗨购商城&lt;/h1&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;
    &lt;button @click=&quot;takephoto&quot;&gt;拍照&lt;/button&gt;
    &lt;button @click=&quot;share&quot;&gt;分享到朋友圈&lt;/button&gt;
    &lt;img :src=&quot;img&quot; alt=&quot;&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
  

  new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
      img: &#39;&#39;
    &#125;,
    mounted() &#123;
      fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
        console.log(res)
        wx.config(&#123;
          debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。
          appId: res.appId, // 必填，公众号的唯一标识
          timestamp: res.timestamp, // 必填，生成签名的时间戳
          nonceStr: res.nonceStr, // 必填，生成签名的随机串
          signature: res.signature,// 必填，签名
          jsApiList: [
            &#39;onMenuShareTimeline&#39;,
            &#39;updateAppMessageShareData&#39;,
            &#39;updateTimelineShareData&#39;,
            &#39;onMenuShareWeibo&#39;,
            &#39;onMenuShareQZone&#39;,
            &#39;startRecord&#39;,
            &#39;stopRecord&#39;,
            &#39;onVoiceRecordEnd&#39;,
            &#39;playVoice&#39;,
            &#39;pauseVoice&#39;,
            &#39;stopVoice&#39;,
            &#39;onVoicePlayEnd&#39;,
            &#39;uploadVoice&#39;,
            &#39;downloadVoice&#39;,
            &#39;chooseImage&#39;,
            &#39;previewImage&#39;,
            &#39;uploadImage&#39;,
            &#39;downloadImage&#39;,
            &#39;translateVoice&#39;,
            &#39;getNetworkType&#39;,
            &#39;openLocation&#39;,
            &#39;getLocation&#39;,
            &#39;hideOptionMenu&#39;,
            &#39;showOptionMenu&#39;,
            &#39;hideMenuItems&#39;,
            &#39;showMenuItems&#39;,
            &#39;hideAllNonBaseMenuItem&#39;,
            &#39;showAllNonBaseMenuItem&#39;,
            &#39;closeWindow&#39;,
            &#39;scanQRCode&#39;,
            &#39;chooseWXPay&#39;,
            &#39;openProductSpecificView&#39;,
            &#39;addCard&#39;,
            &#39;chooseCard&#39;,
            &#39;openCard&#39;
          ] // 必填，需要使用的 JS 接口列表
        &#125;);
      &#125;)
    &#125;,
    methods: &#123;
      scan () &#123;
        wx.scanQRCode(&#123;
          needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，
          scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有
          success: function (res) &#123;
            var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果
          &#125;
        &#125;);
      &#125;,
      takephoto () &#123;
        wx.chooseImage(&#123;
          count: 1, // 默认9
          sizeType: [&#39;original&#39;, &#39;compressed&#39;], // 可以指定是原图还是压缩图，默认二者都有
          sourceType: [&#39;album&#39;, &#39;camera&#39;], // 可以指定来源是相册还是相机，默认二者都有
          success: (res) =&gt; &#123;
            var localIds = res.localIds; // 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片
            console.log(localIds[0])
            this.img = localIds[0]
          &#125;
        &#125;);


      &#125;,
      share () &#123;
        wx.ready(function () &#123; 
          wx.onMenuShareTimeline(&#123; 
            title: &#39;自定义分享啦&#39;, // 分享标题 http://47.93.246.252/share.html
            link: &#39;http://47.93.246.252/share.html&#39;, // 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致
            imgUrl: &#39;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#39;, // 分享图标
            success: function () &#123;
              // 设置成功
            &#125;
          &#125;)
        &#125;)
      &#125;
    &#125;,
  &#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre><div class="tags"><a href="/tags/wxapp/" rel="tag"><i class="ic i-tag"></i> wxapp</a> <a href="/tags/ts/" rel="tag"><i class="ic i-tag"></i> ts</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-03 20:51:58" itemprop="dateModified" datetime="2022-11-03T20:51:58+08:00">2022-11-03</time> </span><span id="wx-app/微信公众号开发/" class="item leancloud_visitors" data-flag-title="微信公众号的开发" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 联系我</button><p>来交朋友吧！</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="叶星辰 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="叶星辰 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="叶星辰 QQ"><p>QQ</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>叶星辰 <i class="ic i-at"><em>@</em></i>永不陨落的星辰</li><li class="link"><strong>本文链接：</strong> <a href="https://www.yexingcheng.com/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/" title="微信公众号的开发">https://www.yexingcheng.com/wx-app/微信公众号开发/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/wx-app/day3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="构建电商界面的小程序（一）"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 微信小程序</span><h3>构建电商界面的小程序（一）</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">微信公众号开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%82%BB%E7%93%9C%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">1.傻瓜式配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">2.代码配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85koa"><span class="toc-number">3.1.</span> <span class="toc-text">1.安装koa</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.构建服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D"><span class="toc-number">3.3.</span> <span class="toc-text">3.实现微信公众号自动回复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.接口测试账号申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.接口信息配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BF%85%E9%A1%BB%E5%BE%97%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%88IP%E5%9C%B0%E5%9D%80%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8ssh%E7%A9%BF%E9%80%8F%EF%BC%88%E9%81%BF%E5%85%8D%E6%AF%8F%E6%AC%A1%E5%86%99%E5%AE%8C%E9%83%BD%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">1.必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E6%9D%A5%E8%87%AA%E5%BE%AE%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">2.验证消息来自微信服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3.自动回复文本消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E6%A8%A1%E7%89%88%E6%B6%88%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">3.添加模版消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%8B%8D%E7%85%A7"><span class="toc-number">4.</span> <span class="toc-text">3.拍照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Koa-%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="toc-number">4.1.</span> <span class="toc-text">1.Koa 实现静态资源目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">2.生成签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">3.前端调用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E7%BB%88%E6%B5%8B%E8%AF%95-%E6%89%AB%E4%B8%80%E6%89%AB"><span class="toc-number">4.4.</span> <span class="toc-text">4.最终测试-扫一扫</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-vue%E7%BB%93%E5%90%88%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">4.vue结合微信公众号开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%89%AB%E7%A0%81%E5%92%8C%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.</span> <span class="toc-text">1.实现扫码和拍照功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%86%E4%BA%AB"><span class="toc-number">5.2.</span> <span class="toc-text">2.分享</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/wx-app/day1/" rel="bookmark" title="微信小程序学习第一天">微信小程序学习第一天</a></li><li><a href="/wx-app/day2/" rel="bookmark" title="微信小程序学习第二天">微信小程序学习第二天</a></li><li><a href="/wx-app/day3/" rel="bookmark" title="构建电商界面的小程序（一）">构建电商界面的小程序（一）</a></li><li class="active"><a href="/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/" rel="bookmark" title="微信公众号的开发">微信公众号的开发</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="叶星辰" data-src="/images/avatar.jpg"><p class="name" itemprop="name">叶星辰</p><div class="description" itemprop="description">温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">34</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhMW1EMHduMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Ca1mD0wn1"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9VZmRIbw==" title="https:&#x2F;&#x2F;twitter.com&#x2F;UfdHo"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tZW5nLXhpbmcteW91LWppLXNpLXl1ZS1odWFuZy0yNw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;meng-xing-you-ji-si-yue-huang-27"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTUwMjkxOTQ0NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;502919445"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NTc4MjU1ODg1" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7578255885"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="aHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvI2luYm94" title="https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;u&#x2F;0&#x2F;#inbox"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/6/" title="vue-mobile项目开发流程第六部分(构建home页面)">vue-mobile项目开发流程第六部分(构建home页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/12/" title="vue-mobile项目开发流程第十二部分(实现提交订单功能)">vue-mobile项目开发流程第十二部分(实现提交订单功能)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/9/" title="vue-mobile项目开发流程第九部分(构建login页面)">vue-mobile项目开发流程第九部分(构建login页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day3/" title="构建电商界面的小程序（一）">构建电商界面的小程序（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面试用">面试用</a></div><span><a href="/interview/interview/" title="面试题总结">面试题总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/react-router-params/" title="React路由传参的几种方式">React路由传参的几种方式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Screeps/" title="分类于 screeps">screeps</a></div><span><a href="/Screeps/chinese/" title="screeps汉化（steam)">screeps汉化（steam)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day1/" title="微信小程序学习第一天">微信小程序学习第一天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/" title="微信公众号的开发">微信公众号的开发</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/7/" title="React学习第七天">React学习第七天</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">叶星辰 @ 永不陨落的星辰</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">574k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">8:42</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"wx-app/微信公众号开发/",favicon:{show:"星辰",hide:"你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":250,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html><!-- rebuild by hrmmi -->