<!-- build time:Wed Nov 09 2022 02:32:54 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/atom.xml"><link rel="alternate" type="application/json" title="永不陨落的星辰" href="https://www.yexingcheng.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="react"><link rel="canonical" href="https://www.yexingcheng.com/react-study/3/"><title>React学习第三天 - react学习 | 永不陨落的星辰 = 永不陨落的星辰</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">React学习第三天</h1><div class="meta"><span class="item" title="创建时间：2022-08-03 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-03T00:00:00+08:00">2022-08-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">永不陨落的星辰</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 react学习"><span itemprop="name">react学习</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.yexingcheng.com/react-study/3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="叶星辰"><meta itemprop="description" content=", 温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="永不陨落的星辰"></span><div class="body md" itemprop="articleBody"><h1 id="六、State"><a href="#六、State" class="headerlink" title="六、State"></a>六、State</h1><p><code>state</code> 是 <code>class</code>组件的内置对象，用于class组件内部数据更新</p><p><code>state</code>就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用<code>state</code>的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p><h2 id="6-1-state及其特点"><a href="#6-1-state及其特点" class="headerlink" title="6.1 state及其特点"></a>6.1 state及其特点</h2><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</p><p>不要直接修改state</p><p>state更新可能是异步的：出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>state更新会被合并：当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state</p><h2 id="6-2-state的定义和使用"><a href="#6-2-state的定义和使用" class="headerlink" title="6.2 state的定义和使用"></a>6.2 state的定义和使用</h2><p>目前react中的状态有两种使用方式：</p><h3 id="6-2-1-es6的类-构造函数"><a href="#6-2-1-es6的类-构造函数" class="headerlink" title="6.2.1 es6的类 - 构造函数"></a>6.2.1 es6的类 - 构造函数</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./02_state/01_App_state_es6&#39; // es6 构造函数 初始化状态

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(&lt;App /&gt;)
</code></pre><p><code>src/02_state/01_App_state_es6.jsx</code></p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;
/**
 * ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。
这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，
得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。
如果不调用super()方法，子类就得不到自己的this对象。

 ES5 的继承机制，是先创造一个独立的子类的实例对象，
 然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。
 ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，
 然后再将该对象作为子类的实例，即“继承在前，实例在后”
 */
class App extends Component &#123;
  // constructor (props) &#123; //  Useless constructor 
  //   super(props)
  // &#125;

  constructor (props) &#123;
    super(props)
    this.state = &#123;
      date: new Date()
    &#125;
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        当前时间为：&#123; this.state.date.toLocaleDateString() +  this.state.date.toLocaleTimeString() &#125;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default App;
</code></pre><h3 id="6-2-2-es7的类-属性初始化器"><a href="#6-2-2-es7的类-属性初始化器" class="headerlink" title="6.2.2 es7的类 - 属性初始化器"></a>6.2.2 es7的类 - 属性初始化器</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./02_state/02_App_state_es7&#39; // es7 属性初始化器 初始化状态

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(&lt;App /&gt;)
</code></pre><p><code>src/02_state/02_App_state_es7.jsx</code></p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

class App extends Component &#123;

  state = &#123;
    date: new Date()
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        当前时间为：&#123; this.state.date.toLocaleDateString() +  this.state.date.toLocaleTimeString() &#125;!!
      &lt;/div&gt;
    );
  &#125;
&#125;

export default App;
</code></pre><h2 id="6-3-如何正确的修改state"><a href="#6-3-如何正确的修改state" class="headerlink" title="6.3 如何正确的修改state"></a>6.3 如何正确的修改state</h2><p><code>setState()</code> 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式.</p><p>将 <code>setState()</code> 视为<em>请求</em>而不是立即更新组件的命令。为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。</p><p><code>setState()</code> 并不总是立即更新组件。它会批量推迟更新。这使得在调用 <code>setState()</code> 后立即读取 <code>this.state</code> 成为了隐患。为了消除隐患，请使用 <code>componentDidUpdate</code> 或者 <code>setState</code> 的回调函数（<code>setState(updater, callback)</code>），这两种方式都可以保证在应用更新后触发。</p><p>记住修改状态的三大原则：</p><ul><li>不要直接修改 State</li></ul><pre><code class="js">state = &#123; a: 10 &#125;
this.state.a = 100 // ❌
</code></pre><ul><li>state 的更新可能是异步的</li></ul><pre><code class="js">state = &#123; a: 10 &#125;
this.setState(&#123;a: this.state.a + 1 &#125;)
this.setState(&#123;a: this.state.a + 1 &#125;)
this.setState(&#123;a: this.state.a + 1 &#125;)
console.log(this.state.a) // 10
</code></pre><ul><li>state 的更新会被合并</li></ul><h2 id="6-4-this-setState-方法及其特点"><a href="#6-4-this-setState-方法及其特点" class="headerlink" title="6.4 this.setState()方法及其特点"></a>6.4 this.setState()方法及其特点</h2><p><code>setState()</code> 会对一个组件的 <code>state</code> 对象安排一次更新。当 state 改变了，该组件就会重新渲染。</p><p><code>setState()</code>可以添加两个参数,</p><p><code>setState()</code> 的第二个参数为可选的回调函数，它将在 <code>setState</code> 完成合并并重新渲染组件后执行</p><h3 id="6-4-1-传递函数"><a href="#6-4-1-传递函数" class="headerlink" title="6.4.1 传递函数"></a>6.4.1 传递函数</h3><p>参数一为带有形式参数的 <code>updater</code> 函数：</p><pre><code>this.setState((state, props) =&gt; stateChange[, callback] )
</code></pre><p><code>src/index.js</code></p><pre><code class="js">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./02_state/03_App_setState_function&#39; // 修改状态 传递函数

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(&lt;App /&gt;)
</code></pre><p><code>src/02_state/03_App_setState_function.jsx</code></p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

class App extends Component &#123;
  state = &#123;
    count: 100
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &#123; this.state.count &#125;
        &lt;button
          onClick=&#123; () =&gt; &#123;
            this.setState((state, props) =&gt; &#123;
              return &#123;
                count: state.count + 1
              &#125;
            &#125;, () =&gt; &#123;
              console.log(4, this.state.count) // 103
            &#125;)
            console.log(1, this.state.count) // 100
            this.setState((state, props) =&gt; &#123;
              return &#123;
                count: state.count + 1
              &#125;
            &#125;, () =&gt; &#123;
              console.log(5, this.state.count) // 103
            &#125;)
            console.log(2, this.state.count) // 100

            this.setState((state, props) =&gt; &#123;
              return &#123;
                count: state.count + 1
              &#125;
            &#125;, () =&gt; &#123;
              console.log(6, this.state.count) // 103
            &#125;)
            console.log(3, this.state.count) // 100

          &#125; &#125;
        &gt;加1&lt;/button&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default App;
</code></pre><blockquote><p>updater 函数中接收的 <code>state</code> 和 <code>props</code> 都保证为最新。updater 的返回值会与 <code>state</code> 进行浅合并。</p></blockquote><h3 id="6-4-2-传递对象"><a href="#6-4-2-传递对象" class="headerlink" title="6.4.2 传递对象"></a>6.4.2 传递对象</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./02_state/04_App_setState_object&#39; // 修改状态 传递对象

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(&lt;App /&gt;)
</code></pre><p><code>src/02_state/04_App_setState_object.jsx</code></p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

class App extends Component &#123;
  state = &#123;
    count: 100
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &#123; this.state.count &#125;
        &lt;button
          onClick=&#123; () =&gt; &#123;
            this.setState(&#123;
              count: this.state.count + 1
            &#125;, () =&gt; &#123;
              console.log(4, this.state.count) // 101
            &#125;)
            console.log(1, this.state.count) // 100

            this.setState(&#123;
              count: this.state.count + 1
            &#125;, () =&gt; &#123;
              console.log(5, this.state.count) // 101
            &#125;)
            console.log(2, this.state.count)// 100

            this.setState(&#123;
              count: this.state.count + 1
            &#125;, () =&gt; &#123;
              console.log(6, this.state.count) // 101
            &#125;)
            console.log(3, this.state.count)// 100
          &#125; &#125;
        &gt;加1&lt;/button&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default App;
</code></pre><blockquote><p>这种形式的 <code>setState()</code> 是异步的，并且在同一周期内会对多个 <code>setState</code> 进行批处理,相当于</p><pre><code>Object.assign(
   prevState,
   &#123;count: this.state.count + 1&#125;,
   &#123;count: this.state.count + 1&#125;,
   ...
)
</code></pre><p>后调用的 <code>setState()</code> 将覆盖同一周期内先调用 <code>setState</code> 的值，因此商品数仅增加一次。如果后续状态取决于当前状态,建议使用 updater 函数的形式代替（前面案例已经实现）。或者在第二个参数中再继续操作。</p></blockquote><blockquote><p>思考题：</p><p>1.<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/48610973/458193">何时以及为什么 <code>setState()</code> 会批量执行？</a></p><p>2.<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">为什么不直接更新 <code>this.state</code>？</a></p></blockquote><h1 id="七、生命周期"><a href="#七、生命周期" class="headerlink" title="七、生命周期"></a>七、生命周期</h1><p>组件的生命周期可分成三个状态：</p><ul><li>Mounting(挂载,初始化)：已插入真实 DOM</li><li>Updating(更新,运行时)：正在被重新渲染</li><li>Unmounting(卸载,销毁)：已移出真实 DOM</li></ul><p>生命周期图谱可以参考链接：<span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0cy53b2p0ZWttYWoucGwvcmVhY3QtbGlmZWN5Y2xlLW1ldGhvZHMtZGlhZ3JhbS8=">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</span></p><blockquote><p>类组件如何实现类似vue的计算属性： <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2Jsb2cvMjAxOC8wNi8wNy95b3UtcHJvYmFibHktZG9udC1uZWVkLWRlcml2ZWQtc3RhdGUuaHRtbCN3aGF0LWFib3V0LW1lbW9pemF0aW9u">https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization</span></p><pre><code class="sh">$ cnpm i memoize-one -S
</code></pre><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;
</code></pre></blockquote><blockquote><p>import App from ‘.&#x2F;02_state&#x2F;05_App_computed’ &#x2F;&#x2F; 类组件实现类似计算属性</p><p>const root &#x3D; ReactDOM.createRoot(document.getElementById(‘root’))</p><p>&#x2F;&#x2F; 标签形式调用<br>root.render(<app>)</app></p><pre><code>
`src/02_state/05_App_computed.jsx`

```jsx
import React, &#123; Component &#125; from &#39;react&#39;;
import memoize from &#39;memoize-one&#39;
class MemoList extends Component &#123;
state = &#123;
 text: &#39;&#39;
&#125;
filter = memoize((list, text) =&gt; &#123;
 return list.filter(item =&gt; text !== &#39;&#39; &amp;&amp; item.includes(text))
&#125;)
render () &#123;
 const list = this.filter(this.props.list, this.state.text)
 return (
   &lt;&gt;
     &lt;input type=&quot;text&quot; value=&#123; this.state.text &#125; onChange = &#123; (event) =&gt; &#123;
       this.setState(&#123;
         text: event.target.value
       &#125;)
     &#125; &#125;/&gt;
     &lt;ul&gt;
       &#123;
         list.map((item, index) =&gt; &#123;
           return (&lt;li key = &#123; index &#125;&gt; &#123; item &#125; &lt;/li&gt;)
         &#125;)
       &#125;
     &lt;/ul&gt;
   &lt;/&gt;
 )
&#125;
&#125;

class App extends Component &#123;
state = &#123;
 list: [&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abcd&#39;]
&#125;
render() &#123;
 return (
   &lt;div&gt;
     &lt;MemoList list=&#123;this.state.list&#125; /&gt;
   &lt;/div&gt;
 );
&#125;
&#125;

export default App;
</code></pre></blockquote><h2 id="7-1-三个阶段"><a href="#7-1-三个阶段" class="headerlink" title="7.1 三个阶段"></a>7.1 三个阶段</h2><h3 id="7-1-1-装载阶段"><a href="#7-1-1-装载阶段" class="headerlink" title="7.1.1 装载阶段"></a>7.1.1 装载阶段</h3><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p><ul><li><p><code>constructor()</code>: 在 React 组件挂载之前，会调用它的构造函数。</p><blockquote><p>如果不需要对类组件添加初始化数据以及绑定事件，那么就不需要写 <code>constructor</code></p></blockquote></li><li><p><code>static getDerivedStateFromProps()</code>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</p></li><li><p><code>render()</code>: render() 方法是 class 组件中唯一必须实现的方法。</p></li><li><p><code>componentDidMount()</code>: 在组件挂载后（插入 DOM 树中）立即调用。</p></li></ul><p>render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。</p><h3 id="7-1-2-更新阶段"><a href="#7-1-2-更新阶段" class="headerlink" title="7.1.2 更新阶段"></a>7.1.2 更新阶段</h3><p>每当组件的 state 或 props 发生变化时，组件就会更新。</p><p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p><ul><li><code>static getDerivedStateFromProps()</code>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</li><li><code>shouldComponentUpdate()</code>:当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。</li><li><code>render()</code>: render() 方法是 class 组件中唯一必须实现的方法。</li><li><code>getSnapshotBeforeUpdate()</code>: 在最近一次渲染输出（提交到 DOM 节点）之前调用。</li><li><code>componentDidUpdate()</code>: 在更新后会被立即调用,如果你需要<strong>执行副作用</strong>（例如，数据提取或动画）以响应 props 中的更改。</li></ul><p>render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。</p><h3 id="7-1-3-卸载阶段"><a href="#7-1-3-卸载阶段" class="headerlink" title="7.1.3 卸载阶段"></a>7.1.3 卸载阶段</h3><p>当组件从 DOM 中移除时会调用如下方法：</p><ul><li><code>componentWillUnmount()</code>: 在组件卸载及销毁之前直接调用。</li></ul><h3 id="7-1-4-Error-boundaries"><a href="#7-1-4-Error-boundaries" class="headerlink" title="7.1.4 Error boundaries"></a>7.1.4 Error boundaries</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvZXJyb3ItYm91bmRhcmllcy5odG1s">Error boundaries</span> 是 React 组件，它会在其子组件树中的任何位置捕获 JavaScript 错误，并记录这些错误，展示降级 UI 而不是崩溃的组件树。Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误。</p><blockquote><p>项目中需要使用的最多的生命周期的钩子函数为 <code>render</code>, <code>componentDidMount</code>,<code>componentDidUpdate</code>,<code>componentWillUnmount</code></p></blockquote><blockquote><p>详细介绍范例：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTI1MzI0OTY=">https://zhuanlan.zhihu.com/p/392532496</span></p></blockquote><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./02_state/06_App_lifeCycle&#39; // 类组件生命周期

class ErrorBoundary extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123; hasError: false &#125;;
  &#125;

  static getDerivedStateFromError(error) &#123;
    // 更新 state 使下一次渲染可以显示降级 UI
    return &#123; hasError: true &#125;;
  &#125;

  componentDidCatch(error, info) &#123;
    // &quot;组件堆栈&quot; 例子:
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    console.log(info.componentStack);
  &#125;

  render() &#123;
    if (this.state.hasError) &#123;
      // 你可以渲染任何自定义的降级 UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    &#125;

    return this.props.children;
  &#125;
&#125;
const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(&lt;ErrorBoundary&gt;
  &lt;App root = &#123; root &#125;/&gt;
&lt;/ErrorBoundary&gt;)
</code></pre><p><code>src/02_state/06_App_lifeCycle.jsx</code></p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

class App extends Component &#123;
  // constructor (props) &#123; // Useless constructor
  //   super(props)
  // &#125;
  state = &#123; count: 100 &#125;
  // static getDerivedStateFromProps (props, state) &#123; // 一般不使用
  //   // getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。
  //   // 它应返回一个对象来更新 state，如果返回 null 则不更新任何内容
  //   // state 的值在任何时候都取决于 props
  // &#125;

  componentDidMount () &#123;
    // 等同于 vue中的 mounted
    // 数据请求，实例化操作，DOM操作，定时器，计时器，订阅数据变化
    // 修改状态
    this.setState(&#123; count: this.state.count + 100 &#125;)
  &#125;

  shouldComponentUpdate (nextProps, nextState) &#123;
    // 可以作为react组件的性能优化的手段，但是也要慎用
    return true
  &#125;
  // getSnapshotBeforeUpdate(prevProps, prevState) &#123;
  //   // 在最近一次渲染输出（提交到 DOM 节点）之前调用。
  //   // 它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。
  //   // 此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。
  // &#125;

  componentDidUpdate(prevProps, prevState, snapshot) &#123;
    // 参照vue中 updated
    // 实例化操作，DOM操作, 特定条件可以请求数据以及修改数据
    // if (this.props.userID !== prevProps.userID) &#123; // 监听数据的变化
    //   this.fetchData(this.props.userID);
    // &#125;
  &#125;

  componentWillUnmount () &#123;
    // 参照vue  beforeDestory
    // 清理对象，取消订阅，消除定时器计时器
    // 当count的值等于210的时候销毁组件
  &#125;
  render() &#123;
    // 挂载阶段 依据初始化数据渲染数据
    // 更新阶段 当该组件的状态或者属性发生改变时触发此函数，也就输数据的改变引起视图的二次渲染
    return (
      &lt;div&gt;
        &lt;p&gt;&#123; this.state.count &#125;&lt;/p&gt;
        &lt;button onClick=&#123; () =&gt; &#123;
          if (this.state.count === 210) &#123;
            console.log(&#39;销毁组件&#39;)
            // 销毁组件
            this.props.root.unmount()
          &#125; else &#123;
            this.setState(&#123; count: this.state.count + 1 &#125; )
          &#125;
        &#125; &#125;&gt;加&lt;/button&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default App;
</code></pre><h2 id="7-2-两个时期"><a href="#7-2-两个时期" class="headerlink" title="7.2 两个时期"></a>7.2 两个时期</h2><p>将应用的渲染过程分为<code>mount</code>阶段（应用首次渲染）和<code>update</code>阶段（应用状态更新），无论在<code>mount</code>阶段还是<code>update</code>阶段，都会经历两个子阶段，一个是<code>render</code>阶段，一个是<code>commit</code>阶段。</p><p><strong>mount时</strong>：<br>在<code>render</code>阶段会根据jsx对象构建新的<code>workInProgressFiber</code>树，然后将相应的<code>fiber</code>节点标记为<code>Placement</code>，表示这个<code>fiber</code>节点需要被插入到<code>dom</code>树中，然后会这些带有副作用的<code>fiber</code>节点加入一条叫做<code>Effect List</code>的链表中。<br>在<code>commit</code>阶段会遍历<code>render</code>阶段形成的<code>Effect List</code>，执行链表上相应<code>fiber</code>节点的副作用，比如<code>Placement</code>插入，或者执行<code>Passive</code>（useEffect的副作用）。将这些副作用应用到真实节点上<br><strong>update时</strong>：<br>在<code>render</code>阶段会根据最新状态的jsx对象对比<code>current Fiber</code>，再构建新的<code>workInProgressFiber</code>树，这个对比的过程就是<code>diff算法</code>，<code>diff算法</code>又分成单节点的对比和多节点的对比，对比的过程中同样会经历收集副作用的过程，也就是将对比出来的差异标记出来，加入<code>Effect List</code>中，这些对比出来的副作用例如：<code>Placement</code>（插入）、<code>Update</code>(更新)、<code>Deletion</code>（删除）等。<br>在<code>commit</code>阶段同样会遍历<code>Effect List</code>，将这些fiber节点上的副作用应用到真实节点上。</p><blockquote><p>参考链接: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbXlzdGVyeS9hcnRpY2xlL2RldGFpbHMvMTIxODk3MjIz">https://blog.csdn.net/bemystery/article/details/121897223</span></p></blockquote><h2 id="7-3-入门理解React-Fiber架构"><a href="#7-3-入门理解React-Fiber架构" class="headerlink" title="7.3 入门理解React Fiber架构"></a>7.3 入门理解React Fiber架构</h2><p>在 React 16 之前，<code>VirtualDOM</code> 的更新采用的是<code>Stack</code>架构实现的，也就是循环递归方式。不过，这种对比方式有明显的缺陷，就是一旦任务开始进行就无法中断，如果遇到应用中组件数量比较庞大，那么<code>VirtualDOM</code> 的层级就会比较深，带来的结果就是主线程被长期占用，进而阻塞渲染、造成卡顿现象。</p><p>为了避免出现卡顿等问题，我们必须保障在执行更新操作时计算时不能超过16ms，如果超过16ms，就需要先暂停，让给浏览器进行渲染，后续再继续执行更新计算。而<code>Fiber</code>架构就是为了支持“可中断渲染”而创建的。</p><p>在<code>React</code>中，<code>Fiber</code>使用了一种新的数据结构<code>fiber tree</code>，它可以把虚拟<code>dom tree</code>转换成一个链表，然后再执行遍历操作，而链表在执行遍历操作时是支持断点重启的，示意图如下。</p><p>官方介绍中，<code>Fiber</code> 被理解为是一种数据结构，但是我们也可以将它理解为是一个执行单元。</p><p><code>Fiber</code> 可以理解为一个执行单元，每次执行完一个执行单元，<code>React Fiber</code>就会检查还剩多少时间，如果没有时间则将控制权让出去，然后由浏览器执行渲染操作。<code>React Fiber</code> 与浏览器的交互流程如下图。</p><p>可以看到，<code>React</code> 首先向浏览器请求调度，浏览器在执行完一帧后如果还有空闲时间，会去判断是否存在待执行任务，不存在就直接将控制权交给浏览器；如果存在就会执行对应的任务，执行完一个新的任务单元之后会继续判断是否还有时间，有时间且有待执行任务则会继续执行下一个任务，否则将控制权交给浏览器执行渲染，这个流程是循环进行的。</p><p>所以，我们可以将<code>Fiber</code> 理解为一个执行单元，并且这个执行单元必须是一次完成的，不能出现暂停。并且，这个小的执行单元在执行完后计算之后，可以移交控制权给浏览器去响应用户，从而提升了渲染的效率。</p><p>在官方的文档中，<code>Fibe</code>r 被解释为是一种数据结构，即链表结构。在链表结构中，每个<code>Virtual DOM</code> 都可以表示为一个 <code>fiber</code>，如下图所示。<br><img data-src="https://segmentfault.com/img/bVc1w1c" alt="image.png"><br>通常，一个 <code>fiber</code>包括了<code>child</code>（第一个子节点）、<code>sibling</code>（兄弟节点）、<code>return</code>（父节点)等属性，<code>React Fiber</code> 机制的实现，就是依赖于上面的数据结构。</p><p>通过介绍，我们知道<code>Fiber</code>使用的是链表结构，准确的说是<strong>单链表树结构</strong>。为了方便理解 <code>Fiber</code> 的遍历过程，下面我们就看下<code>Fiber</code>链表结构。</p><p>在上面的例子中，每一个单元都包含了<code>payload</code>（数据）和<code>nextUpdate</code>（指向下一个单元的指针）两个元素</p><blockquote><p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MjI3MTkxOQ==">https://segmentfault.com/a/1190000042271919</span></p></blockquote><h1 id="八、"><a href="#八、" class="headerlink" title="八、"></a>八、</h1><div class="tags"><a href="/tags/react/" rel="tag"><i class="ic i-tag"></i> react</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-31 10:59:11" itemprop="dateModified" datetime="2022-10-31T10:59:11+08:00">2022-10-31</time> </span><span id="react-study/3/" class="item leancloud_visitors" data-flag-title="React学习第三天" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 联系我</button><p>来交朋友吧！</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="叶星辰 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="叶星辰 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="叶星辰 QQ"><p>QQ</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>叶星辰 <i class="ic i-at"><em>@</em></i>永不陨落的星辰</li><li class="link"><strong>本文链接：</strong> <a href="https://www.yexingcheng.com/react-study/3/" title="React学习第三天">https://www.yexingcheng.com/react-study/3/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/react-study/2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx29mstj20zk0m8hdt.jpg" title="React学习第二天"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> react学习</span><h3>React学习第二天</h3></a></div><div class="item right"><a href="/react-study/4/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipetfk5zwj20zk0m8e81.jpg" title="React学习第四天"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> react学习</span><h3>React学习第四天</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81State"><span class="toc-number">1.</span> <span class="toc-text">六、State</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-state%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 state及其特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-state%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 state的定义和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-es6%E7%9A%84%E7%B1%BB-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1 es6的类 - 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-es7%E7%9A%84%E7%B1%BB-%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2 es7的类 - 属性初始化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%AE%E6%94%B9state"><span class="toc-number">1.3.</span> <span class="toc-text">6.3 如何正确的修改state</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-this-setState-%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">6.4 this.setState()方法及其特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">6.4.1 传递函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">6.4.2 传递对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">七、生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">7.1 三个阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E8%A3%85%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">7.1.1 装载阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">7.1.2 更新阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.3.</span> <span class="toc-text">7.1.3 卸载阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-Error-boundaries"><span class="toc-number">2.1.4.</span> <span class="toc-text">7.1.4 Error boundaries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%B8%A4%E4%B8%AA%E6%97%B6%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text">7.2 两个时期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3React-Fiber%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">7.3 入门理解React Fiber架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81"><span class="toc-number">3.</span> <span class="toc-text">八、</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/react-study/1/" rel="bookmark" title="React学习第一天">React学习第一天</a></li><li><a href="/react-study/2/" rel="bookmark" title="React学习第二天">React学习第二天</a></li><li class="active"><a href="/react-study/3/" rel="bookmark" title="React学习第三天">React学习第三天</a></li><li><a href="/react-study/4/" rel="bookmark" title="React学习第四天">React学习第四天</a></li><li><a href="/react-study/5/" rel="bookmark" title="React学习第五天">React学习第五天</a></li><li><a href="/react-study/6/" rel="bookmark" title="React学习第六天">React学习第六天</a></li><li><a href="/react-study/7/" rel="bookmark" title="React学习第七天">React学习第七天</a></li><li><a href="/react-study/8/" rel="bookmark" title="React学习第八天">React学习第八天</a></li><li><a href="/react-study/react-router-params/" rel="bookmark" title="React路由传参的几种方式">React路由传参的几种方式</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="叶星辰" data-src="/images/avatar.jpg"><p class="name" itemprop="name">叶星辰</p><div class="description" itemprop="description">温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhMW1EMHduMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Ca1mD0wn1"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9VZmRIbw==" title="https:&#x2F;&#x2F;twitter.com&#x2F;UfdHo"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tZW5nLXhpbmcteW91LWppLXNpLXl1ZS1odWFuZy0yNw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;meng-xing-you-ji-si-yue-huang-27"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTUwMjkxOTQ0NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;502919445"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NTc4MjU1ODg1" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7578255885"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="aHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvI2luYm94" title="https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;u&#x2F;0&#x2F;#inbox"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/react-study/2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/react-study/4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面试用">面试用</a></div><span><a href="/interview/wrapper-object/" title="js中包装对象">js中包装对象</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/7/" title="vue-mobile项目开发流程第七部分(构建detail页面)">vue-mobile项目开发流程第七部分(构建detail页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/15/" title="vue-mobile项目开发流程第十五部分(状态管理器,城市选择,登陆状态,已经路由守卫)">vue-mobile项目开发流程第十五部分(状态管理器,城市选择,登陆状态,已经路由守卫)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/14/" title="vue-mobile项目开发流程第十四部分(实现kind和user页面)">vue-mobile项目开发流程第十四部分(实现kind和user页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day3/" title="构建电商界面的小程序（一）">构建电商界面的小程序（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/1/" title="vue-mobile项目开发流程第一部分(项目搭建和技术栈选择)">vue-mobile项目开发流程第一部分(项目搭建和技术栈选择)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/3/" title="React学习第三天">React学习第三天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day1/" title="微信小程序学习第一天">微信小程序学习第一天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面试用">面试用</a></div><span><a href="/interview/Variable-recycling/" title="JS变量回收机制">JS变量回收机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面试用">面试用</a></div><span><a href="/interview/Array.Methods/" title="JS中数组方法总结">JS中数组方法总结</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">叶星辰 @ 永不陨落的星辰</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">624k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:28</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"react-study/3/",favicon:{show:"星辰",hide:"你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/miku.model.json"},display:{position:"right",width:250,height:500},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by hrmmi -->