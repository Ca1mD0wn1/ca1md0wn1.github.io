<!-- build time:Fri Nov 04 2022 09:56:55 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/atom.xml"><link rel="alternate" type="application/json" title="永不陨落的星辰" href="https://www.yexingcheng.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="react"><link rel="canonical" href="https://www.yexingcheng.com/react-study/7/"><title>React学习第七天 - react学习 | 永不陨落的星辰 = 永不陨落的星辰</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">React学习第七天</h1><div class="meta"><span class="item" title="创建时间：2022-08-07 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-07T00:00:00+08:00">2022-08-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>28k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>25 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">永不陨落的星辰</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicliierfjj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" itemprop="item" rel="index" title="分类于 react学习"><span itemprop="name">react学习</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.yexingcheng.com/react-study/7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="叶星辰"><meta itemprop="description" content=", 温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="永不陨落的星辰"></span><div class="body md" itemprop="articleBody"><h1 id="十七、hooks"><a href="#十七、hooks" class="headerlink" title="十七、hooks"></a>十七、hooks</h1><h2 id="17-1-为什么使用hooks"><a href="#17-1-为什么使用hooks" class="headerlink" title="17.1 为什么使用hooks"></a>17.1 为什么使用hooks</h2><p>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 React 一段时间，你也许会熟悉一些解决此类问题的方案，比如 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvcmVuZGVyLXByb3BzLmh0bWw=">render props</span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaGlnaGVyLW9yZGVyLWNvbXBvbmVudHMuaHRtbA==">高阶组件</span>。</p><p><strong>Hook 使你在非 class 的情况下可以使用更多的 React 特性。</strong> 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。</p><p><strong>react 18版本以前hooks</strong></p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYmFzaWMtaG9va3M=">基础 Hook</span><ul><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#usestate"><code>useState</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#useeffect"><code>useEffect</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a></li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYWRkaXRpb25hbC1ob29rcw==">额外的 Hook</span><ul><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#usecallback"><code>useCallback</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#usememo"><code>useMemo</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#useref"><code>useRef</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a></li><li><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/hooks-reference.html#uselayouteffect"><code>useLayoutEffect</code></a></li><li><code>useDebugValue</code></li></ul></li></ul><h2 id="17-2常见的hooks"><a href="#17-2常见的hooks" class="headerlink" title="17.2常见的hooks"></a>17.2常见的hooks</h2><h3 id="17-2-1-useState"><a href="#17-2-1-useState" class="headerlink" title="17.2.1 useState"></a>17.2.1 useState</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/01_App_hooks_useState&#39; // hooks useState

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App /&gt;
)
</code></pre><p><code>src/12_hooks/01_App_hooks_useState.jsx</code></p><pre><code class="jsx">// rsc
import React from &#39;react&#39;;
import &#123; useState &#125; from &#39;react&#39;;

// 函数式组件内不要使用this
// 如果想要 this 指向函数式组件，本身这个想法就是错误的
const App = () =&gt; &#123;
  // 定义了一个初始化状态 为count
  // 定义了一个修改初始化状态的函数 为 setCount
  // 使用 useState 定义了初始化装 count 的值为 1
  const [count, setCount] = useState(1)

  const [name, setName] = useState(&#39;吴&#39;)

  function add100 () &#123;
    setCount(count + 100)
  &#125;

  const add1000 = () =&gt; &#123;
    setCount(count + 1000)
  &#125;

  const add10000 = () =&gt; &#123;
    setCount(prevCount =&gt; &#123; // 函数写法
      console.log(prevCount) 
      return prevCount + 10000
    &#125;)
  &#125;
  return (
    &lt;div&gt;
      &#123; count &#125;
      &lt;button onClick=&#123; () =&gt; &#123;
        // 修改函数内部的值为 运算之后的结果
        setCount(count + 1)
      &#125; &#125;&gt;加1&lt;/button&gt;
      &lt;button onClick=&#123; function () &#123;
        // 修改函数内部的值为 运算之后的结果
        setCount(count + 10)
      &#125; &#125;&gt;加10&lt;/button&gt;

      &lt;button onClick=&#123; add100 &#125;&gt;加100&lt;/button&gt;
      &lt;button onClick=&#123; add1000 &#125;&gt;加1000&lt;/button&gt;
      &lt;button onClick=&#123; add10000 &#125;&gt;加10000&lt;/button&gt;
      &#123; name &#125;
      &lt;button onClick=&#123; () =&gt; &#123;
        setName(&#39;吴大勋&#39;)
      &#125; &#125;&gt;修改name&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/02_App_hooks_useState_obj&#39; // hooks useState  object

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App /&gt;
)
</code></pre><p><code>src/12_hooks/02_App_hooks_useState_obj.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useState &#125; from &#39;react&#39;;

const App = () =&gt; &#123;
  const [obj, setObj] = useState(&#123;
    w: 100,
    h: 100,
    x: 0,
    y: 0
  &#125;)

  const mouseMove = (event) =&gt; &#123;
    // 鼠标移动，发现 w 和 h 的数据丢失, &#123; x: 1, y: 1&#125; 代替了原来的对象 obj 
    // setObj(&#123;
    //   x: event.clientX,
    //   y: event.clientY
    // &#125;)

    // setObj(&#123; // 合并新数据到原来的 obj
    //   ...obj,
    //   x: event.clientX,
    //   y: event.clientY
    // &#125;)

    setObj(prevObj =&gt; &#123;
      // return &#123;
      //   w: prevObj.w,
      //   h: prevObj.h,
      //   x: event.clientX,
      //   y: event.clientY
      // &#125;
      return Object.assign(&#123;&#125;, prevObj, &#123; x: event.clientX &#125;, &#123; y: event.clientY&#125;)
    &#125;)
  &#125;

  return (
    &lt;div style=&#123; &#123; width: &#39;100vw&#39;, height: &#39;100vh&#39; &#125; &#125; onMouseMove = &#123; mouseMove &#125;&gt;
      &lt;div&gt;元素的宽为: &#123; obj.w &#125;，元素的高为： &#123; obj.h &#125;&lt;/div&gt;
      &lt;div&gt;元素的坐标点为： (&#123; obj.x &#125;,&#123;  obj.y&#125;)&lt;/div&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/03_App_hooks_useState_state&#39; // hooks useState  拆分对象状态

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App /&gt;
)
</code></pre><p><code>src/12_hooks/03_App_hooks_useState_state.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useState &#125; from &#39;react&#39;;

const App = () =&gt; &#123;

  // 如果不需要修改状态，那么可以不写解构的第二个值
  const [ box ] = useState(&#123; w: 100, h: 100 &#125;)
  const [position, setPosition] = useState(&#123; x: 0, y: 0 &#125;)

  const mouseMove = (event) =&gt; &#123;
    setPosition(&#123;
      x: event.clientX,
      y: event.clientY
    &#125;)
  &#125;

  return (
    &lt;div style=&#123; &#123; width: &#39;100vw&#39;, height: &#39;100vh&#39; &#125; &#125; onMouseMove = &#123; mouseMove &#125;&gt;
      &lt;div&gt;元素的宽为: &#123; box.w &#125;，元素的高为： &#123; box.h &#125;&lt;/div&gt;
      &lt;div&gt;元素的坐标点为： (&#123; position.x &#125;,&#123;  position.y&#125;)&lt;/div&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><ul><li><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。</p></li><li><p><strong>只在 React 函数中调用 Hook，</strong>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul></li><li><p>如果遇到需要以对象的形式定义状态时，根据需求划分对象，因为修改状态使用的是替换</p></li></ul></blockquote><h3 id="17-2-2-useEffect"><a href="#17-2-2-useEffect" class="headerlink" title="17.2.2 useEffect"></a>17.2.2 useEffect</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./12_hooks/04_App_hooks_useEffect&#39; // hooks useEffect  

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App root=&#123;root&#125;/&gt;
)
</code></pre><p><code>src/12_hooks/04_App_hooks_useEffect.jsx</code></p><pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;

const App = (props) =&gt; &#123;
  const [proList, setProList] = useState([])

  const [count, setCount] = useState(1)
  // 数据请求 --- 函数式组件没有 生命周期钩子函数
  // useEffect 的第一个参数是一个回调函数 类似于类组件中的 componentDidMount 以及 componentDidUpdate
  // useEffect 内的代码会自动执行
  // useEffect 如果没有添加第二个依赖的参数，那么只要内部修改果状态，此部分代码就会一直执行
  // useEffect(() =&gt; &#123;
  //   fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
  //     console.log(res.data) // 第一次打印 - componentDidMount
  //     setProList(res.data) // 发现上一句话一直在打印 - componentDidUpdate 且没有条件限制
  //   &#125;)
  // &#125;)

  // 可以给useEffect添加第二个参数进行控制内部代码执行的次数
  // useEffect(() =&gt; &#123;
  //   fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
  //     console.log(res.data) 
  //     setProList(res.data) 
  //   &#125;)
  // &#125;, []) // useEffect 第二个参数为空数组，代表useEffect 内部只会执行类似 componentDidMount 的操作
  
  // 依赖值发生改变，再次触发代码执行，类似于componentDidUpdate中特定条件下请求数据
  useEffect(() =&gt; &#123;
    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
      console.log(res.data) 
      setProList(res.data) 
    &#125;)
  &#125;, [count]) // 第二个参数写入值，代表只有当count的值发生改变时，才会再次触发useEffect，再次执行


  // 如何模拟 组件的销毁呢？
  // 在useEffect内部的回调函数中 返回一个函数
  useEffect(() =&gt; &#123;

    // 为防止内存泄漏，清除函数会在组件卸载前执行。
    // 另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。
    return () =&gt; &#123; // 类似于类组件中的componentWillUnmount
      // 取消订阅的操作，销毁定时器，计时器等操作
      console.log(&#39;组件销毁了&#39;)
    &#125;
  &#125;, [count])
  return (
    &lt;div&gt;
      &lt;button onClick=&#123; () =&gt; &#123;
        setCount(count + 1)
        if (count === 5) &#123;
          props.root.unmount()
        &#125;
      &#125;&#125;&gt;加1&lt;/button&gt; &#123; count &#125;
      &lt;ul&gt;
        &#123;
          proList &amp;&amp; proList.map(item =&gt; (
            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;
          ))
        &#125;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><ol><li>useEffect() 是个副作用函数。</li><li>useEffect() 函数在每次组件重新渲染时，可再次被调用。</li><li>在开发环境中，开启了 React.StrictMode 模式，组件开始时被渲染两次。</li><li>useEffect() 通过返回函数来清理副作用。</li><li>useEffect() 通过传递第二个参数数组来提高渲染性能，或者说实现 watch 效果。</li></ol></blockquote><h3 id="17-2-3-useRef"><a href="#17-2-3-useRef" class="headerlink" title="17.2.3 useRef"></a>17.2.3 useRef</h3><p>利用 <code>useRef</code> 就可以绕过 Capture Value 的特性。<strong>可以认为</strong> <code>ref</code> <strong>在所有 Render 过程中保持着唯一引用，因此所有对</strong> <code>ref</code> <strong>的赋值或取值，拿到的都只有一个最终状态</strong>，而不会在每个 Render 间存在隔离。</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/05_App_hooks_useRef&#39; // hooks useRef  

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/05_App_hooks_useRef.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useEffect &#125; from &#39;react&#39;;
import &#123; useRef &#125; from &#39;react&#39;;

const FunCom = React.forwardRef((props, ref) =&gt; &#123;
  return (
    &lt;div ref = &#123; ref &#125;&gt;函数式组件&lt;/div&gt;
  )
&#125;)

class Com extends React.Component &#123;
  state = &#123; name: &#39;类组件&#39; &#125;
  testFn = () =&gt; &#123;
    console.log(this.state.name + &#39;!!&#39;)
  &#125;
  render () &#123;
    return (
      &lt;div&gt;类组件&lt;/div&gt;
    )
  &#125;
&#125;

const App = () =&gt; &#123;
  const btnRef = useRef() // 类组件中  React.createRef()
  const comRef = useRef()
  const funRef = useRef()
  useEffect(() =&gt; &#123;
    console.log(btnRef.current)
    console.log(comRef.current)
    console.log(funRef.current)
  &#125;, [])

  return (
    &lt;div&gt;
      &lt;button ref = &#123; btnRef &#125;&gt;按钮ref&lt;/button&gt;
      &lt;Com ref = &#123; comRef &#125;/&gt;
      &lt;FunCom ref = &#123; funRef &#125;/&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><h3 id="17-2-4-useReducer"><a href="#17-2-4-useReducer" class="headerlink" title="17.2.4 useReducer"></a>17.2.4 useReducer</h3><p>useReducer 践行了 Flux&#x2F;Redux 思想。使用步骤：</p><p>1、创建初始值initialState</p><p>2、创建所有操作 reducer(state, action);</p><p>3、传给 userReducer，得到读和写API</p><p>4、调用写 ({type: ‘操作类型’})</p><p>总的来说，useReducer 是 useState 的复杂版。</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/06_App_hooks_useReducer&#39; // hooks useReducer  

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/06_App_hooks_useReducer.jsx</code></p><pre><code class="jsx">import React, &#123; useEffect &#125; from &#39;react&#39;;
import &#123; useReducer &#125; from &#39;react&#39;;
// 1.创建初始化状态
const initialState = &#123;
  bannerList: [],
  proList: []
&#125;

// 2.创建所有操作 reducer(state, action)
const reducer = (state, action) =&gt; &#123;
  switch (action.type) &#123;
    case &#39;CHANGE_BANNER_LIST&#39;:
      // 返回一个新的状态 -- 当触发修改轮播图数据时，得到一个新的数据
      // 如何保证得到一份新的数据  -- 推荐使用 对象的合并
      // return &#123; ...state, bannerList: action.payload &#125;
      return Object.assign(&#123;&#125;, state, &#123; bannerList: action.payload &#125;)
    case &#39;CHANGE_PRO_LIST&#39;:
      return &#123; ...state, proList: action.payload &#125;
    default:
      return state
  &#125;
&#125;

const App = () =&gt; &#123;
  // 3.传给 userReducer，得到读和写API
  // state代表所有的数据
  // dispatch可以触发reducer的改变
  const [state, dispatch] = useReducer(reducer, initialState)

  useEffect(() =&gt; &#123;
    fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
      dispatch(&#123;
        type: &#39;CHANGE_BANNER_LIST&#39;,
        payload: res.data
      &#125;)
    &#125;)
    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;
      dispatch(&#123;
        type: &#39;CHANGE_PRO_LIST&#39;,
        payload: res.data
      &#125;)
    &#125;)
  &#125;, [])
  return (
    &lt;div&gt;
       &#123;
          state.bannerList &amp;&amp; state.bannerList.map(item =&gt; (
            &lt;img key = &#123; item.bannerid &#125;  alt=&#123; item.alt &#125; src = &#123; item.img &#125; style=&#123;&#123; height: 100 &#125;&#125;/&gt;
          ))
        &#125;

      &lt;ul&gt;
        &#123;
          state.proList &amp;&amp; state.proList.map(item =&gt; (
            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;
          ))
        &#125;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><p>如果遇到多个组件需要共享状态时，单纯useReducer就显得无能为力</p></blockquote><h3 id="17-2-5-useContext"><a href="#17-2-5-useContext" class="headerlink" title="17.2.5 useContext"></a>17.2.5 useContext</h3><p>1、使用 C &#x3D; createContext(initial) 创建上下文</p><p>2、使用 &lt;C.Provider&gt; 圈定作用域</p><p>3、在作用域内使用 useContext(C)来使用上下文</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/07_App_hooks_useContext&#39; // hooks useContext  

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/07_App_hooks_useContext.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useContext &#125; from &#39;react&#39;;
const LangContext = React.createContext()
const ColorContext = React.createContext()
const Second = () =&gt; &#123;
  const lang = useContext(LangContext)
  const color = useContext(ColorContext)
  return (
    &lt;&gt;
      &lt;h1&gt;Second&lt;/h1&gt;
      &#123; lang &#125; - &#123; color &#125;
    &lt;/&gt;
  )
&#125;

const First = () =&gt; &#123;
  return (
    &lt;&gt;
      &lt;h1&gt;first&lt;/h1&gt;
      &lt;Second /&gt;
    &lt;/&gt;
  )
&#125;
const App = () =&gt; &#123;
  return (
    &lt;div&gt;
      &lt;LangContext.Provider value = &quot;中文&quot;&gt;
        &lt;ColorContext.Provider value = &quot;red&quot;&gt;
          &lt;First /&gt;
        &lt;/ColorContext.Provider&gt;
      &lt;/LangContext.Provider&gt;
      
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><p><strong>使用 useReducer 和 useContext 实现轻型Redux,可以让组件间共享状态</strong></p><p>步骤：</p><p>1、将数据集中在一个 store 对象</p><p>2、将所有操作集中在 reducer</p><p>3、创建一个 Context</p><p>4、创建对数据的读取 API</p><p>5、将第四步的内容放到第三步的 Context</p><p>6、用 Context.Provider 将 Context 提供给所有组件</p><p>7、各个组件用 useContext 获取读写API</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/08_App_hooks_redux&#39; // hooks useContext useReducer redux

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/09-App-redux.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useContext &#125; from &#39;react&#39;;
import &#123; useEffect &#125; from &#39;react&#39;;
import &#123; useReducer &#125; from &#39;react&#39;;

const MyContext = React.createContext()
const intitalState = &#123;
  userName: &#39;吴大勋&#39;,
  count: 100,
  proList: []
&#125;

const reducer = (state, action) =&gt; &#123;
  switch (action.type) &#123;
    case &#39;CHANGE_USER_NAME&#39;:
      return &#123; ...state, userName: action.payload &#125;
    case &#39;CHANGE_COUNT&#39;: 
      return &#123; ...state, count: action.payload&#125;
    case &#39;CHANGE_PRO_LIST&#39;: 
      return &#123; ...state, proList: action.payload&#125;
    default:
      return state
  &#125;
&#125;


const Home = () =&gt; &#123;
  // const [state, dispatch] = useReducer(reducer, intitalState)
  const &#123; state, dispatch &#125;  = useContext(MyContext)
  useEffect(() =&gt; &#123; // 不要直接在回调函数上使用async
    const fetchData = async () =&gt; &#123;
      const res = await  fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json())
      dispatch(&#123;
        type: &#39;CHANGE_PRO_LIST&#39;,
        payload: res.data
      &#125;)
    &#125;
    fetchData()

  &#125;, [dispatch])
  return (
    &lt;&gt;
      &lt;h1&gt;Home&lt;/h1&gt;
      &lt;ul&gt;
        &#123;
          state.proList &amp;&amp; state.proList.map(item =&gt; (
            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;
          ))
        &#125;
      &lt;/ul&gt;
    &lt;/&gt;
  )
&#125;
const List = () =&gt; &#123;
  // const [state, dispatch] = useReducer(reducer, intitalState)
  const &#123; state &#125;  = useContext(MyContext)
  return (
    &lt;&gt;
      &lt;h1&gt;List&lt;/h1&gt;
      &lt;ul&gt;
        &#123;
          state.proList &amp;&amp; state.proList.map(item =&gt; (
            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;
          ))
        &#125;
      &lt;/ul&gt;
    &lt;/&gt;
  )
&#125;

// Home 组件  以及 List 组件共享 列表数据
const App = () =&gt; &#123;
  const [state, dispatch] = useReducer(reducer, intitalState)
  return (
    &lt;div&gt;
      &lt;MyContext.Provider value = &#123; &#123;
        state,
        dispatch
      &#125;&#125; &gt;
        &lt;Home /&gt;
        &lt;List /&gt;
      &lt;/MyContext.Provider&gt;
      
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><p>useContext + useReducer 可以实现轻型redux，但是不适合应用于多模块管理的大型项目</p></blockquote><h3 id="17-2-6-useMemo"><a href="#17-2-6-useMemo" class="headerlink" title="17.2.6 useMemo"></a>17.2.6 useMemo</h3><h3 id="17-2-7-useCallback"><a href="#17-2-7-useCallback" class="headerlink" title="17.2.7 useCallback"></a>17.2.7 useCallback</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/09_App_hooks_useCallback_useMemo&#39; // hooks useCallback useMemo 提升性能以及计算属性

const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/09_App_hooks_useCallback_useMemo.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;
import &#123; useMemo &#125; from &#39;react&#39;;
import &#123; useCallback &#125; from &#39;react&#39;;
import &#123; useState &#125; from &#39;react&#39;;

// const Child = (props) =&gt; &#123;
//   console.log(&#39;child被执行了&#39;)
//   return (
//     &lt;div&gt;child - &#123; props.b &#125;&lt;/div&gt;
//   )
// &#125;
const Child = React.memo((props) =&gt; &#123;
  console.log(&#39;child被执行了&#39;)
  return (
    &lt;div&gt;child - &#123; props.b &#125;&lt;/div&gt;
  )
&#125;)

const Com = React.memo((props) =&gt; &#123;
  console.log(&#39;com被执行了&#39;)
  return (
    &lt;div&gt;com - &#123; props.b &#125;&lt;/div&gt;
  )
&#125;)

const App = () =&gt; &#123;
  const [a, setA] = useState(0)
  // const [b] = useState(100)
  const [b, setB] = useState(100)

  const [list, setList] = useState([1, 2, 3, 4, 5])

  const add = () =&gt; &#123;
    setA(a + 1)
  &#125;

  const addB = () =&gt; &#123;
    setB(b + 1)
  &#125;

  // 每次更新生成一个新的引用，意味这属性发生改变
  // const testFn = () =&gt; &#123;&#125;
  // 如果记住这个函数 useCallback 以及 useMemo ，从而达到提升组件性能的目的
  // const testFn = useCallback(() =&gt; &#123; // useCallback结构
  //   return (event) =&gt; &#123; // 真正的函数实现
  //   &#125;
  // &#125;, []) // 依赖值的改变，重新生成新的引用
  const testFn = useMemo((event) =&gt; &#123; // 真正的函数
  &#125;, [])

  // 函数式组件中，通常使用useMemo可以实现计算属性
  // const doubleA = a * 2 // 不推荐
  const doubleA = useMemo(() =&gt; &#123;
    return a * 2
  &#125;, [a])

  const len = useMemo(() =&gt; &#123;
    return list.length
  &#125;, [list])
  return (
    &lt;div&gt;
      &lt;button onClick=&#123; () =&gt; &#123;
        const arr = JSON.parse(JSON.stringify(list)) // 深拷贝
        arr.push(len+1)
        setList(arr)
      &#125;&#125;&gt;追加数据&lt;/button&gt;&#123;list&#125;
      &lt;button onClick=&#123; add &#125;&gt;a加1&lt;/button&gt; &#123; a &#125; - &#123; doubleA &#125; - &#123; len &#125;
      &lt;button onClick=&#123; addB &#125;&gt;b加1&lt;/button&gt; &#123; b &#125;
      &#123;/* 理想情况 b的值发生改变，Child 组件才被重新渲染 */&#125;
      &#123;/* 可以使用高阶组件 React.memo() 包裹一下Child组件 */&#125;
      &lt;Child b=&#123; b &#125;/&gt;

      &#123;/* 组件的状态发生改变，组件重新渲染，重新渲染，就会给函数生成一个新的地址，意味着全新的一个属性 */&#125;
      &lt;Com b = &#123; b &#125; testFn = &#123; testFn &#125;/&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><p>useCallback 应用于 组件的事件，使用useCallback 包裹组件 - 记忆函数</p><p>useMemo 可以是计算属性， 也应用于 组件的事件，使用useMemo 包裹组件 - 记忆组件</p></blockquote><h3 id="17-2-8-useImperativeHandle"><a href="#17-2-8-useImperativeHandle" class="headerlink" title="17.2.8 useImperativeHandle"></a>17.2.8 useImperativeHandle</h3><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/10_App_hooks_useImperativeHandle.jsx&#39; // useImperativeHandle 父组件操作子组件的方法


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/10_App_hooks_useImperativeHandle.jsx.jsx</code></p><pre><code class="jsx">import React from &#39;react&#39;;

// const Child = React.forwardRef((props, ref) =&gt; &#123;

//   return (
//     &lt;&gt;
//       &lt;input ref = &#123; ref &#125;/&gt;
//     &lt;/&gt;
//   )
// &#125;)

// 可以实现子组件中多个 ref 的使用
const Child = React.forwardRef((props, ref) =&gt; &#123;
  const inputRef = React.useRef()
  const divRef = React.useRef()
  // 父组件通过 ref 即可 调用 内部自定义的函数 通过透传ref解决问题
  React.useImperativeHandle(ref, () =&gt; &#123;
    return &#123;
      inputFocus: () =&gt; &#123;
        inputRef.current.focus()
      &#125;,
      wirteVal (str) &#123;
        divRef.current.innerHTML = str
      &#125;
    &#125;
  &#125;)
  return (
    &lt;&gt;
      &lt;input ref = &#123; inputRef &#125;/&gt;
      &lt;div ref = &#123; divRef &#125;&gt;&lt;/div&gt;
    &lt;/&gt;
  )
&#125;)

const App = () =&gt; &#123;
  const childRef = React.useRef()
  return (
    &lt;div&gt;
      &lt;button onClick=&#123; () =&gt; &#123;
        // childRef.current.focus()
        childRef.current.inputFocus()
      &#125;&#125; style=&#123;&#123; marginRight: 30 &#125;&#125;&gt;获取焦点&lt;/button&gt;
      &lt;button onClick=&#123; () =&gt; &#123;
        // childRef.current.focus()
        childRef.current.wirteVal(&#39;hello hooks!!&#39;)
      &#125;&#125; style=&#123;&#123; marginRight: 30 &#125;&#125;&gt;写入内容&lt;/button&gt;
      &lt;Child ref = &#123; childRef &#125;/&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><p>上面这个例子中与直接转发 ref 不同，直接转发 ref 是将 <code>React.forwardRef</code> 中函数上的 ref 参数直接应用在了返回元素的 ref 属性上，其实父、子组件引用的是同一个 ref 的 current 对象，官方不建议使用这样的 ref 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 ref，通过 <code>React.forwardRef</code> 将父组件的 ref 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 current。</p><p><code>useImperativeHandle</code>的第一个参数是定义 current 对象的 ref，第二个参数是一个函数，返回值是一个对象，即这个 ref 的 current 对象，这样可以像上面的案例一样，通过自定义父组件的 ref 来使用子组件 ref 的某些方法。</p><p><code>useImperativeHandle</code> 和<code>React.forwardRef</code>必须是配合使用的，这也是为什么在开头要介绍 ref 的转发。</p><h3 id="17-2-9-useLayoutEffect"><a href="#17-2-9-useLayoutEffect" class="headerlink" title="17.2.9 useLayoutEffect"></a>17.2.9 useLayoutEffect</h3><p>useLayoutEffect 与 useEffect的区别：</p><ul><li><code>useEffect</code> 是异步执行的，而<code>useLayoutEffect</code>是同步执行的。</li><li><code>useEffect</code> 的执行时机是浏览器完成渲染之后，而 <code>useLayoutEffect</code> 的执行时机是浏览器把内容真正渲染到界面之前</li></ul><p>举个例子：</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;


import App from &#39;./12_hooks/11_App_hooks_useLayoutEffect&#39; // useLayoutEffect 


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/13-App-useLayoutEffect.jsx</code></p><pre><code class="jsx">import React, &#123; useEffect, useLayoutEffect, useState &#125; from &#39;react&#39;;

// const App = () =&gt; &#123;
//   const [count, setCount] = useState(1)
//   useEffect(() =&gt; &#123; // 副作用操作- 异步操作
//     console.log(&#39;useEffect&#39;) // 后执行
//     document.title = count + &#39;!!&#39;

//   &#125;)
//   useLayoutEffect(() =&gt; &#123; // 同步操作 - DOM相关
//     console.log(&#39;useLayoutEffect&#39;) // 先执行
//     document.title = count
//   &#125;) 
//   return (
//     &lt;div&gt;
//       &lt;h1&gt;useLayoutEffect&lt;/h1&gt;
//       &#123; count &#125;
//       &lt;button onClick=&#123; () =&gt; &#123;
//         setCount(count + 1)
//       &#125;&#125;&gt;加1&lt;/button&gt;
//     &lt;/div&gt;
//   );
// &#125;;

function App() &#123;
  const [ state1, setState1 ] = useState(&#39;hello&#39;)
  const [ state2, setState2 ] = useState(&#39;hi&#39;)

  useEffect(() =&gt; &#123;
    let i = 0
    while (i &lt; 1000000000) &#123;
      i++
    &#125;
    setState1(&#39;world&#39;)
  &#125;, [])
  useLayoutEffect(() =&gt; &#123;
    let i = 0
    while (i &lt; 1000000000) &#123;
      i++
    &#125;
    setState2(&#39;world&#39;)
  &#125;, [])

  return (
    &lt;&gt;
      &lt;h1&gt;&#123;state1&#125;&lt;/h1&gt;
      &lt;h1&gt;&#123;state2&#125;&lt;/h1&gt;
    &lt;/&gt;
  )
&#125;


export default App;
</code></pre><blockquote><p>注意观察 useEffect 抖动现象</p><p>useLayoutEffect 做DOM操作</p><p>useEffect 中 副作用执行</p></blockquote><h3 id="17-2-10-useDebugValue"><a href="#17-2-10-useDebugValue" class="headerlink" title="17.2.10 useDebugValue"></a>17.2.10 useDebugValue</h3><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/12_App_hooks_useDebugValue&#39; // useDebugValue 


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/12_App_hooks_useDebugValue.jsx</code></p><pre><code class="jsx">import React, &#123; useEffect, useState, useDebugValue &#125; from &#39;react&#39;;

// const App = () =&gt; &#123;
//   const [count, setCount] = useState(1)
//   const add = () =&gt; &#123;
//     setCount(count + 1)
//   &#125;

//   useEffect(() =&gt; &#123;
//     document.title = `点击了$&#123;count&#125;次`
//   &#125;)
//   return (
//     &lt;div&gt;
//       &lt;button onClick=&#123; add &#125;&gt;加1&lt;/button&gt;
//     &lt;/div&gt;
//   );
// &#125;;
// 自定义hook
const useCount = () =&gt; &#123;
  const [count, setCount] = useState(1)
  const add = () =&gt; &#123;
    setCount(count + 1)
  &#125;
  useDebugValue(&#39;myCount&#39;) // 自定义Hook起名
  return &#123;
    count,
    add
  &#125;
&#125;

const useTitle = (count) =&gt; &#123;
  useEffect(() =&gt; &#123;
    document.title = `点击了$&#123;count&#125;次`
  &#125;) 
  useDebugValue(&#39;myTitle&#39;) // 自定义Hook起名
&#125;


const App = () =&gt; &#123;
  // const [count, setCount] = useState(1)
  // const add = () =&gt; &#123;
  //   setCount(count + 1)
  // &#125;

  const &#123; count, add &#125; = useCount()

  // useEffect(() =&gt; &#123;
  //   document.title = `点击了$&#123;count&#125;次`
  // &#125;)

  useTitle(count)

  return (
    &lt;div&gt;
      &lt;button onClick=&#123; add &#125;&gt;加1&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><p>接下来的hooks是属于react18版本新增的hooks</p><h3 id="17-2-11-useId"><a href="#17-2-11-useId" class="headerlink" title="17.2.11 useId"></a>17.2.11 useId</h3><p><code>useId</code>是一个钩子，用于生成唯一的ID，在服务器和客户端之间是稳定的，同时避免hydration 不匹配。</p><blockquote><p>注意：</p><p><code>useId</code>不是用来生成列表中的键的。<code>Keys</code> 应该从你的数据中生成。</p><p>不能用于列表渲染的key值</p></blockquote><p>对于一个基本的例子，直接将id传递给需要它的元素。</p><p>对于同一组件中的多个ID，使用相同的ID附加一个后缀。</p><p><code>src/index.js</code></p><pre><code class="js">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/13_App_hooks_useId&#39; // useId 


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/13_App_hooks_useId.jsx</code></p><pre><code class="jsx">import React, &#123; useId &#125; from &#39;react&#39;;

//React Hook &quot;useId&quot; cannot be called inside a callback. 
// React Hooks must be called in a React function component or a custom React Hook function
// useId不能在回调函数中使用，
// react hooks 必须包裹在函数式组件或者自定义hooks中使用
const App = () =&gt; &#123;
  // const [list] = useState([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
  const useNameId = useId()
  const passwordId = useId()
  return (
    &lt;div&gt;
      &#123;
        // list &amp;&amp; list.map((item) =&gt; &#123;
        //   const id = useId() // 这样的写法是错误的
        //   return (
        //     &lt;p key = &#123; id &#125;&gt; &#123; item &#125; &lt;/p&gt;
        //   )
        // &#125;)
      &#125;
      &#123;/* HTML 中使用for，react中使用HtmlFor */&#125;
      &lt;div&gt;
        &lt;label htmlFor=&#123; useNameId &#125;&gt;用户名&lt;/label&gt;
        &lt;input type=&quot;text&quot; id = &#123; useNameId &#125; /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label htmlFor = &#123; passwordId &#125;&gt;密码&lt;/label&gt;
        &lt;input type=&quot;password&quot; id = &#123; passwordId &#125; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
&#125;;

export default App;
</code></pre><blockquote><p><strong>注意：</strong></p><p><code>useId</code> 会生成一个包含 : token的字符串。这有助于确保令牌是唯一的，但在CSS选择器或API（如<code>querySelectorAll</code>）中不支持。</p><p><code>useId</code>支持一个<code>identifierPrefix</code>，以防止在多根应用程序中发生碰撞。要配置，请参阅 <code>hydrateRoot</code> 和 <code>ReactDOMServer</code>的选项。</p><p>hooks需要在函数式组件以及自定义hook的顶级使用（返回jsx代码之前），不要在jsx代码中使用hooks</p></blockquote><h3 id="17-2-12-useDeferredValue"><a href="#17-2-12-useDeferredValue" class="headerlink" title="17.2.12 useDeferredValue"></a>17.2.12 useDeferredValue</h3><blockquote><p>真实需求其实不需要实时渲染所有的数据</p></blockquote><p><code>useDeferredValue</code> 需要接收一个值, 返回这个值的副本, 副本的更新会在值更新渲染之后进行更新, 以此来避免一些不必要的重复渲染. 打个比方页面中有输入框, 输入框下的内容依赖于输入框的值, 但是输入框是一个高频操作, 如果输入10次, 可能用户只想看到最终的结果那么中途的实时渲染就显得不那么重要了, 页面元素少点还好, 一旦元素过多页面就会及其的卡顿, 渲染引擎堵得死死的, 用户就会骂娘了, 此时使用useDeferredValue是一个很好的选择</p><p><code>src/index.js</code></p><pre><code class="jsx">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

import App from &#39;./12_hooks/14_App_hooks_useDeferredValue&#39; // useDeferredValue 


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/14_App_hooks_useDeferredValue.jsx</code> 数据量必须过大，否则看不到效果</p><pre><code class="jsx">import React, &#123; useDeferredValue, useEffect, useState, useMemo, memo &#125; from &#39;react&#39;
const List = memo(function List(&#123;count&#125;) &#123;
  const [data, setData] = useState([])

  useEffect(() =&gt; &#123;
    const data = []
    data.length = 50000
    for (let i = 0; i &lt; data.length; i++) &#123;
      data.fill(i+1, i)
    &#125;
    setData(data)

  &#125;, [count])

  return (
    &lt;div&gt;
      &#123;
        data.map((item) =&gt; &#123;
          return (
            &lt;p key=&#123;item&#125;&gt;&#123;count&#125;&lt;/p&gt;
          )
        &#125;)
      &#125;
    &lt;/div&gt;
  )
&#125;)

export default function UseDeferredValueDemo() &#123;
  const [inpVal, setInpVal] = useState(&#39;&#39;)
  const deferredValue = useDeferredValue(inpVal) // 备份数据
  const memoList = useMemo(() =&gt; &lt;List count=&#123;deferredValue&#125;&gt;&lt;/List&gt;, [deferredValue])
  return (
    &lt;&gt;
      &lt;h1&gt;UseDeferredValue&lt;/h1&gt;
      &lt;input type=&quot;text&quot; value=&#123;inpVal&#125;  onChange=&#123;(e) =&gt; setInpVal(e.target.value)&#125;/&gt;
      &#123;memoList&#125;
    &lt;/&gt;
  )
&#125;
</code></pre><h3 id="17-2-13-useTransition"><a href="#17-2-13-useTransition" class="headerlink" title="17.2.13 useTransition"></a>17.2.13 useTransition</h3><p><code>useTransition</code> 又叫过渡, 他的作用就是标记非紧急更新, 这些被标记非紧急更新会在紧急更新完之后进行更新, <code>useTransition</code> 使用场景在应对渲染量很大的页面，需要及时响应某些事件的情况。</p><p>举个例子，准备一个进度条, 通过滑动进度条来显示进度条的进度并且渲染相同进度数量的div, 如果我们不对渲染进行优化那无疑页面会很卡, 此时使用过渡配合useMemo来缓存页面结构, diffing算法就会对比出少量的变化进行局部修改。</p><p><code>src/index.js</code></p><pre><code class="js">// src/index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/client&#39;

/
import App from &#39;./12_hooks/15_App_hooks_useTransition&#39; // useTransition 


const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))

// 标签形式调用
root.render(
  &lt;App/&gt;
)
</code></pre><p><code>src/12_hooks/15_App_hooks_useTransition</code></p><pre><code class="jsx">import React, &#123; useTransition, useState, useMemo &#125; from &#39;react&#39;
 
export default function UseTransition() &#123;
  const [isPending, startTransition] = useTransition()
 
  const [rangeValue, setRangeValue] = useState(1)
  const [renderData, setRenderData] = useState([1])
  const [isStartTransition, setIsStartTransition] = useState(false)
  const handleChange = (e) =&gt; &#123;
    setRangeValue(e.target.value)
    const arr = []
    arr.length = e.target.value
    for (let i = 0; i &lt;= arr.length; i++) &#123;
      arr.fill(i, i + 1)
    &#125;
    if (isStartTransition) &#123;
      startTransition(() =&gt; &#123;
        setRenderData(arr)
      &#125;)
    &#125; else &#123;
      setRenderData(arr)
    &#125;
  &#125;
  const jsx = useMemo(() =&gt; &#123;
    return renderData.map((item, index) =&gt; &#123;
      return (
        &lt;div
          style=&#123;&#123;
            width: 50,
            height: 50,
            backgroundColor: `#$&#123;Math.floor(Math.random() * 16777215).toString(
              16
            )&#125;`,
            margin: 10,
            display: 'inline-block',
          &#125;&#125;
          key=&#123;&#39;item&#39;+index&#125;
        &gt;
          &#123;item&#125;
        &lt;/div&gt;
      )
    &#125;)
  &#125;, [renderData])
  return (
    &lt;div&gt;
      &lt;div style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt;
        &lt;label&gt;
          &lt;input
            type=&quot;checkbox&quot;
            checked=&#123;isStartTransition&#125;
            onChange=&#123;(e) =&gt; &#123;
              setIsStartTransition(e.target.checked)
            &#125;&#125;
          /&gt;
          useTransition
        &lt;/label&gt;
        &lt;input
          type=&quot;range&quot;
          value=&#123;rangeValue&#125;
          min=&#123;0&#125;
          max=&#123;10000&#125;
          style=&#123;&#123; width: 120 &#125;&#125;
          onChange=&#123;handleChange&#125;
        /&gt;
        &lt;span&gt;进度条 &#123;rangeValue&#125;&lt;/span&gt;
        &lt;hr /&gt;
      &lt;/div&gt;
      &#123;jsx&#125;
    &lt;/div&gt;
  )
&#125;
</code></pre><h3 id="17-2-14-useSyncExternalStore"><a href="#17-2-14-useSyncExternalStore" class="headerlink" title="17.2.14 useSyncExternalStore"></a>17.2.14 useSyncExternalStore</h3><p>React18的beta版本将<code>useMutableSource</code>更新为了<code>useSyncExternalStore</code>，这个新的api将会对React的各种状态管理库产生非常大的影响，下面我来介绍<code>useSyncExternalStore</code>的用法和场景。</p><p>我们可以通过这个api自行设计一个redux + react-redux的数据方案：</p><p><strong>1、设计store</strong></p><p>首先我们要设计一个store，它必须有如下属性：</p><ul><li>currentState:当前状态</li><li>subscribe:提供状态发生变化时的订阅能力</li><li>getSnapshot: 获取当前状态</li></ul><p>以及改变state的方法，这里参考redux，设计了dispatch、reducer</p><pre><code class="jsx">const store = &#123;
    currentState:&#123;data:0&#125;,
    listeners:[],
    reducer(action)&#123;
        switch(action.type) &#123;
            case &#39;ADD&#39;:
                return &#123;data:store.currentState.data+1&#125;
            default:
                return store.state
        &#125;
    &#125;,
    subscribe(l)&#123;
        store.listeners.push(l)
    &#125;,
    getSnapshot() &#123;
        return store.currentState
    &#125;,
    dispatch(action) &#123;
        store.currentState = store.reducer(action)
        store.listeners.forEach(l=&gt;l())
        return action;
    &#125;
&#125;
</code></pre><p><strong>2、应用 store 同步组件状态</strong></p><pre><code class="jsx">import React, &#123; useSyncExternalStore &#125; from &#39;react&#39;
import store from &#39;./store&#39;

export default function UseSyncExternalStoreDemo() &#123;
  const state = useSyncExternalStore(store.subscribe, () =&gt; store.getSnapshot().data);
    
    return (
      &lt;div&gt;
        &lt;div&gt;count: &#123;state&#125;&lt;/div&gt;
        &lt;div&gt;
            &lt;button onClick=&#123;()=&gt;store.dispatch(&#123;type:&#39;ADD&#39;&#125;)&#125;&gt;add+&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
&#125;
</code></pre><h3 id="17-2-15-useInsertionEffect"><a href="#17-2-15-useInsertionEffect" class="headerlink" title="17.2.15 useInsertionEffect"></a>17.2.15 useInsertionEffect</h3><p><code>useInsertionEffect</code> 与useEffect相同，在所有DOM变更之前同步触发。在使用 useLayoutEffect 读取布局之前，使用这个函数将样式注入到DOM中。因为这个钩子的作用域是有限的，所以这个钩子不能访问 refs，也不能调度更新。</p><pre><code class="jsx">import React, &#123; useInsertionEffect, useEffect, useLayoutEffect &#125; from &#39;react&#39;
 
export default function UseInsertionEffect() &#123;

  useInsertionEffect(() =&gt; &#123;
    console.log(&#39;useInsertionEffect&#39;) // 1
    // const style = document.createElement(&#39;style&#39;)
    // style.innerHTML = &#39;.box &#123; color: red &#125;&#39;
    // document.head.appendChild(style)
  &#125;)

  useEffect(() =&gt; &#123;
    console.log(&#39;useEffect&#39;) // 3
  &#125;)

  useLayoutEffect(() =&gt; &#123;
    console.log(&#39;useLayoutEffect&#39;) // 2
  &#125;)

  return (
    &lt;div className=&quot;box&quot;&gt;UseInsertionEffect&lt;/div&gt;
  )
&#125;
</code></pre><h2 id="17-3-自定义hooks"><a href="#17-3-自定义hooks" class="headerlink" title="17.3 自定义hooks"></a>17.3 自定义hooks</h2><p>以use开头的小驼峰式的函数</p><div class="tags"><a href="/tags/react/" rel="tag"><i class="ic i-tag"></i> react</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-31 10:21:22" itemprop="dateModified" datetime="2022-10-31T10:21:22+08:00">2022-10-31</time> </span><span id="react-study/7/" class="item leancloud_visitors" data-flag-title="React学习第七天" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 联系我</button><p>来交朋友吧！</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="叶星辰 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="叶星辰 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="叶星辰 QQ"><p>QQ</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>叶星辰 <i class="ic i-at"><em>@</em></i>永不陨落的星辰</li><li class="link"><strong>本文链接：</strong> <a href="https://www.yexingcheng.com/react-study/7/" title="React学习第七天">https://www.yexingcheng.com/react-study/7/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/react-study/6/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitzannuj20zk0m8b29.jpg" title="React学习第六天"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> react学习</span><h3>React学习第六天</h3></a></div><div class="item right"><a href="/react-study/8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicliwyw55j20zk0m8hdt.jpg" title="React学习第八天"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> react学习</span><h3>React学习第八天</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81hooks"><span class="toc-number">1.</span> <span class="toc-text">十七、hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8hooks"><span class="toc-number">1.1.</span> <span class="toc-text">17.1 为什么使用hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2%E5%B8%B8%E8%A7%81%E7%9A%84hooks"><span class="toc-number">1.2.</span> <span class="toc-text">17.2常见的hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-1-useState"><span class="toc-number">1.2.1.</span> <span class="toc-text">17.2.1 useState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-2-useEffect"><span class="toc-number">1.2.2.</span> <span class="toc-text">17.2.2 useEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-3-useRef"><span class="toc-number">1.2.3.</span> <span class="toc-text">17.2.3 useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-4-useReducer"><span class="toc-number">1.2.4.</span> <span class="toc-text">17.2.4 useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-5-useContext"><span class="toc-number">1.2.5.</span> <span class="toc-text">17.2.5 useContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-6-useMemo"><span class="toc-number">1.2.6.</span> <span class="toc-text">17.2.6 useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-7-useCallback"><span class="toc-number">1.2.7.</span> <span class="toc-text">17.2.7 useCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-8-useImperativeHandle"><span class="toc-number">1.2.8.</span> <span class="toc-text">17.2.8 useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-9-useLayoutEffect"><span class="toc-number">1.2.9.</span> <span class="toc-text">17.2.9 useLayoutEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-10-useDebugValue"><span class="toc-number">1.2.10.</span> <span class="toc-text">17.2.10 useDebugValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-11-useId"><span class="toc-number">1.2.11.</span> <span class="toc-text">17.2.11 useId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-12-useDeferredValue"><span class="toc-number">1.2.12.</span> <span class="toc-text">17.2.12 useDeferredValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-13-useTransition"><span class="toc-number">1.2.13.</span> <span class="toc-text">17.2.13 useTransition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-14-useSyncExternalStore"><span class="toc-number">1.2.14.</span> <span class="toc-text">17.2.14 useSyncExternalStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-15-useInsertionEffect"><span class="toc-number">1.2.15.</span> <span class="toc-text">17.2.15 useInsertionEffect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E8%87%AA%E5%AE%9A%E4%B9%89hooks"><span class="toc-number">1.3.</span> <span class="toc-text">17.3 自定义hooks</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/react-study/1/" rel="bookmark" title="React学习第一天">React学习第一天</a></li><li><a href="/react-study/2/" rel="bookmark" title="React学习第二天">React学习第二天</a></li><li><a href="/react-study/3/" rel="bookmark" title="React学习第三天">React学习第三天</a></li><li><a href="/react-study/4/" rel="bookmark" title="React学习第四天">React学习第四天</a></li><li><a href="/react-study/5/" rel="bookmark" title="React学习第五天">React学习第五天</a></li><li><a href="/react-study/6/" rel="bookmark" title="React学习第六天">React学习第六天</a></li><li class="active"><a href="/react-study/7/" rel="bookmark" title="React学习第七天">React学习第七天</a></li><li><a href="/react-study/8/" rel="bookmark" title="React学习第八天">React学习第八天</a></li><li><a href="/react-study/react-router-params/" rel="bookmark" title="React路由传参的几种方式">React路由传参的几种方式</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="叶星辰" data-src="/images/avatar.jpg"><p class="name" itemprop="name">叶星辰</p><div class="description" itemprop="description">温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhMW1EMHduMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Ca1mD0wn1"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9VZmRIbw==" title="https:&#x2F;&#x2F;twitter.com&#x2F;UfdHo"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tZW5nLXhpbmcteW91LWppLXNpLXl1ZS1odWFuZy0yNw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;meng-xing-you-ji-si-yue-huang-27"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTUwMjkxOTQ0NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;502919445"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NTc4MjU1ODg1" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7578255885"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="aHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvI2luYm94" title="https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;u&#x2F;0&#x2F;#inbox"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/react-study/6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/react-study/8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day3/" title="构建电商界面的小程序（一）">构建电商界面的小程序（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/2/" title="React学习第二天">React学习第二天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/11/" title="vue-mobile项目开发流程第十一部分(实现shopcar功能)">vue-mobile项目开发流程第十一部分(实现shopcar功能)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/10/" title="vue-mobile项目开发流程第十部分(构建joinshopcar页面)">vue-mobile项目开发流程第十部分(构建joinshopcar页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/react-router-params/" title="React路由传参的几种方式">React路由传参的几种方式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/3/" title="vue-mobile项目开发流程第三部分(TS与选项式API)">vue-mobile项目开发流程第三部分(TS与选项式API)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/5/" title="React学习第五天">React学习第五天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/1/" title="React学习第一天">React学习第一天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/8/" title="React学习第八天">React学习第八天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/1/" title="vue-mobile项目开发流程第一部分(项目搭建和技术栈选择)">vue-mobile项目开发流程第一部分(项目搭建和技术栈选择)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">叶星辰 @ 永不陨落的星辰</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">615k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"react-study/7/",favicon:{show:"星辰",hide:"你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/miku.model.json"},display:{position:"right",width:250,height:500},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by hrmmi -->