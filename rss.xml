<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>永不陨落的星辰</title>
        <subtitle></subtitle>
        <icon>https://www.yexingcheng.com/images/favicon.ico</icon>
        <link>https://www.yexingcheng.com</link>
        <author>
          <name>叶星辰</name>
        </author>
        <description>如因为网络原因,如果有文章加载不出来的情况，请访问(https://beize_admin.gitee.io)</description>
        <language>zh-CN</language>
        <pubDate>Wed, 30 Nov 2022 16:36:58 +0800</pubDate>
        <lastBuildDate>Wed, 30 Nov 2022 16:36:58 +0800</lastBuildDate>
        <category term="github vue typescript" />
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E9%87%91%E5%8D%B0%E5%AE%A2%E7%94%B5%E5%AD%90/</guid>
            <title>金印客电子面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E9%87%91%E5%8D%B0%E5%AE%A2%E7%94%B5%E5%AD%90/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Wed, 30 Nov 2022 16:36:58 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-上机做一个前台的详情页页面&#34;&gt;&lt;a href=&#34;#1-上机做一个前台的详情页页面&#34; class=&#34;headerlink&#34; title=&#34;1.上机做一个前台的详情页页面&#34;&gt;&lt;/a&gt;1.上机做一个前台的详情页页面&lt;/h2&gt;&lt;h2 id=&#34;2-介绍项目&#34;&gt;&lt;a href=&#34;#2-介绍项目&#34; class=&#34;headerlink&#34; title=&#34;2.介绍项目&#34;&gt;&lt;/a&gt;2.介绍项目&lt;/h2&gt;&lt;h2 id=&#34;3-对Vue3有哪些了解&#34;&gt;&lt;a href=&#34;#3-对Vue3有哪些了解&#34; class=&#34;headerlink&#34; title=&#34;3.对Vue3有哪些了解&#34;&gt;&lt;/a&gt;3.对Vue3有哪些了解&lt;/h2&gt;&lt;h2 id=&#34;4-layUI有没有用过&#34;&gt;&lt;a href=&#34;#4-layUI有没有用过&#34; class=&#34;headerlink&#34; title=&#34;4.layUI有没有用过&#34;&gt;&lt;/a&gt;4.layUI有没有用过&lt;/h2&gt;&lt;h2 id=&#34;5-单独负责一个网站或者APP能全权负责吗&#34;&gt;&lt;a href=&#34;#5-单独负责一个网站或者APP能全权负责吗&#34; class=&#34;headerlink&#34; title=&#34;5.单独负责一个网站或者APP能全权负责吗&#34;&gt;&lt;/a&gt;5.单独负责一个网站或者APP能全权负责吗&lt;/h2&gt;&lt;h2 id=&#34;6-跨域是什么，咋解决的&#34;&gt;&lt;a href=&#34;#6-跨域是什么，咋解决的&#34; class=&#34;headerlink&#34; title=&#34;6.跨域是什么，咋解决的&#34;&gt;&lt;/a&gt;6.跨域是什么，咋解决的&lt;/h2&gt;&lt;h2 id=&#34;7-jsonp和cors有啥区别&#34;&gt;&lt;a href=&#34;#7-jsonp和cors有啥区别&#34; class=&#34;headerlink&#34; title=&#34;7.jsonp和cors有啥区别&#34;&gt;&lt;/a&gt;7.jsonp和cors有啥区别&lt;/h2&gt;&lt;h2 id=&#34;8-nodeJS做过什么&#34;&gt;&lt;a href=&#34;#8-nodeJS做过什么&#34; class=&#34;headerlink&#34; title=&#34;8.nodeJS做过什么&#34;&gt;&lt;/a&gt;8.nodeJS做过什么&lt;/h2&gt;&lt;h2 id=&#34;9-文件资源压缩有没有了解&#34;&gt;&lt;a href=&#34;#9-文件资源压缩有没有了解&#34; class=&#34;headerlink&#34; title=&#34;9.文件资源压缩有没有了解&#34;&gt;&lt;/a&gt;9.文件资源压缩有没有了解&lt;/h2&gt;&lt;h2 id=&#34;10-小程序做过吗，用过uniapp没有&#34;&gt;&lt;a href=&#34;#10-小程序做过吗，用过uniapp没有&#34; class=&#34;headerlink&#34; title=&#34;10.小程序做过吗，用过uniapp没有&#34;&gt;&lt;/a&gt;10.小程序做过吗，用过uniapp没有&lt;/h2&gt;&lt;h2 id=&#34;11-你了解我们公司吗&#34;&gt;&lt;a href=&#34;#11-你了解我们公司吗&#34; class=&#34;headerlink&#34; title=&#34;11.你了解我们公司吗&#34;&gt;&lt;/a&gt;11.你了解我们公司吗&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E8%95%BE%E8%93%9D%E7%A7%91%E6%8A%80/</guid>
            <title>蕾蓝科技面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E8%95%BE%E8%93%9D%E7%A7%91%E6%8A%80/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Tue, 29 Nov 2022 16:45:01 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-自我介绍&#34;&gt;&lt;a href=&#34;#1-自我介绍&#34; class=&#34;headerlink&#34; title=&#34;1.自我介绍&#34;&gt;&lt;/a&gt;1.自我介绍&lt;/h2&gt;&lt;h2 id=&#34;2-介绍一个你的项目&#34;&gt;&lt;a href=&#34;#2-介绍一个你的项目&#34; class=&#34;headerlink&#34; title=&#34;2.介绍一个你的项目&#34;&gt;&lt;/a&gt;2.介绍一个你的项目&lt;/h2&gt;&lt;h2 id=&#34;3-原生JS中的闭包，闭包中的变量怎么销毁，怎么释放变量，使用闭包的场景&#34;&gt;&lt;a href=&#34;#3-原生JS中的闭包，闭包中的变量怎么销毁，怎么释放变量，使用闭包的场景&#34; class=&#34;headerlink&#34; title=&#34;3.原生JS中的闭包，闭包中的变量怎么销毁，怎么释放变量，使用闭包的场景&#34;&gt;&lt;/a&gt;3.原生JS中的闭包，闭包中的变量怎么销毁，怎么释放变量，使用闭包的场景&lt;/h2&gt;&lt;h2 id=&#34;4-有没有用原生js写项目&#34;&gt;&lt;a href=&#34;#4-有没有用原生js写项目&#34; class=&#34;headerlink&#34; title=&#34;4.有没有用原生js写项目&#34;&gt;&lt;/a&gt;4.有没有用原生js写项目&lt;/h2&gt;&lt;h2 id=&#34;5-作用域链是什么&#34;&gt;&lt;a href=&#34;#5-作用域链是什么&#34; class=&#34;headerlink&#34; title=&#34;5.作用域链是什么&#34;&gt;&lt;/a&gt;5.作用域链是什么&lt;/h2&gt;&lt;h2 id=&#34;6-es6增加哪些特性，箭头函数和普通函数有啥区别&#34;&gt;&lt;a href=&#34;#6-es6增加哪些特性，箭头函数和普通函数有啥区别&#34; class=&#34;headerlink&#34; title=&#34;6.es6增加哪些特性，箭头函数和普通函数有啥区别&#34;&gt;&lt;/a&gt;6.es6增加哪些特性，箭头函数和普通函数有啥区别&lt;/h2&gt;&lt;h2 id=&#34;7-call，apply-bind&#34;&gt;&lt;a href=&#34;#7-call，apply-bind&#34; class=&#34;headerlink&#34; title=&#34;7.call，apply,bind&#34;&gt;&lt;/a&gt;7.call，apply,bind&lt;/h2&gt;&lt;h2 id=&#34;8-async与await，await能不能单独使用&#34;&gt;&lt;a href=&#34;#8-async与await，await能不能单独使用&#34; class=&#34;headerlink&#34; title=&#34;8.async与await，await能不能单独使用&#34;&gt;&lt;/a&gt;8.async与await，await能不能单独使用&lt;/h2&gt;&lt;h2 id=&#34;9-promise用法&#34;&gt;&lt;a href=&#34;#9-promise用法&#34; class=&#34;headerlink&#34; title=&#34;9.promise用法&#34;&gt;&lt;/a&gt;9.promise用法&lt;/h2&gt;&lt;h2 id=&#34;10-Vue双向绑定原理&#34;&gt;&lt;a href=&#34;#10-Vue双向绑定原理&#34; class=&#34;headerlink&#34; title=&#34;10.Vue双向绑定原理&#34;&gt;&lt;/a&gt;10.Vue双向绑定原理&lt;/h2&gt;&lt;h2 id=&#34;11，vuex有几个特性&#34;&gt;&lt;a href=&#34;#11，vuex有几个特性&#34; class=&#34;headerlink&#34; title=&#34;11，vuex有几个特性&#34;&gt;&lt;/a&gt;11，vuex有几个特性&lt;/h2&gt;&lt;h2 id=&#34;12-keepalive怎么缓存的，存到哪里了&#34;&gt;&lt;a href=&#34;#12-keepalive怎么缓存的，存到哪里了&#34; class=&#34;headerlink&#34; title=&#34;12.keepalive怎么缓存的，存到哪里了&#34;&gt;&lt;/a&gt;12.keepalive怎么缓存的，存到哪里了&lt;/h2&gt;&lt;h2 id=&#34;13-组件通信了解吗&#34;&gt;&lt;a href=&#34;#13-组件通信了解吗&#34; class=&#34;headerlink&#34; title=&#34;13.组件通信了解吗&#34;&gt;&lt;/a&gt;13.组件通信了解吗&lt;/h2&gt;&lt;h2 id=&#34;14-Vue首页加载慢怎么解决&#34;&gt;&lt;a href=&#34;#14-Vue首页加载慢怎么解决&#34; class=&#34;headerlink&#34; title=&#34;14.Vue首页加载慢怎么解决&#34;&gt;&lt;/a&gt;14.Vue首页加载慢怎么解决&lt;/h2&gt;&lt;h2 id=&#34;15-前端SEO怎么理解的，有啥方法&#34;&gt;&lt;a href=&#34;#15-前端SEO怎么理解的，有啥方法&#34; class=&#34;headerlink&#34; title=&#34;15.前端SEO怎么理解的，有啥方法&#34;&gt;&lt;/a&gt;15.前端SEO怎么理解的，有啥方法&lt;/h2&gt;&lt;h2 id=&#34;16-fetch会用吗&#34;&gt;&lt;a href=&#34;#16-fetch会用吗&#34; class=&#34;headerlink&#34; title=&#34;16.fetch会用吗&#34;&gt;&lt;/a&gt;16.fetch会用吗&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E7%9B%92%E9%A9%AC%E7%A7%91%E6%8A%80/</guid>
            <title>盒马科技面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E7%9B%92%E9%A9%AC%E7%A7%91%E6%8A%80/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Tue, 29 Nov 2022 16:43:41 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-对递归的理解和注意事项&#34;&gt;&lt;a href=&#34;#1-对递归的理解和注意事项&#34; class=&#34;headerlink&#34; title=&#34;1.对递归的理解和注意事项&#34;&gt;&lt;/a&gt;1.对递归的理解和注意事项&lt;/h2&gt;&lt;h2 id=&#34;2-jsx怎么转成js的-如果createElement第一个参数传的是一个html传统标签-会怎么样-原生html标签和组件标签怎么分辨&#34;&gt;&lt;a href=&#34;#2-jsx怎么转成js的-如果createElement第一个参数传的是一个html传统标签-会怎么样-原生html标签和组件标签怎么分辨&#34; class=&#34;headerlink&#34; title=&#34;2.jsx怎么转成js的,如果createElement第一个参数传的是一个html传统标签,会怎么样.原生html标签和组件标签怎么分辨&#34;&gt;&lt;/a&gt;2.jsx怎么转成js的,如果createElement第一个参数传的是一个html传统标签,会怎么样.原生html标签和组件标签怎么分辨&lt;/h2&gt;&lt;h2 id=&#34;3-vuex如果要把state保存在本地-要在哪里写-如果有10个函数修改状态是要在每个函数里面都写上保存到本地的代码吗&#34;&gt;&lt;a href=&#34;#3-vuex如果要把state保存在本地-要在哪里写-如果有10个函数修改状态是要在每个函数里面都写上保存到本地的代码吗&#34; class=&#34;headerlink&#34; title=&#34;3.vuex如果要把state保存在本地,要在哪里写.如果有10个函数修改状态是要在每个函数里面都写上保存到本地的代码吗&#34;&gt;&lt;/a&gt;3.vuex如果要把state保存在本地,要在哪里写.如果有10个函数修改状态是要在每个函数里面都写上保存到本地的代码吗&lt;/h2&gt;&lt;h2 id=&#34;4-对diff算法的理解&#34;&gt;&lt;a href=&#34;#4-对diff算法的理解&#34; class=&#34;headerlink&#34; title=&#34;4.对diff算法的理解&#34;&gt;&lt;/a&gt;4.对diff算法的理解&lt;/h2&gt;&lt;h2 id=&#34;5-你开发项目中遇到的bug-为什么严格模式下函数组件会调用两次-流程是什么&#34;&gt;&lt;a href=&#34;#5-你开发项目中遇到的bug-为什么严格模式下函数组件会调用两次-流程是什么&#34; class=&#34;headerlink&#34; title=&#34;5.你开发项目中遇到的bug?为什么严格模式下函数组件会调用两次,流程是什么&#34;&gt;&lt;/a&gt;5.你开发项目中遇到的bug?为什么严格模式下函数组件会调用两次,流程是什么&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E8%AE%AF%E9%A3%9E%E7%A7%91%E6%8A%80/</guid>
            <title>讯飞科技面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E8%AE%AF%E9%A3%9E%E7%A7%91%E6%8A%80/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:55:19 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-css中你知道的选择器，以及他们的执行顺序&#34;&gt;&lt;a href=&#34;#1-css中你知道的选择器，以及他们的执行顺序&#34; class=&#34;headerlink&#34; title=&#34;1.css中你知道的选择器，以及他们的执行顺序&#34;&gt;&lt;/a&gt;1.css中你知道的选择器，以及他们的执行顺序&lt;/h2&gt;&lt;h2 id=&#34;2-css中的常用单位&#34;&gt;&lt;a href=&#34;#2-css中的常用单位&#34; class=&#34;headerlink&#34; title=&#34;2.css中的常用单位&#34;&gt;&lt;/a&gt;2.css中的常用单位&lt;/h2&gt;&lt;h2 id=&#34;3-active伪类用过吗-（伪类选择器）&#34;&gt;&lt;a href=&#34;#3-active伪类用过吗-（伪类选择器）&#34; class=&#34;headerlink&#34; title=&#34;3.:active伪类用过吗 （伪类选择器）&#34;&gt;&lt;/a&gt;3.:active伪类用过吗 （伪类选择器）&lt;/h2&gt;&lt;h2 id=&#34;4-es6新增特性&#34;&gt;&lt;a href=&#34;#4-es6新增特性&#34; class=&#34;headerlink&#34; title=&#34;4.es6新增特性&#34;&gt;&lt;/a&gt;4.es6新增特性&lt;/h2&gt;&lt;h2 id=&#34;5-循坏计时器设置十秒执行一次，把浏览器放到后台，会有什么影响（对执行时间有啥影响）&#34;&gt;&lt;a href=&#34;#5-循坏计时器设置十秒执行一次，把浏览器放到后台，会有什么影响（对执行时间有啥影响）&#34; class=&#34;headerlink&#34; title=&#34;5.循坏计时器设置十秒执行一次，把浏览器放到后台，会有什么影响（对执行时间有啥影响）&#34;&gt;&lt;/a&gt;5.循坏计时器设置十秒执行一次，把浏览器放到后台，会有什么影响（对执行时间有啥影响）&lt;/h2&gt;&lt;h2 id=&#34;6-cookie-、localstorage和sessionstorage的区别&#34;&gt;&lt;a href=&#34;#6-cookie-、localstorage和sessionstorage的区别&#34; class=&#34;headerlink&#34; title=&#34;6.cookie 、localstorage和sessionstorage的区别&#34;&gt;&lt;/a&gt;6.cookie 、localstorage和sessionstorage的区别&lt;/h2&gt;&lt;h2 id=&#34;7-两个div嵌套，都有一个点击事件，怎么阻止冒泡&#34;&gt;&lt;a href=&#34;#7-两个div嵌套，都有一个点击事件，怎么阻止冒泡&#34; class=&#34;headerlink&#34; title=&#34;7.两个div嵌套，都有一个点击事件，怎么阻止冒泡&#34;&gt;&lt;/a&gt;7.两个div嵌套，都有一个点击事件，怎么阻止冒泡&lt;/h2&gt;&lt;h2 id=&#34;8-跨域&#34;&gt;&lt;a href=&#34;#8-跨域&#34; class=&#34;headerlink&#34; title=&#34;8.跨域&#34;&gt;&lt;/a&gt;8.跨域&lt;/h2&gt;&lt;h2 id=&#34;9-你对-next-Tick的理解有哪些&#34;&gt;&lt;a href=&#34;#9-你对-next-Tick的理解有哪些&#34; class=&#34;headerlink&#34; title=&#34;9.你对$next Tick的理解有哪些&#34;&gt;&lt;/a&gt;9.你对$next Tick的理解有哪些&lt;/h2&gt;&lt;h2 id=&#34;10-vue2和vue3的原理&#34;&gt;&lt;a href=&#34;#10-vue2和vue3的原理&#34; class=&#34;headerlink&#34; title=&#34;10.vue2和vue3的原理&#34;&gt;&lt;/a&gt;10.vue2和vue3的原理&lt;/h2&gt;&lt;h2 id=&#34;11-对webSocket的理解&#34;&gt;&lt;a href=&#34;#11-对webSocket的理解&#34; class=&#34;headerlink&#34; title=&#34;11.对webSocket的理解&#34;&gt;&lt;/a&gt;11.对webSocket的理解&lt;/h2&gt;&lt;h2 id=&#34;12-在项目中封装过哪些函数&#34;&gt;&lt;a href=&#34;#12-在项目中封装过哪些函数&#34; class=&#34;headerlink&#34; title=&#34;12.在项目中封装过哪些函数&#34;&gt;&lt;/a&gt;12.在项目中封装过哪些函数&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E6%B5%99%E6%B1%9F%E4%BA%A4%E5%B7%A5/</guid>
            <title>浙江交工面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E6%B5%99%E6%B1%9F%E4%BA%A4%E5%B7%A5/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:54:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1、项目亮点&#34;&gt;&lt;a href=&#34;#1、项目亮点&#34; class=&#34;headerlink&#34; title=&#34;1、项目亮点&#34;&gt;&lt;/a&gt;1、项目亮点&lt;/h2&gt;&lt;h2 id=&#34;2、封装组件的业务场景（如果简历上写过封装组件的）&#34;&gt;&lt;a href=&#34;#2、封装组件的业务场景（如果简历上写过封装组件的）&#34; class=&#34;headerlink&#34; title=&#34;2、封装组件的业务场景（如果简历上写过封装组件的）&#34;&gt;&lt;/a&gt;2、封装组件的业务场景（如果简历上写过封装组件的）&lt;/h2&gt;&lt;h2 id=&#34;3、React的Axios封装&#34;&gt;&lt;a href=&#34;#3、React的Axios封装&#34; class=&#34;headerlink&#34; title=&#34;3、React的Axios封装&#34;&gt;&lt;/a&gt;3、React的Axios封装&lt;/h2&gt;&lt;h2 id=&#34;4、es6数组新增方法&#34;&gt;&lt;a href=&#34;#4、es6数组新增方法&#34; class=&#34;headerlink&#34; title=&#34;4、es6数组新增方法&#34;&gt;&lt;/a&gt;4、es6数组新增方法&lt;/h2&gt;&lt;h2 id=&#34;5、reduce数组去重&#34;&gt;&lt;a href=&#34;#5、reduce数组去重&#34; class=&#34;headerlink&#34; title=&#34;5、reduce数组去重&#34;&gt;&lt;/a&gt;5、reduce数组去重&lt;/h2&gt;&lt;h2 id=&#34;6、Promise-async-await&#34;&gt;&lt;a href=&#34;#6、Promise-async-await&#34; class=&#34;headerlink&#34; title=&#34;6、Promise ,async,await&#34;&gt;&lt;/a&gt;6、Promise ,async,await&lt;/h2&gt;&lt;h2 id=&#34;7、在react中，如何去获取地址栏？后面的参数（用自己封装好的pathname，已经去过重了），现在不希望去重&#34;&gt;&lt;a href=&#34;#7、在react中，如何去获取地址栏？后面的参数（用自己封装好的pathname，已经去过重了），现在不希望去重&#34; class=&#34;headerlink&#34; title=&#34;7、在react中，如何去获取地址栏？后面的参数（用自己封装好的pathname，已经去过重了），现在不希望去重&#34;&gt;&lt;/a&gt;7、在react中，如何去获取地址栏？后面的参数（用自己封装好的pathname，已经去过重了），现在不希望去重&lt;/h2&gt;&lt;h2 id=&#34;8、在react中，父组件如何调用子组件，forward结合useImperativehandle&#34;&gt;&lt;a href=&#34;#8、在react中，父组件如何调用子组件，forward结合useImperativehandle&#34; class=&#34;headerlink&#34; title=&#34;8、在react中，父组件如何调用子组件，forward结合useImperativehandle&#34;&gt;&lt;/a&gt;8、在react中，父组件如何调用子组件，forward结合useImperativehandle&lt;/h2&gt;&lt;h2 id=&#34;9、react如何捕获异常&#34;&gt;&lt;a href=&#34;#9、react如何捕获异常&#34; class=&#34;headerlink&#34; title=&#34;9、react如何捕获异常&#34;&gt;&lt;/a&gt;9、react如何捕获异常&lt;/h2&gt;&lt;h2 id=&#34;10、try-catch如何封装&#34;&gt;&lt;a href=&#34;#10、try-catch如何封装&#34; class=&#34;headerlink&#34; title=&#34;10、try ,catch如何封装&#34;&gt;&lt;/a&gt;10、try ,catch如何封装&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E8%A1%8C%E7%9F%A5%E7%BD%91%E7%BB%9C/</guid>
            <title>行知网络面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E8%A1%8C%E7%9F%A5%E7%BD%91%E7%BB%9C/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:54:02 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;行知网络-技术面&#34;&gt;&lt;a href=&#34;#行知网络-技术面&#34; class=&#34;headerlink&#34; title=&#34;行知网络-技术面&#34;&gt;&lt;/a&gt;行知网络-技术面&lt;/h1&gt;&lt;h2 id=&#34;1-react类组件和函数组件区别&#34;&gt;&lt;a href=&#34;#1-react类组件和函数组件区别&#34; class=&#34;headerlink&#34; title=&#34;1.react类组件和函数组件区别&#34;&gt;&lt;/a&gt;1.react类组件和函数组件区别&lt;/h2&gt;&lt;h2 id=&#34;2-react的Useeffect副作用如何清除&#34;&gt;&lt;a href=&#34;#2-react的Useeffect副作用如何清除&#34; class=&#34;headerlink&#34; title=&#34;2.react的Useeffect副作用如何清除&#34;&gt;&lt;/a&gt;2.react的Useeffect副作用如何清除&lt;/h2&gt;&lt;h2 id=&#34;3-React的Axios封装&#34;&gt;&lt;a href=&#34;#3-React的Axios封装&#34; class=&#34;headerlink&#34; title=&#34;3.React的Axios封装&#34;&gt;&lt;/a&gt;3.React的Axios封装&lt;/h2&gt;&lt;h2 id=&#34;4-Vue的自定义指令&#34;&gt;&lt;a href=&#34;#4-Vue的自定义指令&#34; class=&#34;headerlink&#34; title=&#34;4.Vue的自定义指令&#34;&gt;&lt;/a&gt;4.Vue的自定义指令&lt;/h2&gt;&lt;h2 id=&#34;5-Vuex五个参数&#34;&gt;&lt;a href=&#34;#5-Vuex五个参数&#34; class=&#34;headerlink&#34; title=&#34;5.Vuex五个参数&#34;&gt;&lt;/a&gt;5.Vuex五个参数&lt;/h2&gt;&lt;h2 id=&#34;6-说一下你react常用的生命周期&#34;&gt;&lt;a href=&#34;#6-说一下你react常用的生命周期&#34; class=&#34;headerlink&#34; title=&#34;6.说一下你react常用的生命周期&#34;&gt;&lt;/a&gt;6.说一下你react常用的生命周期&lt;/h2&gt;&lt;h2 id=&#34;7-谈一下你对ts的理解&#34;&gt;&lt;a href=&#34;#7-谈一下你对ts的理解&#34; class=&#34;headerlink&#34; title=&#34;7.谈一下你对ts的理解&#34;&gt;&lt;/a&gt;7.谈一下你对ts的理解&lt;/h2&gt;&lt;h2 id=&#34;8-ts定义一个对象类型，怎们去定义&#34;&gt;&lt;a href=&#34;#8-ts定义一个对象类型，怎们去定义&#34; class=&#34;headerlink&#34; title=&#34;8.ts定义一个对象类型，怎们去定义&#34;&gt;&lt;/a&gt;8.ts定义一个对象类型，怎们去定义&lt;/h2&gt;&lt;h2 id=&#34;9-对uiapp的理解&#34;&gt;&lt;a href=&#34;#9-对uiapp的理解&#34; class=&#34;headerlink&#34; title=&#34;9.对uiapp的理解&#34;&gt;&lt;/a&gt;9.对uiapp的理解&lt;/h2&gt;&lt;h2 id=&#34;10-umi的理解&#34;&gt;&lt;a href=&#34;#10-umi的理解&#34; class=&#34;headerlink&#34; title=&#34;10.umi的理解&#34;&gt;&lt;/a&gt;10.umi的理解&lt;/h2&gt;&lt;h1 id=&#34;行知网络-经理面&#34;&gt;&lt;a href=&#34;#行知网络-经理面&#34; class=&#34;headerlink&#34; title=&#34;行知网络 - 经理面&#34;&gt;&lt;/a&gt;行知网络 - 经理面&lt;/h1&gt;&lt;h2 id=&#34;1-怎样和后端对接口&#34;&gt;&lt;a href=&#34;#1-怎样和后端对接口&#34; class=&#34;headerlink&#34; title=&#34;1.怎样和后端对接口&#34;&gt;&lt;/a&gt;1.怎样和后端对接口&lt;/h2&gt;&lt;h2 id=&#34;2-怎样和ui对原型&#34;&gt;&lt;a href=&#34;#2-怎样和ui对原型&#34; class=&#34;headerlink&#34; title=&#34;2.怎样和ui对原型&#34;&gt;&lt;/a&gt;2.怎样和ui对原型&lt;/h2&gt;&lt;h2 id=&#34;3-你项目中遇到的难点&#34;&gt;&lt;a href=&#34;#3-你项目中遇到的难点&#34; class=&#34;headerlink&#34; title=&#34;3.你项目中遇到的难点&#34;&gt;&lt;/a&gt;3.你项目中遇到的难点&lt;/h2&gt;&lt;h2 id=&#34;4-你对每一个项目主要负责的功能和收获&#34;&gt;&lt;a href=&#34;#4-你对每一个项目主要负责的功能和收获&#34; class=&#34;headerlink&#34; title=&#34;4.你对每一个项目主要负责的功能和收获&#34;&gt;&lt;/a&gt;4.你对每一个项目主要负责的功能和收获&lt;/h2&gt;&lt;h2 id=&#34;5-遇到问题，你一般怎么解决&#34;&gt;&lt;a href=&#34;#5-遇到问题，你一般怎么解决&#34; class=&#34;headerlink&#34; title=&#34;5.遇到问题，你一般怎么解决&#34;&gt;&lt;/a&gt;5.遇到问题，你一般怎么解决&lt;/h2&gt;&lt;h2 id=&#34;6-你在流媒体项目中遇到的难点，以图片和视频为例去讲&#34;&gt;&lt;a href=&#34;#6-你在流媒体项目中遇到的难点，以图片和视频为例去讲&#34; class=&#34;headerlink&#34; title=&#34;6.你在流媒体项目中遇到的难点，以图片和视频为例去讲&#34;&gt;&lt;/a&gt;6.你在流媒体项目中遇到的难点，以图片和视频为例去讲&lt;/h2&gt;&lt;h2 id=&#34;7-后端定义的接口，有什么规范&#34;&gt;&lt;a href=&#34;#7-后端定义的接口，有什么规范&#34; class=&#34;headerlink&#34; title=&#34;7.后端定义的接口，有什么规范&#34;&gt;&lt;/a&gt;7.后端定义的接口，有什么规范&lt;/h2&gt;&lt;h2 id=&#34;8-你对加班怎们看&#34;&gt;&lt;a href=&#34;#8-你对加班怎们看&#34; class=&#34;headerlink&#34; title=&#34;8.你对加班怎们看&#34;&gt;&lt;/a&gt;8.你对加班怎们看&lt;/h2&gt;&lt;h2 id=&#34;9-谈一下你印象最深的项目，为什么&#34;&gt;&lt;a href=&#34;#9-谈一下你印象最深的项目，为什么&#34; class=&#34;headerlink&#34; title=&#34;9.谈一下你印象最深的项目，为什么&#34;&gt;&lt;/a&gt;9.谈一下你印象最深的项目，为什么&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E4%B8%AD%E7%A7%91%E4%BC%98%E8%AE%AF/</guid>
            <title>中科优讯面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E4%B8%AD%E7%A7%91%E4%BC%98%E8%AE%AF/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:52:11 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-自我介绍&#34;&gt;&lt;a href=&#34;#1-自我介绍&#34; class=&#34;headerlink&#34; title=&#34;1.自我介绍&#34;&gt;&lt;/a&gt;1.自我介绍&lt;/h2&gt;&lt;h2 id=&#34;2-cookie-localstorage和sessionstorage&#34;&gt;&lt;a href=&#34;#2-cookie-localstorage和sessionstorage&#34; class=&#34;headerlink&#34; title=&#34;2.cookie localstorage和sessionstorage&#34;&gt;&lt;/a&gt;2.cookie localstorage和sessionstorage&lt;/h2&gt;&lt;h2 id=&#34;3-跨域请求&#34;&gt;&lt;a href=&#34;#3-跨域请求&#34; class=&#34;headerlink&#34; title=&#34;3.跨域请求&#34;&gt;&lt;/a&gt;3.跨域请求&lt;/h2&gt;&lt;h2 id=&#34;4-js原型链的理解&#34;&gt;&lt;a href=&#34;#4-js原型链的理解&#34; class=&#34;headerlink&#34; title=&#34;4.js原型链的理解&#34;&gt;&lt;/a&gt;4.js原型链的理解&lt;/h2&gt;&lt;h2 id=&#34;5-盒模型&#34;&gt;&lt;a href=&#34;#5-盒模型&#34; class=&#34;headerlink&#34; title=&#34;5.盒模型&#34;&gt;&lt;/a&gt;5.盒模型&lt;/h2&gt;&lt;h2 id=&#34;6-Es6新增&#34;&gt;&lt;a href=&#34;#6-Es6新增&#34; class=&#34;headerlink&#34; title=&#34;6.Es6新增&#34;&gt;&lt;/a&gt;6.Es6新增&lt;/h2&gt;&lt;h2 id=&#34;7-怎么实现居中&#34;&gt;&lt;a href=&#34;#7-怎么实现居中&#34; class=&#34;headerlink&#34; title=&#34;7.怎么实现居中&#34;&gt;&lt;/a&gt;7.怎么实现居中&lt;/h2&gt;&lt;h2 id=&#34;8-在项目登录怎么做的&#34;&gt;&lt;a href=&#34;#8-在项目登录怎么做的&#34; class=&#34;headerlink&#34; title=&#34;8.在项目登录怎么做的&#34;&gt;&lt;/a&gt;8.在项目登录怎么做的&lt;/h2&gt;&lt;h2 id=&#34;9-在项目中登录白名单怎么实现&#34;&gt;&lt;a href=&#34;#9-在项目中登录白名单怎么实现&#34; class=&#34;headerlink&#34; title=&#34;9.在项目中登录白名单怎么实现&#34;&gt;&lt;/a&gt;9.在项目中登录白名单怎么实现&lt;/h2&gt;&lt;h2 id=&#34;10-订单中不同的操作怎么实现分类弹窗&#34;&gt;&lt;a href=&#34;#10-订单中不同的操作怎么实现分类弹窗&#34; class=&#34;headerlink&#34; title=&#34;10.订单中不同的操作怎么实现分类弹窗&#34;&gt;&lt;/a&gt;10.订单中不同的操作怎么实现分类弹窗&lt;/h2&gt;&lt;h2 id=&#34;11-Vue中Vuex的使用&#34;&gt;&lt;a href=&#34;#11-Vue中Vuex的使用&#34; class=&#34;headerlink&#34; title=&#34;11.Vue中Vuex的使用&#34;&gt;&lt;/a&gt;11.Vue中Vuex的使用&lt;/h2&gt;&lt;h2 id=&#34;12-Vue中的传值&#34;&gt;&lt;a href=&#34;#12-Vue中的传值&#34; class=&#34;headerlink&#34; title=&#34;12.Vue中的传值&#34;&gt;&lt;/a&gt;12.Vue中的传值&lt;/h2&gt;&lt;h2 id=&#34;13-怎么获取路由的传值&#34;&gt;&lt;a href=&#34;#13-怎么获取路由的传值&#34; class=&#34;headerlink&#34; title=&#34;13.怎么获取路由的传值&#34;&gt;&lt;/a&gt;13.怎么获取路由的传值&lt;/h2&gt;&lt;h2 id=&#34;14-MVVM的理解&#34;&gt;&lt;a href=&#34;#14-MVVM的理解&#34; class=&#34;headerlink&#34; title=&#34;14.MVVM的理解&#34;&gt;&lt;/a&gt;14.MVVM的理解&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E6%88%90%E9%BA%A6%E7%A7%91%E6%8A%80/</guid>
            <title>成麦科技面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E6%88%90%E9%BA%A6%E7%A7%91%E6%8A%80/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:51:20 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-react和vue的区别，尽可能多的说。&#34;&gt;&lt;a href=&#34;#1-react和vue的区别，尽可能多的说。&#34; class=&#34;headerlink&#34; title=&#34;1.react和vue的区别，尽可能多的说。&#34;&gt;&lt;/a&gt;1.react和vue的区别，尽可能多的说。&lt;/h2&gt;&lt;h3 id=&#34;框架简介：&#34;&gt;&lt;a href=&#34;#框架简介：&#34; class=&#34;headerlink&#34; title=&#34;框架简介：&#34;&gt;&lt;/a&gt;框架简介：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;React主张是函数式编程的理念， 实现了前端界面的高性能高效率开发，react很擅长处理组件化的页面。React的官方网站提到了“学习一次，随处写作”这个关键功能，可以使用React框架在JavaScript中构建移动应用程序。在 React 中，所有的组件的渲染功能都依靠 JSX，它是JavaScript的语法扩展，它在创建UI组件和调试时非常简单有用。&lt;/p&gt;
&lt;p&gt;Vue是渐进式JavaScript框架。“渐进式框架”和“自底向上增量开发的设计”是Vue开发的两个概念。Vue可以在任意其他类型的项目中使用，使用成本较低，更灵活，主张较弱，在Vue的项目中也可以轻松融汇其他的技术来开发。特点：易用（使用成本低），灵活（生态系统完善，适用于任何规模的项目），高效（体积小，优化好，性能好）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;框架共同点：&#34;&gt;&lt;a href=&#34;#框架共同点：&#34; class=&#34;headerlink&#34; title=&#34;框架共同点：&#34;&gt;&lt;/a&gt;框架共同点：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;①都使用虚拟dom。&lt;br&gt;②提供了响应式和组件化的视图组件。&lt;br&gt;③把注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。(vue-router、vuex、react-router、redux等等)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;各自的优势：&#34;&gt;&lt;a href=&#34;#各自的优势：&#34; class=&#34;headerlink&#34; title=&#34;各自的优势：&#34;&gt;&lt;/a&gt;各自的优势：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;React&lt;/p&gt;
&lt;p&gt;①灵活性和响应性：它提供最大的灵活性和响应能力。&lt;br&gt;②丰富的JavaScript库：来自世界各地的贡献者正在努力添加更多功能。&lt;br&gt;③可扩展性：由于其灵活的结构和可扩展性，React已被证明对大型应用程序更好。&lt;br&gt;④不断发展： React得到了Facebook专业开发人员的支持，他们不断寻找改进方法。&lt;br&gt;⑤web或移动平台： React提供React Native平台，可通过相同的React组件模型为iOS和Android开发本机呈现的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue&lt;/p&gt;
&lt;p&gt;①易于使用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。&lt;br&gt;②更顺畅的集成：无论是单页应用程序还是复杂的Web界面，Vue.js都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。&lt;br&gt;③更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。&lt;br&gt;④精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML和JavaScript将完成工作。&lt;br&gt;⑤适应性：整体声音设计和架构使其成为一种流行的JavaScript框架。它提供无障碍的迁移，简单有效的结构和可重用的模板。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;两者的区别：&#34;&gt;&lt;a href=&#34;#两者的区别：&#34; class=&#34;headerlink&#34; title=&#34;两者的区别：&#34;&gt;&lt;/a&gt;两者的区别：&lt;/h3&gt;&lt;h4 id=&#34;1、数据是否可变：&#34;&gt;&lt;a href=&#34;#1、数据是否可变：&#34; class=&#34;headerlink&#34; title=&#34;1、数据是否可变：&#34;&gt;&lt;/a&gt;1、数据是否可变：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;React：整体是函数式的思想，在react中，是单向数据流，推崇结合immutable来实现数据不可变。&lt;br&gt;Vue：的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2、编译-amp-写法&#34;&gt;&lt;a href=&#34;#2、编译-amp-写法&#34; class=&#34;headerlink&#34; title=&#34;2、编译&amp;amp;写法&#34;&gt;&lt;/a&gt;2、编译&amp;amp;写法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;React：思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等。&lt;br&gt;Vue：把html，css，js组合到一起，用各自的处理方式，Vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;3、重新渲染和优化&#34;&gt;&lt;a href=&#34;#3、重新渲染和优化&#34; class=&#34;headerlink&#34; title=&#34;3、重新渲染和优化&#34;&gt;&lt;/a&gt;3、重新渲染和优化&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;当你比较React和Vue时，速度不能成为决定哪个更好的重要比较因素。在性能方面，让我们考虑重新渲染功能。当组件的状态发生变化时，React的机制会触发整个组件树的重新呈现。您可能需要使用额外的属性来避免不必要地重新渲染子组件。虽然Vue的重新渲染功能是开箱即用的，但Vue提供了优化的重新渲染，其中系统在渲染过程中跟踪依赖关系并相应地工作。重新渲染是Vue最显着的特征，也使其成为全世界开发人员广泛接受的框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;4、类式的组件写法，还是声明式的写法&#34;&gt;&lt;a href=&#34;#4、类式的组件写法，还是声明式的写法&#34; class=&#34;headerlink&#34; title=&#34;4、类式的组件写法，还是声明式的写法&#34;&gt;&lt;/a&gt;4、类式的组件写法，还是声明式的写法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;react是类式的写法，api很少，而Vue是声明式的写法，通过传入各种options，api和参数都很多。所以react结合typescript更容易一起写，Vue稍微复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;5、路由和状态管理解决方案&#34;&gt;&lt;a href=&#34;#5、路由和状态管理解决方案&#34; class=&#34;headerlink&#34; title=&#34;5、路由和状态管理解决方案&#34;&gt;&lt;/a&gt;5、路由和状态管理解决方案&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在像React和Vue这样的基于组件的框架中，当您开始扩展应用程序时，需要更加关注状态管理和数据流。这是因为有许多组件相互交互并共享数据。在这种情况下，React提供了一种称为Flux &amp;#x2F; Redux架构的创新解决方案，它代表单向数据流，是著名MVC架构的替代方案。现在，如果我们考虑Vue.js框架，就会有一个名为Vuex的更高级架构，它集成到Vue中并提供无与伦比的体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;6、构建工具&#34;&gt;&lt;a href=&#34;#6、构建工具&#34; class=&#34;headerlink&#34; title=&#34;6、构建工具&#34;&gt;&lt;/a&gt;6、构建工具&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;React和Vue都有一个非常好的开发环境。只需很少或没有配置，就可以创建应用程序，能够使用最新的实践和模板。在React中，有一个Create React App（CRA），在Vue中，它是vue-cli。这两种引导工具都倾向于提供舒适灵活的开发环境，并提供开始编码的出色起点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-html常用标签&#34;&gt;&lt;a href=&#34;#2-html常用标签&#34; class=&#34;headerlink&#34; title=&#34;2.html常用标签&#34;&gt;&lt;/a&gt;2.html常用标签&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;a,p,div,span,img,header,main,footer,ul,i,li,ol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-parseInt的理解&#34;&gt;&lt;a href=&#34;#3-parseInt的理解&#34; class=&#34;headerlink&#34; title=&#34;3.parseInt的理解&#34;&gt;&lt;/a&gt;3.parseInt的理解&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;parseInt(*string*, *radix*)&lt;/strong&gt; 解析一个字符串并返回指定基数的十进制整数，&lt;code&gt;radix&lt;/code&gt; 是 2-36 之间的整数，表示被解析字符串的基数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;parseInt(string, radix);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参数&#34;&gt;&lt;a href=&#34;#参数&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要被解析的值。如果参数不是一个字符串，则将其转换为字符串 (使用 &lt;a href=&#34;https://www.ecma-international.org/ecma-262/6.0/#sec-tostring&#34;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;抽象操作)。字符串开头的空白符将会被忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;radix&lt;/code&gt;_ 可选_&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;2&lt;/code&gt; 到 &lt;code&gt;36&lt;/code&gt; 的整数，表示进制的基数。例如指定 &lt;code&gt;16&lt;/code&gt; 表示被解析值是十六进制数。如果超出这个范围，将返回 &lt;code&gt;NaN&lt;/code&gt;。假如指定 &lt;code&gt;0&lt;/code&gt; 或未指定，基数将会根据字符串的值进行推算。注意，推算的结果不会永远是默认值 &lt;code&gt;10&lt;/code&gt;！文章后面的描述解释了当参数 &lt;code&gt;radix&lt;/code&gt; 不传时该函数的具体行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;返回值&#34;&gt;&lt;a href=&#34;#返回值&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h3&gt;&lt;p&gt;从给定的字符串中解析出的一个整数。&lt;/p&gt;
&lt;p&gt;或者 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN&#34;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;，当&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;radix&lt;/code&gt; 小于 &lt;code&gt;2&lt;/code&gt; 或大于 &lt;code&gt;36&lt;/code&gt;，或&lt;/li&gt;
&lt;li&gt;第一个非空格字符不能转换为数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-数组循环，常用的方法&#34;&gt;&lt;a href=&#34;#4-数组循环，常用的方法&#34; class=&#34;headerlink&#34; title=&#34;4.数组循环，常用的方法&#34;&gt;&lt;/a&gt;4.数组循环，常用的方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;for in&lt;/p&gt;
&lt;p&gt;for of&lt;/p&gt;
&lt;p&gt;forEach()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-map循环三个参数，map循环返回的值是新值还是旧值，map的实际场景&#34;&gt;&lt;a href=&#34;#5-map循环三个参数，map循环返回的值是新值还是旧值，map的实际场景&#34; class=&#34;headerlink&#34; title=&#34;5.map循环三个参数，map循环返回的值是新值还是旧值，map的实际场景&#34;&gt;&lt;/a&gt;5.map循环三个参数，map循环返回的值是新值还是旧值，map的实际场景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/strong&gt; 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。&lt;/p&gt;
&lt;h3 id=&#34;参数-1&#34;&gt;&lt;a href=&#34;#参数-1&#34; class=&#34;headerlink&#34; title=&#34;参数&#34;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;callbackFn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 生成新数组元素的函数，使用三个参数：&lt;code&gt;currentValue``callbackFn&lt;/code&gt; 数组中正在处理的当前元素。&lt;code&gt;index``callbackFn&lt;/code&gt; 数组中正在处理的当前元素的索引。&lt;code&gt;array``map&lt;/code&gt; 方法调用的数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thisArg&lt;/code&gt; 可选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 执行 &lt;code&gt;callbackFn&lt;/code&gt; 函数时被用作 &lt;code&gt;this&lt;/code&gt; 的值。&lt;/p&gt;
&lt;h3 id=&#34;返回值-1&#34;&gt;&lt;a href=&#34;#返回值-1&#34; class=&#34;headerlink&#34; title=&#34;返回值&#34;&gt;&lt;/a&gt;返回值&lt;/h3&gt;&lt;p&gt;一个新数组，每个元素都是回调函数的返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-react的生命周期&#34;&gt;&lt;a href=&#34;#6-react的生命周期&#34; class=&#34;headerlink&#34; title=&#34;6.react的生命周期&#34;&gt;&lt;/a&gt;6.react的生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&#34;挂载&#34;&gt;&lt;a href=&#34;#挂载&#34; class=&#34;headerlink&#34; title=&#34;挂载&#34;&gt;&lt;/a&gt;挂载&lt;/h2&gt;&lt;p&gt;当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constructor()&lt;/code&gt;: 在 React 组件挂载之前，会调用它的构造函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getDerivedStateFromProps()&lt;/code&gt;: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render()&lt;/code&gt;: render() 方法是 class 组件中唯一必须实现的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;: 在组件挂载后（插入 DOM 树中）立即调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;&lt;a href=&#34;#更新&#34; class=&#34;headerlink&#34; title=&#34;更新&#34;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;p&gt;每当组件的 state 或 props 发生变化时，组件就会更新。&lt;/p&gt;
&lt;p&gt;当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getDerivedStateFromProps()&lt;/code&gt;: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;:当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render()&lt;/code&gt;: render() 方法是 class 组件中唯一必须实现的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt;: 在最近一次渲染输出（提交到 DOM 节点）之前调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;: 在更新后会被立即调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。&lt;/p&gt;
&lt;h2 id=&#34;卸载&#34;&gt;&lt;a href=&#34;#卸载&#34; class=&#34;headerlink&#34; title=&#34;卸载&#34;&gt;&lt;/a&gt;卸载&lt;/h2&gt;&lt;p&gt;当组件从 DOM 中移除时会调用如下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;: 在组件卸载及销毁之前直接调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-react的性能优化怎么做&#34;&gt;&lt;a href=&#34;#7-react的性能优化怎么做&#34; class=&#34;headerlink&#34; title=&#34;7.react的性能优化怎么做&#34;&gt;&lt;/a&gt;7.react的性能优化怎么做&lt;/h2&gt;&lt;h2 id=&#34;8-react的组件传值&#34;&gt;&lt;a href=&#34;#8-react的组件传值&#34; class=&#34;headerlink&#34; title=&#34;8.react的组件传值&#34;&gt;&lt;/a&gt;8.react的组件传值&lt;/h2&gt;&lt;h2 id=&#34;9-setState是异步还是同步的，怎样获取同步数据&#34;&gt;&lt;a href=&#34;#9-setState是异步还是同步的，怎样获取同步数据&#34; class=&#34;headerlink&#34; title=&#34;9.setState是异步还是同步的，怎样获取同步数据&#34;&gt;&lt;/a&gt;9.setState是异步还是同步的，怎样获取同步数据&lt;/h2&gt;&lt;h2 id=&#34;10-谈一下你对redux的理解&#34;&gt;&lt;a href=&#34;#10-谈一下你对redux的理解&#34; class=&#34;headerlink&#34; title=&#34;10.谈一下你对redux的理解&#34;&gt;&lt;/a&gt;10.谈一下你对redux的理解&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E7%A5%9E%E8%88%9F%E6%95%B0%E7%A0%81/</guid>
            <title>神舟数码面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E7%A5%9E%E8%88%9F%E6%95%B0%E7%A0%81/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:50:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-说说你对vuex的理解，mutations和actions有什么区别，你的项目中有哪些数据保存在vuex当中&#34;&gt;&lt;a href=&#34;#1-说说你对vuex的理解，mutations和actions有什么区别，你的项目中有哪些数据保存在vuex当中&#34; class=&#34;headerlink&#34; title=&#34;1.说说你对vuex的理解，mutations和actions有什么区别，你的项目中有哪些数据保存在vuex当中?&#34;&gt;&lt;/a&gt;1.说说你对vuex的理解，mutations和actions有什么区别，你的项目中有哪些数据保存在vuex当中?&lt;/h2&gt;&lt;h2 id=&#34;2-vue项目首页加载做过哪些优化？&#34;&gt;&lt;a href=&#34;#2-vue项目首页加载做过哪些优化？&#34; class=&#34;headerlink&#34; title=&#34;2.vue项目首页加载做过哪些优化？&#34;&gt;&lt;/a&gt;2.vue项目首页加载做过哪些优化？&lt;/h2&gt;&lt;h2 id=&#34;3-vue页面组件的样式写scoped可以区分全局样式和组件内的样式，那scoped的实现原理是什么？&#34;&gt;&lt;a href=&#34;#3-vue页面组件的样式写scoped可以区分全局样式和组件内的样式，那scoped的实现原理是什么？&#34; class=&#34;headerlink&#34; title=&#34;3.vue页面组件的样式写scoped可以区分全局样式和组件内的样式，那scoped的实现原理是什么？&#34;&gt;&lt;/a&gt;3.vue页面组件的样式写scoped可以区分全局样式和组件内的样式，那scoped的实现原理是什么？&lt;/h2&gt;&lt;h2 id=&#34;4-说说Vue-use-的理解？&#34;&gt;&lt;a href=&#34;#4-说说Vue-use-的理解？&#34; class=&#34;headerlink&#34; title=&#34;4.说说Vue.use()的理解？&#34;&gt;&lt;/a&gt;4.说说Vue.use()的理解？&lt;/h2&gt;&lt;h2 id=&#34;5-有没有封装过组件，有没有将封装的组件发布到npm或者别的平台的？&#34;&gt;&lt;a href=&#34;#5-有没有封装过组件，有没有将封装的组件发布到npm或者别的平台的？&#34; class=&#34;headerlink&#34; title=&#34;5.有没有封装过组件，有没有将封装的组件发布到npm或者别的平台的？&#34;&gt;&lt;/a&gt;5.有没有封装过组件，有没有将封装的组件发布到npm或者别的平台的？&lt;/h2&gt;&lt;h2 id=&#34;6-es6中箭头函数和普通函数有什么区别，为什么箭头函数没有this？&#34;&gt;&lt;a href=&#34;#6-es6中箭头函数和普通函数有什么区别，为什么箭头函数没有this？&#34; class=&#34;headerlink&#34; title=&#34;6.es6中箭头函数和普通函数有什么区别，为什么箭头函数没有this？&#34;&gt;&lt;/a&gt;6.es6中箭头函数和普通函数有什么区别，为什么箭头函数没有this？&lt;/h2&gt;&lt;h2 id=&#34;7-es6中forEach-map-for-of-for-in-四种循环的区别是什么，哪些业务中使用过map循环，平常用map多还是forEach多？&#34;&gt;&lt;a href=&#34;#7-es6中forEach-map-for-of-for-in-四种循环的区别是什么，哪些业务中使用过map循环，平常用map多还是forEach多？&#34; class=&#34;headerlink&#34; title=&#34;7.es6中forEach, map, for of , for in 四种循环的区别是什么，哪些业务中使用过map循环，平常用map多还是forEach多？&#34;&gt;&lt;/a&gt;7.es6中forEach, map, for of , for in 四种循环的区别是什么，哪些业务中使用过map循环，平常用map多还是forEach多？&lt;/h2&gt;&lt;h2 id=&#34;8-如果要去华东跟随项目出差能接受吗…&#34;&gt;&lt;a href=&#34;#8-如果要去华东跟随项目出差能接受吗…&#34; class=&#34;headerlink&#34; title=&#34;8.如果要去华东跟随项目出差能接受吗…&#34;&gt;&lt;/a&gt;8.如果要去华东跟随项目出差能接受吗…&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/interview-questions/%E5%8F%8C%E7%BE%BD%E4%B9%9D%E5%B7%9E/</guid>
            <title>双羽九州面试题</title>
            <link>https://www.yexingcheng.com/interview-questions/%E5%8F%8C%E7%BE%BD%E4%B9%9D%E5%B7%9E/</link>
            <category term="面试题总结" scheme="https://www.yexingcheng.com/categories/interview-questions/" />
            <category term="interview" scheme="https://www.yexingcheng.com/tags/interview/" />
            <pubDate>Mon, 28 Nov 2022 09:49:01 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1-说一下你知道的数据结构和算法&#34;&gt;&lt;a href=&#34;#1-说一下你知道的数据结构和算法&#34; class=&#34;headerlink&#34; title=&#34;1.说一下你知道的数据结构和算法&#34;&gt;&lt;/a&gt;1.说一下你知道的数据结构和算法&lt;/h2&gt;&lt;h2 id=&#34;2-冒泡排序的时间复杂度&#34;&gt;&lt;a href=&#34;#2-冒泡排序的时间复杂度&#34; class=&#34;headerlink&#34; title=&#34;2.冒泡排序的时间复杂度&#34;&gt;&lt;/a&gt;2.冒泡排序的时间复杂度&lt;/h2&gt;&lt;h2 id=&#34;3-margin的值为负值会发生什么&#34;&gt;&lt;a href=&#34;#3-margin的值为负值会发生什么&#34; class=&#34;headerlink&#34; title=&#34;3.margin的值为负值会发生什么&#34;&gt;&lt;/a&gt;3.margin的值为负值会发生什么&lt;/h2&gt;&lt;h2 id=&#34;4-BFC&#34;&gt;&lt;a href=&#34;#4-BFC&#34; class=&#34;headerlink&#34; title=&#34;4.BFC&#34;&gt;&lt;/a&gt;4.BFC&lt;/h2&gt;&lt;h2 id=&#34;5-vue路由传参的方式，以及弊端&#34;&gt;&lt;a href=&#34;#5-vue路由传参的方式，以及弊端&#34; class=&#34;headerlink&#34; title=&#34;5.vue路由传参的方式，以及弊端&#34;&gt;&lt;/a&gt;5.vue路由传参的方式，以及弊端&lt;/h2&gt;&lt;h2 id=&#34;6-vue传值&#34;&gt;&lt;a href=&#34;#6-vue传值&#34; class=&#34;headerlink&#34; title=&#34;6.vue传值&#34;&gt;&lt;/a&gt;6.vue传值&lt;/h2&gt;&lt;h2 id=&#34;7-嵌套路由&#34;&gt;&lt;a href=&#34;#7-嵌套路由&#34; class=&#34;headerlink&#34; title=&#34;7.嵌套路由&#34;&gt;&lt;/a&gt;7.嵌套路由&lt;/h2&gt;&lt;h2 id=&#34;8-http请求头你了解的&#34;&gt;&lt;a href=&#34;#8-http请求头你了解的&#34; class=&#34;headerlink&#34; title=&#34;8.http请求头你了解的&#34;&gt;&lt;/a&gt;8.http请求头你了解的&lt;/h2&gt;&lt;h2 id=&#34;9-contenttype你的了解&#34;&gt;&lt;a href=&#34;#9-contenttype你的了解&#34; class=&#34;headerlink&#34; title=&#34;9.contenttype你的了解&#34;&gt;&lt;/a&gt;9.contenttype你的了解&lt;/h2&gt;&lt;h2 id=&#34;10-描述你简历项目&#34;&gt;&lt;a href=&#34;#10-描述你简历项目&#34; class=&#34;headerlink&#34; title=&#34;10.描述你简历项目&#34;&gt;&lt;/a&gt;10.描述你简历项目&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/JavaScript/promise/</guid>
            <title>详解JsPromise</title>
            <link>https://www.yexingcheng.com/JavaScript/promise/</link>
            <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
            <category term="Js" scheme="https://www.yexingcheng.com/tags/Js/" />
            <pubDate>Mon, 14 Nov 2022 20:49:25 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;什么是promise&#34;&gt;&lt;a href=&#34;#什么是promise&#34; class=&#34;headerlink&#34; title=&#34;什么是promise?&#34;&gt;&lt;/a&gt;什么是promise?&lt;/h1&gt;&lt;p&gt;来看看官方解释：&lt;/p&gt;
&lt;p&gt;Promise 是目前 JS 异步编程的一种解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。&lt;br&gt;Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基本过程&lt;/strong&gt;：&lt;br&gt;初始化 Promise 状态（pending）&lt;br&gt;立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理&lt;br&gt;执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）&lt;br&gt;Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/JavaScript/object-oriented/</guid>
            <title>Js面向对象详解</title>
            <link>https://www.yexingcheng.com/JavaScript/object-oriented/</link>
            <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
            <category term="Js" scheme="https://www.yexingcheng.com/tags/Js/" />
            <pubDate>Mon, 14 Nov 2022 20:28:45 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/algorithm/sort/</guid>
            <title>基础排序算法总结</title>
            <link>https://www.yexingcheng.com/algorithm/sort/</link>
            <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
            <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
            <pubDate>Mon, 14 Nov 2022 02:17:16 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;冒泡排序：&#34;&gt;&lt;a href=&#34;#冒泡排序：&#34; class=&#34;headerlink&#34; title=&#34;冒泡排序：&#34;&gt;&lt;/a&gt;冒泡排序：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;从开始位置两两比较，持续n轮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基础版：&#34;&gt;&lt;a href=&#34;#基础版：&#34; class=&#34;headerlink&#34; title=&#34;基础版：&#34;&gt;&lt;/a&gt;基础版：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function bubbleSort(arr)&amp;#123;
    for(let i = 0; i &amp;lt;arr.length; i++)&amp;#123;
        for(let j = 0; j &amp;lt;arr.length; j++)&amp;#123;
            if(arr[j]&amp;gt;arr[j+1])&amp;#123;
                let tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;改进版&#34;&gt;&lt;a href=&#34;#改进版&#34; class=&#34;headerlink&#34; title=&#34;改进版&#34;&gt;&lt;/a&gt;改进版&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function bubleSort(arr)&amp;#123;
    for(let i = arr.length-1;i&amp;gt;0;i--)&amp;#123;
        for(let j = 0; j&amp;lt;i;j++)&amp;#123;
            if(arr[j]&amp;gt;arr[j+1])&amp;#123;
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;选择排序：&#34;&gt;&lt;a href=&#34;#选择排序：&#34; class=&#34;headerlink&#34; title=&#34;选择排序：&#34;&gt;&lt;/a&gt;选择排序：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;每次选出最大&amp;#x2F;最小值 持续n轮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基础班&#34;&gt;&lt;a href=&#34;#基础班&#34; class=&#34;headerlink&#34; title=&#34;基础班&#34;&gt;&lt;/a&gt;基础班&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function selectSort(arr)&amp;#123;
    for(let i = 0i&amp;lt;arr.length; i &amp;lt; ++)&amp;#123;
        let index = i;

        for(let j = i;j&amp;lt;arr.length;j++)&amp;#123;
            if(arr[index]&amp;gt;arr[j])&amp;#123;
                index = j;
        &amp;#125;
    &amp;#125;
    [arr[i], arr[index]] = [arr[index],arr[i]]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;改进版-1&#34;&gt;&lt;a href=&#34;#改进版-1&#34; class=&#34;headerlink&#34; title=&#34;改进版&#34;&gt;&lt;/a&gt;改进版&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function selectSort (arr) &amp;#123;
  for (let i = 0, len_i = arr.length - 1; i &amp;lt; len_i; i++) &amp;#123;
    let index = i
    for (let j = i + 1, len_j = arr.length; j &amp;lt; len_j; j++) &amp;#123;
      if (arr[index] &amp;gt; arr[j]) &amp;#123;
        index = j
      &amp;#125;
    &amp;#125;
    if (index !== i) &amp;#123;
      [arr[i], arr[index]] = [arr[index], arr[i]]
    &amp;#125;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;插入排序&#34;&gt;&lt;a href=&#34;#插入排序&#34; class=&#34;headerlink&#34; title=&#34;插入排序&#34;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;h1 id=&#34;希尔排序&#34;&gt;&lt;a href=&#34;#希尔排序&#34; class=&#34;headerlink&#34; title=&#34;希尔排序&#34;&gt;&lt;/a&gt;希尔排序&lt;/h1&gt;&lt;h1 id=&#34;归并排序&#34;&gt;&lt;a href=&#34;#归并排序&#34; class=&#34;headerlink&#34; title=&#34;归并排序&#34;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h1 id=&#34;快速排序&#34;&gt;&lt;a href=&#34;#快速排序&#34; class=&#34;headerlink&#34; title=&#34;快速排序&#34;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h1 id=&#34;堆排序&#34;&gt;&lt;a href=&#34;#堆排序&#34; class=&#34;headerlink&#34; title=&#34;堆排序&#34;&gt;&lt;/a&gt;堆排序&lt;/h1&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/algorithm/concurrent-requests/</guid>
            <title>并发请求</title>
            <link>https://www.yexingcheng.com/algorithm/concurrent-requests/</link>
            <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
            <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
            <pubDate>Mon, 14 Nov 2022 01:54:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;并发请求：&#34;&gt;&lt;a href=&#34;#并发请求：&#34; class=&#34;headerlink&#34; title=&#34;并发请求：&#34;&gt;&lt;/a&gt;并发请求：&lt;/h1&gt;&lt;p&gt;给定一个url数组，每一项都是一个url地址，然后给出一个最大的并发请求数，直到所有请求发送完毕，然后把所有的返回结果归并到一个数组里面，并且顺序和url地址顺序相同&lt;/p&gt;
&lt;p&gt;首先，请求肯定是异步的，所以我们返回一个Promise,并且这个Promise一定是成功的，并且我们准备好一个返回数组，并且排除特殊情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
    &amp;#125;)
        let result = []

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次我们取出一个url地址，然后发送请求，因为我们不用等待请求结果，所以可以看作是并发的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        function request()&amp;#123;
            const url = urls[index];
            index++;
            fetch(url)
        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在以及可以发送请求了，但是在他请求完了之后，不管是成功还是失败，我们都加入到返回数组中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        async function request()&amp;#123;
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;

        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个请求完成了，就要开始发送下一个请求了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标

        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                request()
            &amp;#125;

        &amp;#125;

    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后要判断所有请求是否都完成了，我们每完成一次请求就记录一次数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标
        let count = 0;//完成的请求数量
        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                count++
                if(count===urls.length)&amp;#123;
                    resolve(result)
                &amp;#125;
                request()
            &amp;#125;

        &amp;#125;
    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们请求的函数就有了，但是要调用几次呢，就是调用最大并发数的次数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function concurRequest(urls,maxNum)&amp;#123;
    return new Promise(resolve=&amp;gt;&amp;#123;
        if(urls.length===0)&amp;#123;
            reslove([])
            return
        &amp;#125;
        let result = []
        let index = 0;//下一个请求的下标
        let count = 0;//完成的请求数量
        async function request()&amp;#123;

            if(index==urls.length)return//发送次数到达最大就停止发送
            const i = index;//保存请求url在urls数组中的位置
            const url = urls[index];
            index++;
            try&amp;#123;
                const res  = await fetch(url)
                result[i] = res
            &amp;#125;catch(e)&amp;#123;
                result[i] = e
            &amp;#125;finally&amp;#123;
                count++
                if(count===urls.length)&amp;#123;
                    resolve(result)
                &amp;#125;
                request()
            &amp;#125;

        &amp;#125;

        let times = Math.min(urls.length,maxNum)

        for(let i = 0; i &amp;lt; times; i++)&amp;#123;
            request()
        &amp;#125;
    &amp;#125;)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里这道面试题就完成了&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/data-structures/stack/</guid>
            <title>栈代码面试题</title>
            <link>https://www.yexingcheng.com/data-structures/stack/</link>
            <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <category term="stack" scheme="https://www.yexingcheng.com/tags/stack/" />
            <pubDate>Sat, 12 Nov 2022 21:27:30 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;使用临时堆栈对堆栈进行排序&#34;&gt;&lt;a href=&#34;#使用临时堆栈对堆栈进行排序&#34; class=&#34;headerlink&#34; title=&#34;使用临时堆栈对堆栈进行排序&#34;&gt;&lt;/a&gt;使用临时堆栈对堆栈进行排序&lt;/h1&gt;&lt;p&gt;给定一堆整数，使用另一个临时堆栈按升序对其进行排序。&lt;/p&gt;
&lt;h2 id=&#34;例子：&#34;&gt;&lt;a href=&#34;#例子：&#34; class=&#34;headerlink&#34; title=&#34;例子：&#34;&gt;&lt;/a&gt;例子：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入 ：[34、3、31、98、92、23]&lt;br&gt;输出：[3、23、31、34、92、98]&lt;/p&gt;
&lt;p&gt;输入：[3、5、1、4、2、8]&lt;br&gt;输出：[1、2、3、4、5、8]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;算法：&#34;&gt;&lt;a href=&#34;#算法：&#34; class=&#34;headerlink&#34; title=&#34;算法：&#34;&gt;&lt;/a&gt;算法：&lt;/h2&gt;&lt;p&gt;1、创建一个临时堆栈为tmpStack&lt;br&gt;2、虽然输入堆栈不为空，但请执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从输入堆栈弹出一个元素，成为temp&lt;/li&gt;
&lt;li&gt;当临时堆栈不为空且临时堆栈顶部大于 temp 时， 临时堆栈中弹出并将其推送到输入堆栈&lt;/li&gt;
&lt;li&gt;将temp推入临时堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、排序后的数字在tempStack&lt;/p&gt;
&lt;h2 id=&#34;执行：&#34;&gt;&lt;a href=&#34;#执行：&#34; class=&#34;headerlink&#34; title=&#34;执行：&#34;&gt;&lt;/a&gt;执行：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function sortStack(input)&amp;#123;

    let tempStack = [];
    while(input.length &amp;gt; 0)&amp;#123;

        let temp = input.pop();

    while(tempStack.length &amp;gt; 0 &amp;amp;&amp;amp; tempStack[tempStack.length-1]&amp;gt;temp)&amp;#123;

        input.push(tempStack[tempStack.length-1]);

        tempStack.pop();
    &amp;#125;   

    tempStack.push(temp);

    &amp;#125;
    return tempStack;
&amp;#125;


const arr = [34, 3, 31, 98, 92, 23]

console.log(sortStack(arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[34, 3, 31, 98, 92, 23]&lt;/p&gt;
&lt;p&gt;取出的元素：23&lt;br&gt;输入：[34, 3, 31, 98, 92]&lt;br&gt;tmpStack：[23]&lt;/p&gt;
&lt;p&gt;取出的元素：92&lt;br&gt;输入：[34, 3, 31, 98]&lt;br&gt;tmpStack: [23, 92]&lt;/p&gt;
&lt;p&gt;取出元素: 98&lt;br&gt;输入: [34, 3, 31]&lt;br&gt;tmpStack: [23, 92, 98]&lt;/p&gt;
&lt;p&gt;取出元素: 31&lt;br&gt;输入: [34, 3, 98, 92]&lt;br&gt;tmpStack: [23, 31]&lt;/p&gt;
&lt;p&gt;取出元素: 92&lt;br&gt;输入: [34, 3, 98]&lt;br&gt;tmpStack: [23, 31, 92]&lt;/p&gt;
&lt;p&gt;取出元素: 98&lt;br&gt;输入: [34, 3]&lt;br&gt;tmpStack: [23, 31, 92 , 98]&lt;/p&gt;
&lt;p&gt;取出的元素：3&lt;br&gt;输入：[34, 98, 92, 31, 23]&lt;br&gt;tmpStack：[3]&lt;/p&gt;
&lt;p&gt;取出的元素：23&lt;br&gt;输入：[34, 98, 92, 31]&lt;br&gt;tmpStack: [3, 23]&lt;/p&gt;
&lt;p&gt;取出元素: 31&lt;br&gt;输入: [34, 98, 92]&lt;br&gt;tmpStack: [3, 23, 31]&lt;/p&gt;
&lt;p&gt;取出元素: 92&lt;br&gt;输入: [34, 98]&lt;br&gt;tmpStack: [3, 23, 31 , 92]&lt;/p&gt;
&lt;p&gt;取出的元素：98&lt;br&gt;输入：[34]&lt;br&gt;tmpStack：[3, 23, 31, 92, 98]&lt;/p&gt;
&lt;p&gt;取出的元素：34&lt;br&gt;输入：[98, 92]&lt;br&gt;tmpStack：[3, 23, 31, 34]&lt;/p&gt;
&lt;p&gt;元素取出：92&lt;br&gt;输入：[98]&lt;br&gt;tmpStack：[3,23,31,34,92]&lt;/p&gt;
&lt;p&gt;取出元素：98&lt;br&gt;输入：[]&lt;br&gt;tmpStack：[3,23,31,34,92,98]&lt;/p&gt;
&lt;p&gt;最终排序列表： [3、23、31、34、92、98]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;输出&#34;&gt;&lt;a href=&#34;#输出&#34; class=&#34;headerlink&#34; title=&#34;输出&#34;&gt;&lt;/a&gt;输出&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;98 92 34 31 23 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; O(n 2 )其中 n 是给定堆栈中的整数总数。&lt;br&gt;&lt;strong&gt;辅助空间：&lt;/strong&gt; O(n)&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/data-structures/array/</guid>
            <title>数组代码面试题</title>
            <link>https://www.yexingcheng.com/data-structures/array/</link>
            <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
            <category term="Array" scheme="https://www.yexingcheng.com/tags/Array/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <pubDate>Fri, 11 Nov 2022 22:11:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;查找数组中最小和次小的元素&#34;&gt;&lt;a href=&#34;#查找数组中最小和次小的元素&#34; class=&#34;headerlink&#34; title=&#34;查找数组中最小和次小的元素&#34;&gt;&lt;/a&gt;查找数组中最小和次小的元素&lt;/h1&gt;&lt;h2 id=&#34;实例：&#34;&gt;&lt;a href=&#34;#实例：&#34; class=&#34;headerlink&#34; title=&#34;实例：&#34;&gt;&lt;/a&gt;实例：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;输入：arr[] = &amp;#123;12, 13, 1, 10, 34, 1&amp;#125;
输出：最小元素是 1 
     第二个最小的元素是 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法1（简单方法）&#34;&gt;&lt;a href=&#34;#方法1（简单方法）&#34; class=&#34;headerlink&#34; title=&#34;方法1（简单方法）&#34;&gt;&lt;/a&gt;方法1（简单方法）&lt;/h3&gt;&lt;p&gt;一个简单的解决方案是按照升序对数组进行排序。排序数组中的前两个元素将是两个最小的元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;let arr = [111, 13, 25, 9, 34, 1];

arr.sort((a,b)=&amp;gt;a-b)

console.log(arr[0],arr[1]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果最小元素出现不止一次，那么我们将不得不使用循环来打印唯一的最小元素和次小元素。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; O(N*logN)&lt;br&gt;&lt;strong&gt;辅助空间：&lt;/strong&gt; O(1)&lt;/p&gt;
&lt;h3 id=&#34;方法2&#34;&gt;&lt;a href=&#34;#方法2&#34; class=&#34;headerlink&#34; title=&#34;方法2&#34;&gt;&lt;/a&gt;方法2&lt;/h3&gt;&lt;p&gt;更好的&lt;strong&gt;解决方案&lt;/strong&gt;是扫描阵列两次。在第一次遍历中找到最小元素。设此元素为 x。在第二次遍历中，找到大于 x 的最小元素。&lt;/p&gt;
&lt;p&gt;使用这种方法，我们可以克服方法 1 的问题，即最小元素在数组中出现多次时出现的问题。&lt;br&gt;上述解决方案需要对输入数组进行两次遍历。 &lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/data-structures/main/</guid>
            <title>面试需要了解的八个数据结构</title>
            <link>https://www.yexingcheng.com/data-structures/main/</link>
            <category term="数据结构" scheme="https://www.yexingcheng.com/categories/data-structures/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <pubDate>Fri, 11 Nov 2022 21:59:56 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;1976 年，一个瑞士计算机科学家写一本书《Algorithms + Data Structures &amp;#x3D; Programs》。即：算法 + 数据结构 &amp;#x3D; 程序。40 多年过去了，这个等式依然成立。&lt;/p&gt;
&lt;p&gt;很多代码面试题都要求候选者深入理解数据结构，不管你来自大学计算机专业还是编程培训机构，也不管你有多少年编程经验。有时面试题会直接提到数据结构，比如“给我实现一个二叉树”，然而有时则不那么明显，比如“统计一下每个作者写的书的数量”。&lt;/p&gt;
&lt;h1 id=&#34;什么是数据结构？&#34;&gt;&lt;a href=&#34;#什么是数据结构？&#34; class=&#34;headerlink&#34; title=&#34;什么是数据结构？&#34;&gt;&lt;/a&gt;什么是数据结构？&lt;/h1&gt;&lt;p&gt;数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要数据结构&#34;&gt;&lt;a href=&#34;#为什么我们需要数据结构&#34; class=&#34;headerlink&#34; title=&#34;为什么我们需要数据结构&#34;&gt;&lt;/a&gt;为什么我们需要数据结构&lt;/h2&gt;&lt;p&gt;数据是程序的核心要素，因此数据结构的价值不言而喻。无论你在写什么程序，你都需要与数据打交道，比如员工工资、股票价格、杂货清单或者电话本。在不同场景下，数据需要以特定的方式存储，我们有不同的数据结构可以满足我们的需求。&lt;/p&gt;
&lt;h1 id=&#34;8种常用的数据结构&#34;&gt;&lt;a href=&#34;#8种常用的数据结构&#34; class=&#34;headerlink&#34; title=&#34;8种常用的数据结构&#34;&gt;&lt;/a&gt;8种常用的数据结构&lt;/h1&gt;&lt;p&gt;1.数组&lt;br&gt;2.栈&lt;br&gt;3.队列&lt;br&gt;4.链表&lt;br&gt;5.图&lt;br&gt;6.树&lt;br&gt;7.前缀树&lt;br&gt;8.哈希表&lt;/p&gt;
&lt;h2 id=&#34;1、数组&#34;&gt;&lt;a href=&#34;#1、数组&#34; class=&#34;headerlink&#34; title=&#34;1、数组&#34;&gt;&lt;/a&gt;1、数组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;(Array)大概是最简单，也是最常用的数据结构了。其他数据结构，比如栈和队列都是由数组衍生出来的&lt;/p&gt;
&lt;p&gt;下面展示了一个数组，他有四个元素&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/data-structures/main/image-20221111221359307.png&#34; alt=&#34;image-20221111221359307&#34;&gt;&lt;/p&gt;
&lt;p&gt;每一个元素的位置由数字编号，称为下标或者索引。大多数编程语言的第一个元素的下标为0。&lt;/p&gt;
&lt;p&gt;根据维度区分，有2种不同的数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一维数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数组的基本操作&#34;&gt;&lt;a href=&#34;#数组的基本操作&#34; class=&#34;headerlink&#34; title=&#34;数组的基本操作&#34;&gt;&lt;/a&gt;数组的基本操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Insert - 在某个索引处插入元素&lt;/li&gt;
&lt;li&gt;Get - 读取某个索引处的元素&lt;/li&gt;
&lt;li&gt;Delete - 删除某个索引处的元素&lt;/li&gt;
&lt;li&gt;Size - 获取数组的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;/data-structures/array/&#34;&gt;常见的数组代码面试题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-栈&#34;&gt;&lt;a href=&#34;#2-栈&#34; class=&#34;headerlink&#34; title=&#34;2. 栈&#34;&gt;&lt;/a&gt;2. 栈&lt;/h2&gt;&lt;p&gt;撤回，即 Ctrl+Z，是我们最常见的操作之一，大多数应用都会支持这个功能。你知道它是怎么实现的吗？答案是这样的：把之前的应用状态(限制个数)保存到内存中，最近的状态放到第一个。这时，我们需要栈(stack)来实现这个功能。&lt;/p&gt;
&lt;p&gt;栈中的元素采用 LIFO (Last In First Out)，即后进先出。&lt;/p&gt;
&lt;p&gt;下图的栈有 3 个元素，3 在最上面，因此它会被第一个移除&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/data-structures/main/image-20221112212908111.png&#34; alt=&#34;image-20221112212908111&#34;&gt;&lt;/p&gt;
&lt;p&gt;栈的基本操作 &lt;/p&gt;
&lt;p&gt;栈的基本操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Push —  在栈的最上方插入元素&lt;/li&gt;
&lt;li&gt;Pop — 返回栈最上方的元素，并将其删除&lt;/li&gt;
&lt;li&gt;isEmpty —  查询栈是否为空&lt;/li&gt;
&lt;li&gt;Top —  返回栈最上方的元素，并不删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;/data-structures/stack/&#34;&gt;常见的数组代码面试题&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/JavaScript/wrapper-object/</guid>
            <title>js中包装对象</title>
            <link>https://www.yexingcheng.com/JavaScript/wrapper-object/</link>
            <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <pubDate>Tue, 08 Nov 2022 21:08:22 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;先来看定义&#34;&gt;&lt;a href=&#34;#先来看定义&#34; class=&#34;headerlink&#34; title=&#34;先来看定义&#34;&gt;&lt;/a&gt;先来看定义&lt;/h1&gt;&lt;p&gt;对象是javascript语言最主要的数据类型，三种原始类型的值————Number,string,boolean在一定条件下，也会自动转为对象，也就是原始类型的&lt;code&gt;包装对象&lt;/code&gt;(wrapper)&lt;/p&gt;
&lt;p&gt;所谓&lt;code&gt;包装对象&lt;/code&gt; 指的是Number,string,boolean分别对应的Number,String,Boolean三个原生对象。这三个原生对象可以把原始类型的值变成(包装成)对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var v1 = new Number(123);
var v2 = new String(&amp;#39;abc&amp;#39;);
var v3 = new Boolean(true);

typeof v1 // &amp;quot;object&amp;quot;
typeof v2 // &amp;quot;object&amp;quot;
typeof v3 // &amp;quot;object&amp;quot;

v1 === 123 // false
v2 === &amp;#39;abc&amp;#39; // false
v3 === true // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，v1、v2、v3都是对象，且与对应的简单类型值不相等。&lt;/p&gt;
&lt;p&gt;包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Boolean&lt;/code&gt;这三个原生对象，如果不作为构造函数调用（即调用时不加new），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 字符串转为数值
Number(&amp;#39;123&amp;#39;) // 123

// 数值转为字符串
String(123) // &amp;quot;123&amp;quot;

// 数值转为布尔值
Boolean(123) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。&lt;/p&gt;
&lt;h1 id=&#34;实例方法&#34;&gt;&lt;a href=&#34;#实例方法&#34; class=&#34;headerlink&#34; title=&#34;实例方法&#34;&gt;&lt;/a&gt;实例方法&lt;/h1&gt;&lt;p&gt;三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从Object对象继承的方法:&lt;code&gt;valueOf()&lt;/code&gt;和&lt;code&gt;toString()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valueOf()&lt;br&gt;&lt;code&gt;valueOf()&lt;/code&gt;方法返回包装对象实例对应的原始类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new Number(123).valueOf()  // 123
new String(&amp;#39;abc&amp;#39;).valueOf() // &amp;quot;abc&amp;quot;
new Boolean(true).valueOf() // true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;toString()&lt;br&gt;&lt;code&gt;toString()&lt;/code&gt;方法返回对应的字符串形式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new Number(123).toString() // &amp;quot;123&amp;quot;
new String(&amp;#39;abc&amp;#39;).toString() // &amp;quot;abc&amp;quot;
new Boolean(true).toString() // &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原始类型与实例对象的自动转换&#34;&gt;&lt;a href=&#34;#原始类型与实例对象的自动转换&#34; class=&#34;headerlink&#34; title=&#34;原始类型与实例对象的自动转换&#34;&gt;&lt;/a&gt;原始类型与实例对象的自动转换&lt;/h2&gt;&lt;p&gt;某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。&lt;/p&gt;
&lt;p&gt;比如，字符串可以调用&lt;code&gt;length&lt;/code&gt;属性，返回字符串的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;abc&amp;#39;.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;abc&lt;/code&gt;是一个字符串，本身不是对象，不能调用&lt;code&gt;length&lt;/code&gt;属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用&lt;code&gt;length&lt;/code&gt;属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var str = &amp;#39;abc&amp;#39;;
str.length // 3

// 等同于
var strObj = new String(str)
// String &amp;#123;
//   0: &amp;quot;a&amp;quot;, 1: &amp;quot;b&amp;quot;, 2: &amp;quot;c&amp;quot;, length: 3, [[PrimitiveValue]]: &amp;quot;abc&amp;quot;
// &amp;#125;
strObj.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s = &amp;#39;Hello World&amp;#39;;
s.x = 123;
s.x // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。&lt;/p&gt;
&lt;h2 id=&#34;自定义方法&#34;&gt;&lt;a href=&#34;#自定义方法&#34; class=&#34;headerlink&#34; title=&#34;自定义方法&#34;&gt;&lt;/a&gt;自定义方法&lt;/h2&gt;&lt;p&gt;除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。&lt;/p&gt;
&lt;p&gt;比如，我们可以新增一个double方法，使得字符串和数字翻倍。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;String.prototype.double = function () &amp;#123;
  return this.valueOf() + this.valueOf();
&amp;#125;;

&amp;#39;abc&amp;#39;.double() // abcabc

Number.prototype.double = function () &amp;#123;
  return this.valueOf() + this.valueOf();
&amp;#125;;

(123).double() // 246
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码在String和Number这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后的123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。&lt;/p&gt;
&lt;h1 id=&#34;Boolean对象&#34;&gt;&lt;a href=&#34;#Boolean对象&#34; class=&#34;headerlink&#34; title=&#34;Boolean对象&#34;&gt;&lt;/a&gt;Boolean对象&lt;/h1&gt;&lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述:&#34;&gt;&lt;/a&gt;概述:&lt;/h2&gt;&lt;p&gt;Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var b = new Boolean(true);

typeof b // &amp;quot;object&amp;quot;
b.valueOf() // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的变量b是一个&lt;code&gt;Boolean&lt;/code&gt;对象的实例，它的类型是对象，值为布尔值&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;false&lt;/code&gt;对应的包装对象实例，布尔运算结果也是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;if (new Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true

if (new Boolean(false).valueOf()) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始值，本例为false。&lt;/p&gt;
&lt;h2 id=&#34;Boolean-函数的类型转换作用&#34;&gt;&lt;a href=&#34;#Boolean-函数的类型转换作用&#34; class=&#34;headerlink&#34; title=&#34;Boolean 函数的类型转换作用&#34;&gt;&lt;/a&gt;Boolean 函数的类型转换作用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt;对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时&lt;code&gt;Boolean&lt;/code&gt;就是一个单纯的工具方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(&amp;#39;&amp;#39;) // false
Boolean(NaN) // false

Boolean(1) // true
Boolean(&amp;#39;false&amp;#39;) // true
Boolean([]) // true
Boolean(&amp;#123;&amp;#125;) // true
Boolean(function () &amp;#123;&amp;#125;) // true
Boolean(/foo/) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中几种得到true的情况，都值得认真记住。&lt;/p&gt;
&lt;p&gt;顺便提一下，使用双重的否运算符（!）也可以将任意值转为对应的布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;!!undefined // false
!!null // false
!!0 // false
!!&amp;#39;&amp;#39; // false
!!NaN // false

!!1 // true
!!&amp;#39;false&amp;#39; // true
!![] // true
!!&amp;#123;&amp;#125; // true
!!function()&amp;#123;&amp;#125; // true
!!/foo/ // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，对于一些特殊值，&lt;code&gt;Boolean&lt;/code&gt;对象前面加不加&lt;code&gt;new&lt;/code&gt;，会得到完全相反的结果，必须小心。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;if (Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出

if (new Boolean(false)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true

if (Boolean(null)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // 无输出

if (new Boolean(null)) &amp;#123;
  console.log(&amp;#39;true&amp;#39;);
&amp;#125; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Number-对象&#34;&gt;&lt;a href=&#34;#Number-对象&#34; class=&#34;headerlink&#34; title=&#34;Number 对象&#34;&gt;&lt;/a&gt;Number 对象&lt;/h1&gt;&lt;h2 id=&#34;概述-1&#34;&gt;&lt;a href=&#34;#概述-1&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。&lt;/p&gt;
&lt;p&gt;作为构造函数时，它用于生成值为数值的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var n = new Number(1);
typeof n // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;Number&lt;/code&gt;对象作为构造函数使用，返回一个值为1的对象。&lt;/p&gt;
&lt;p&gt;作为工具函数时，它可以将任何类型的值转为数值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;Number(true) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;静态属性&#34;&gt;&lt;a href=&#34;#静态属性&#34; class=&#34;headerlink&#34; title=&#34;静态属性&#34;&gt;&lt;/a&gt;静态属性&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;对象拥有以下一些静态属性（即直接定义在&lt;code&gt;Number&lt;/code&gt;对象上的属性，而不是定义在实例上的属性）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;：正的无限，指向Infinity。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.NEGATIVE_INFINITY&lt;/code&gt;：负的无限，指向-Infinity。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.NaN&lt;/code&gt;：表示非数值，指向NaN。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MIN_VALUE&lt;/code&gt;：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应- 的，最接近0的负数为-&lt;code&gt;Number.MIN_VALUE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;：表示能够精确表示的最大整数，即9007199254740991。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt;：表示能够精确表示的最小整数，即-9007199254740991。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例方法&lt;br&gt;&lt;code&gt;Number&lt;/code&gt;对象有4个实例方法，都跟将数值转换成指定格式有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number.prototype.toString()&lt;/strong&gt;&lt;br&gt;&lt;code&gt;Numbe&lt;/code&gt;r对象部署了自己的&lt;code&gt;toString&lt;/code&gt;方法，用来将一个数值转为字符串形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(10).toString() // &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(10).toString(2) // &amp;quot;1010&amp;quot;
(10).toString(8) // &amp;quot;12&amp;quot;
(10).toString(16) // &amp;quot;a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10.toString(2)
// SyntaxError: Unexpected token ILLEGAL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为10加上括号，还可以在&lt;code&gt;10&lt;/code&gt;后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10..toString(2) // &amp;quot;1010&amp;quot;

// 其他方法还包括
10 .toString(2) // &amp;quot;1010&amp;quot;
10.0.toString(2) // &amp;quot;1010&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这实际上意味着，可以直接对一个小数使用&lt;code&gt;toString&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10.5.toString() // &amp;quot;10.5&amp;quot;
10.5.toString(2) // &amp;quot;1010.1&amp;quot;
10.5.toString(8) // &amp;quot;12.4&amp;quot;
10.5.toString(16) // &amp;quot;a.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过方括号运算符也可以调用&lt;code&gt;toString&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;10[&amp;#39;toString&amp;#39;](2) // &amp;quot;1010&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用&lt;code&gt;parseInt&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number.prototype.toFixed()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toPrecision方法用于将一个数转为指定位数的有效数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(12.34).toPrecision(1) // &amp;quot;1e+1&amp;quot;
(12.34).toPrecision(2) // &amp;quot;12&amp;quot;
(12.34).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.34).toPrecision(4) // &amp;quot;12.34&amp;quot;
(12.34).toPrecision(5) // &amp;quot;12.340&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toPrecision&lt;/code&gt;方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出&lt;code&gt;RangeError&lt;/code&gt;错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toPrecision&lt;/code&gt;方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;(12.35).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.25).toPrecision(3) // &amp;quot;12.3&amp;quot;
(12.15).toPrecision(3) // &amp;quot;12.2&amp;quot;
(12.45).toPrecision(3) // &amp;quot;12.4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;String-对象&#34;&gt;&lt;a href=&#34;#String-对象&#34; class=&#34;headerlink&#34; title=&#34;String 对象&#34;&gt;&lt;/a&gt;String 对象&lt;/h1&gt;&lt;h2 id=&#34;概述-2&#34;&gt;&lt;a href=&#34;#概述-2&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s1 = &amp;#39;abc&amp;#39;;
var s2 = new String(&amp;#39;abc&amp;#39;);

typeof s1 // &amp;quot;string&amp;quot;
typeof s2 // &amp;quot;object&amp;quot;

s2.valueOf() // &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串对象是一个类似数组的对象（很像数组，但不是数组）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;new String(&amp;#39;abc&amp;#39;)
// String &amp;#123;0: &amp;quot;a&amp;quot;, 1: &amp;quot;b&amp;quot;, 2: &amp;quot;c&amp;quot;, length: 3&amp;#125;

(new String(&amp;#39;abc&amp;#39;))[1] // &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例属性&#34;&gt;&lt;a href=&#34;#实例属性&#34; class=&#34;headerlink&#34; title=&#34;实例属性&#34;&gt;&lt;/a&gt;实例属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;String.prototype.length&lt;/strong&gt;&lt;br&gt;字符串实例的length属性返回字符串的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;abc&amp;#39;.length // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;静态方法&#34;&gt;&lt;a href=&#34;#静态方法&#34; class=&#34;headerlink&#34; title=&#34;静态方法:&#34;&gt;&lt;/a&gt;静态方法:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;String.prototype.match()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;at&amp;#39;) // [&amp;quot;at&amp;quot;]
&amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;xt&amp;#39;) // null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回的数组还有&lt;code&gt;index&lt;/code&gt;属性和&lt;code&gt;input&lt;/code&gt;属性，分别表示匹配字符串开始的位置和原始字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var matches = &amp;#39;cat, bat, sat, fat&amp;#39;.match(&amp;#39;at&amp;#39;);
matches.index // 1
matches.input // &amp;quot;cat, bat, sat, fat&amp;quot;
match方法还可以使用正则表达式作为参数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;String.prototype.localeCompare()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;localeCompare&lt;/code&gt;方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;apple&amp;#39;.localeCompare(&amp;#39;banana&amp;#39;) // -1
&amp;#39;apple&amp;#39;.localeCompare(&amp;#39;apple&amp;#39;) // 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;B&amp;#39; &amp;gt; &amp;#39;a&amp;#39; // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，字母B小于字母a。因为 JavaScript 采用的是 Unicode 码点比较，B的码点是&lt;code&gt;66&lt;/code&gt;，而a的码点是&lt;code&gt;97&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;localeCompare&lt;/code&gt;方法会考虑自然语言的排序情况，将B排在a的前面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;B&amp;#39;.localeCompare(&amp;#39;a&amp;#39;) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;localeCompare&lt;/code&gt;方法返回整数1，表示B较大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;localeCompare&lt;/code&gt;还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;&amp;#39;ä&amp;#39;.localeCompare(&amp;#39;z&amp;#39;, &amp;#39;de&amp;#39;) // -1
&amp;#39;ä&amp;#39;.localeCompare(&amp;#39;z&amp;#39;, &amp;#39;sv&amp;#39;) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，de表示德语，sv表示瑞典语。德语中，ä小于z，所以返回-1；瑞典语中，ä大于z，所以返回1。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/JavaScript/Variable-recycling/</guid>
            <title>JS变量回收机制</title>
            <link>https://www.yexingcheng.com/JavaScript/Variable-recycling/</link>
            <category term="JavaScript" scheme="https://www.yexingcheng.com/categories/JavaScript/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <pubDate>Mon, 07 Nov 2022 00:09:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;先看题目&#34;&gt;&lt;a href=&#34;#先看题目&#34; class=&#34;headerlink&#34; title=&#34;先看题目:&#34;&gt;&lt;/a&gt;先看题目:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下列代码有几个变量没有被回收？&lt;code&gt;点我查看&lt;/code&gt; [3]{.gap}。 {.quiz .fill}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即i和add,局部变量有一个i，因为局部变量被另一个作用域引用，所以局部变量i也不回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var i = 1;
var i = 2;
var add = function() &amp;#123;
    var i = 0;
    return function()
&amp;#123;
        i++;
        console.log(i);
    &amp;#125;
&amp;#125;();
add();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;变量回收原则&#34;&gt;&lt;a href=&#34;#变量回收原则&#34; class=&#34;headerlink&#34; title=&#34;变量回收原则:&#34;&gt;&lt;/a&gt;变量回收原则:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;全局变量不会回收&lt;/li&gt;
&lt;li&gt;局部变量会被回收,也就是函数一旦运行完后，函数内部的东西都会被销毁&lt;/li&gt;
&lt;li&gt;只要被另外一个作用域引用就不会被回收&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var i = 1;   // 全局变量不会被回收
var i = 2;   // 这里重复声明变量i,因此var声明被忽略，只是把i赋值为2
var add = function() &amp;#123;  // 全局变量不会被回收
    var i = 0;  // 局部变量
    return function() &amp;#123;
        i++;
        console.log(i); // 被另一个作用域引用导致不会被回收
    &amp;#125;
&amp;#125;();
add();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;JS的垃圾回收机制&#34;&gt;&lt;a href=&#34;#JS的垃圾回收机制&#34; class=&#34;headerlink&#34; title=&#34;JS的垃圾回收机制&#34;&gt;&lt;/a&gt;JS的垃圾回收机制&lt;/h1&gt;&lt;h2 id=&#34;标记清除&#34;&gt;&lt;a href=&#34;#标记清除&#34; class=&#34;headerlink&#34; title=&#34;标记清除&#34;&gt;&lt;/a&gt;标记清除&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;js中最常见的垃圾回收方式是标记清除&lt;br&gt;标记清除就是从根部出发，看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它。&lt;br&gt;这个过程大致分为三步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器创建roots列表,roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局变量window作为root,也就是所谓的跟部&lt;/li&gt;
&lt;li&gt;从根部出发检查所有的roots,所有的children也会被递归检查，能从root到达的都会被标记为active&lt;/li&gt;
&lt;li&gt;未被标记为active的数据被认定为不再需要，垃圾回收器开始释放他们&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:&lt;br&gt;当一个对象&lt;code&gt;零引用&lt;/code&gt;时，我们从根部&lt;code&gt;一定无法到达&lt;/code&gt;。&lt;br&gt;但反过来，从&lt;code&gt;根部无法到达&lt;/code&gt;的&lt;code&gt;不一定&lt;/code&gt;是严格意义上的零引用，比如循环引用，所以标记清除要&lt;code&gt;更优于引用计数&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;引用计数&#34;&gt;&lt;a href=&#34;#引用计数&#34; class=&#34;headerlink&#34; title=&#34;引用计数&#34;&gt;&lt;/a&gt;引用计数&lt;/h2&gt;&lt;p&gt;工作原理:工作原理：跟踪记录每个值被引用的次数。&lt;/p&gt;
&lt;h2 id=&#34;什么情况会引起内存泄漏-无法释放已经不使用的内存&#34;&gt;&lt;a href=&#34;#什么情况会引起内存泄漏-无法释放已经不使用的内存&#34; class=&#34;headerlink&#34; title=&#34;什么情况会引起内存泄漏(无法释放已经不使用的内存)?&#34;&gt;&lt;/a&gt;什么情况会引起内存泄漏(无法释放已经不使用的内存)?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、意外的全局变量引起的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：全局变量，不会被回收。&lt;br&gt;解决：使用严格模式避免。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2、闭包引起的内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：闭包可以维持函数内局部变量，使其得不到释放。&lt;br&gt;解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3、没有清理的DOM元素引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：虽然别的地方删除了，但是对象中还存在对dom的引用&lt;br&gt;解决：手动删除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4、被遗忘的定时器或者回调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。&lt;br&gt;解决：手动删除定时器和dom。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5、子元素存在引用引起的内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。&lt;br&gt;解决：手动删除清空。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.yexingcheng.com/algorithm/toTree/</guid>
            <title>扁平数据结构转tree</title>
            <link>https://www.yexingcheng.com/algorithm/toTree/</link>
            <category term="算法" scheme="https://www.yexingcheng.com/categories/algorithm/" />
            <category term="js" scheme="https://www.yexingcheng.com/tags/js/" />
            <category term="面试" scheme="https://www.yexingcheng.com/tags/%E9%9D%A2%E8%AF%95/" />
            <category term="算法" scheme="https://www.yexingcheng.com/tags/%E7%AE%97%E6%B3%95/" />
            <pubDate>Fri, 04 Nov 2022 10:11:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;题目要求&#34;&gt;&lt;a href=&#34;#题目要求&#34; class=&#34;headerlink&#34; title=&#34;题目要求&#34;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;首先来看下题目:打平的数据内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;let arr = [
    &amp;#123;id: 1, name: &amp;#39;部门1&amp;#39;, pid: 0&amp;#125;,
    &amp;#123;id: 2, name: &amp;#39;部门2&amp;#39;, pid: 1&amp;#125;,
    &amp;#123;id: 3, name: &amp;#39;部门3&amp;#39;, pid: 1&amp;#125;,
    &amp;#123;id: 4, name: &amp;#39;部门4&amp;#39;, pid: 3&amp;#125;,
    &amp;#123;id: 5, name: &amp;#39;部门5&amp;#39;, pid: 4&amp;#125;,
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想要的输出结果如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;[
    &amp;#123;
        &amp;quot;id&amp;quot;: 1,
        &amp;quot;name&amp;quot;: &amp;quot;部门1&amp;quot;,
        &amp;quot;pid&amp;quot;: 0,
        &amp;quot;children&amp;quot;: [
            &amp;#123;
                &amp;quot;id&amp;quot;: 2,
                &amp;quot;name&amp;quot;: &amp;quot;部门2&amp;quot;,
                &amp;quot;pid&amp;quot;: 1,
                &amp;quot;children&amp;quot;: []
            &amp;#125;,
            &amp;#123;
                &amp;quot;id&amp;quot;: 3,
                &amp;quot;name&amp;quot;: &amp;quot;部门3&amp;quot;,
                &amp;quot;pid&amp;quot;: 1,
                &amp;quot;children&amp;quot;: [
                    // 结果 ,,,
                ]
            &amp;#125;
        ]
    &amp;#125;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先我们要了解一个概念，衡量一个算法的好坏，主要看算法的时间复杂度和空间复杂度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 随着n的不断增大，时间复杂度不断增大，算法花费时间越多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;时间复杂度&#34;&gt;&lt;a href=&#34;#时间复杂度&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度&#34;&gt;&lt;/a&gt;时间复杂度&lt;/h2&gt;&lt;h3 id=&#34;计算方法&#34;&gt;&lt;a href=&#34;#计算方法&#34; class=&#34;headerlink&#34; title=&#34;计算方法&#34;&gt;&lt;/a&gt;计算方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;选取相对增长最高的项&lt;/li&gt;
&lt;li&gt;最高项系数是都化为1&lt;/li&gt;
&lt;li&gt;若是常数的话用O(1)表示 举个例子：如f(n)&amp;#x3D;3*n^4+3n+300 则 O(n)&amp;#x3D;n^4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 举例如下：代码执行100次，是一个常数，复杂度也是O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    let x = 1;
    while (x &amp;lt;100) &amp;#123;
     x++;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;  for (i = 0; i &amp;lt; n; i++)&amp;#123;
         for (j = 0; j &amp;lt; n; j++) &amp;#123;
             // ...code
         &amp;#125;
     &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;循环不仅与n有关，还与执行循环判断条件有关。举例如下：在代码中，如果arr[i]不等于1的话，时间复杂度是O(n)。如果arr[i]等于1的话，循环不执行，时间复杂度是O(0)。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    for(var i = 0; i&amp;lt;n &amp;amp;&amp;amp; arr[i] !=1; i++) &amp;#123;
    // ...code
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;空间复杂度&#34;&gt;&lt;a href=&#34;#空间复杂度&#34; class=&#34;headerlink&#34; title=&#34;空间复杂度&#34;&gt;&lt;/a&gt;空间复杂度&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;计算方法-1&#34;&gt;&lt;a href=&#34;#计算方法-1&#34; class=&#34;headerlink&#34; title=&#34;计算方法&#34;&gt;&lt;/a&gt;计算方法&lt;/h3&gt;&lt;p&gt;1、 忽略常数，用O(1)表示&lt;/p&gt;
&lt;p&gt;2、 递归算法的空间复杂度 &amp;#x3D; （递归深度n）*(每次递归所要的辅助空间)&lt;/p&gt;
&lt;p&gt;计算空间复杂度的简单几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅仅只复制单个变量，空间复杂度为O(1)。 以下例子空间复杂度为O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;   let a = 1;
   let b = 2;
   let c = 3;
   console.log(&amp;#39;输出a,b,c&amp;#39;, a, b, c);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;递归实现，调用fun函数，每次都创建一个变量K，调用n次，空间复杂度O(n*1) &amp;#x3D; O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;    function fun(n) &amp;#123;
       let k = 10;
       if (n == k) &amp;#123;
           return n;
       &amp;#125; else &amp;#123;
           return fun(++n)
       &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;不考虑性能实现，递归遍历查找&#34;&gt;&lt;a href=&#34;#不考虑性能实现，递归遍历查找&#34; class=&#34;headerlink&#34; title=&#34;不考虑性能实现，递归遍历查找&#34;&gt;&lt;/a&gt;不考虑性能实现，递归遍历查找&lt;/h1&gt; ]]></description>
        </item>
    </channel>
</rss>
