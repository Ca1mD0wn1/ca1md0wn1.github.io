<!-- build time:Fri Nov 04 2022 09:56:55 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="永不陨落的星辰" href="https://www.yexingcheng.com/atom.xml"><link rel="alternate" type="application/json" title="永不陨落的星辰" href="https://www.yexingcheng.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="js,react,面试,vue"><link rel="canonical" href="https://www.yexingcheng.com/interview/interview/"><title>面试题总结 - 面试用 | 永不陨落的星辰 = 永不陨落的星辰</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">面试题总结</h1><div class="meta"><span class="item" title="创建时间：2022-10-01 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-01T00:00:00+08:00">2022-10-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">永不陨落的星辰</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/interview/" itemprop="item" rel="index" title="分类于 面试用"><span itemprop="name">面试用</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.yexingcheng.com/interview/interview/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="叶星辰"><meta itemprop="description" content=", 温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="永不陨落的星辰"></span><div class="body md" itemprop="articleBody"><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h3 id="柯里化和反柯里化"><a href="#柯里化和反柯里化" class="headerlink" title="柯里化和反柯里化"></a>柯里化和反柯里化</h3><blockquote><p>柯里化，可以理解为<strong>提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数</strong>。因为这样的特性，也被称为部分计算函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。</p><p>反柯里化，是一个<strong>泛型化</strong>的过程。它使得被反柯里化的函数，可以<strong>接收更多参数</strong>。目的是创建一个更普适性的函数，可以被不同的对象使用。有鸠占鹊巢的效果。</p></blockquote><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><blockquote><p>async声明一个function来表示这个异步函数，await用于等待函数中某个异步操作执行完成。</p></blockquote><h3 id="对象类型的数组去重"><a href="#对象类型的数组去重" class="headerlink" title="对象类型的数组去重"></a>对象类型的数组去重</h3><pre><code class="js">let arr = [
  &#123;
    key: &#39;1&#39;,
    name: &#39;林青霞&#39;
  &#125;,
  &#123;
    key: &#39;2&#39;,
    name: &#39;张三丰&#39;
  &#125;,
  &#123;
    key: &#39;1&#39;,
    name: &#39;段誉&#39;
  &#125;,
]
let obj = &#123;&#125;
let res = arr.reduce(function (preValue, item) &#123;
  obj[item.key] ? &#39;&#39; : obj[item.key] = true &amp;&amp; preValue.push(item);
  return preValue
&#125;, [])//将返回值的初始值定义为空数组
console.log(res, &#39;===&#39;)//打印去重之后的数组
</code></pre><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><blockquote><p>箭头函数不会创建自己的<code>this</code>，所以它没有自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。</p><p>箭头函数中的this指向永远不变</p><p>而箭头函数就不可以使用<code>arguments</code>对象，获取不到输入的参数。</p><p>使用场景</p></blockquote><p>判断一个变量类型的方式</p><blockquote><p>&#x2F;&#x2F;typeof</p><pre><code class="js">console.log(typeof a);    //&#39;undefined&#39;    
console.log(typeof(true));  //&#39;boolean&#39;    
console.log(typeof &#39;123&#39;);  //&#39;string&#39;   
console.log(typeof 123);   //&#39;number&#39;    
console.log(typeof NaN);   //&#39;number&#39;    
console.log(typeof null);  //&#39;object&#39;       
var obj = new String();    console.log(typeof(obj));    //&#39;object&#39;    
var  fn = function()&#123;&#125;;    console.log(typeof(fn));  //&#39;function&#39;    
console.log(typeof(class c&#123;&#125;));  //&#39;function&#39;
</code></pre><p>&#x2F;&#x2F;instanceof</p><pre><code class="js">var arr = []

// example
var arr = [];

//由于：
arr.constructor === Array
arr.__proto__ === Array.prototype
arr.__poto__.proto__ === Object.prototype

//所以, 以下都返回true
arr instanceof arr.constructor(Array)
arr instanceof arr.__proto__.constructor(Array)
arr instanceof arr.__proto__.__poto__.constructor(Object)
</code></pre><pre><code class="js">console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String]
console.log(Object.prototype.toString.call(12));//[object Number]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call(&#123;name: &quot;jerry&quot;&#125;));//[object Object]
console.log(Object.prototype.toString.call(function()&#123;&#125;));//[object Function]
console.log(Object.prototype.toString.call([]));//[object Array]
console.log(Object.prototype.toString.call(new Date));//[object Date]
console.log(Object.prototype.toString.call(/\d/));//[object RegExp]
function Person()&#123;&#125;;
console.log(Object.prototype.toString.call(new Person));//[object Object]
</code></pre><p>constructor</p><pre><code class="js">function a() &#123;&#125;
let a = new b;
console.log(a.constructor.name);//a
console.log(b.constructor);//Function（）&#123;&#125;
console.log(Function.constructor);//Function（）&#123;&#125;
</code></pre></blockquote><p>ES5和ES6继承的区别</p><blockquote><p>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上<br>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改 this。<br>ES5 的继承时通过原型或构造函数机制来实现。<br>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。 子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。 super 关键字指代父类的实例，即父类的 this 对象。 在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。<br>ES5的构造函数可以不进行构造调用即可以当普通函数使用，而ES6的class只能通过new来调用。<br>class的所有方法（包括静态方法和实例方法）都是不可枚举的且都没有原型对象 prototype，所以也没有[[constructor]]，不能使用 new 来调用</p></blockquote><p>事件循环</p><blockquote></blockquote><p>promise</p><blockquote><p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：</p><p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p><p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p><p>但是请注意以下两点：</p><ul><li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li><li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li></ul></blockquote><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h3 id="vue3的缺点"><a href="#vue3的缺点" class="headerlink" title="vue3的缺点"></a>vue3的缺点</h3><blockquote></blockquote><h3 id="vue命名路由"><a href="#vue命名路由" class="headerlink" title="vue命名路由"></a>vue命名路由</h3><pre><code class="json">  &#123;
    path: &quot;/&quot;,//重定向
    redirect: &quot;/home&quot;,
  &#125;,
&#125;
    path: &quot;/home&quot;, // 地址栏地址 - 路由
    name: &quot;home&quot;, // 命名路由  ---   唯一性
    components: &#123;
      default: HomeView,
      footer: Footer
    &#125;, // 路由映射的页面组件
    //页面中
 &lt;router-view name = &quot;default&quot;/&gt;
 &lt;router-view name = &quot;footer&quot;/&gt;
</code></pre><h3 id="浏览器渲染的过程"><a href="#浏览器渲染的过程" class="headerlink" title="浏览器渲染的过程"></a>浏览器渲染的过程</h3><blockquote><p>处理HTML 标记并构建DOM 树。<br>处理CSS 标记并构建CSSOM 树。<br>将DOM 与CSSOM 合并成一个渲染树。<br>根据渲染树来布局，计算每个节点的几何信息。<br>将各个节点绘制到屏幕上。</p></blockquote><h3 id="vue3自定义指令"><a href="#vue3自定义指令" class="headerlink" title="vue3自定义指令"></a>vue3自定义指令</h3><pre><code class="vue">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt;
    &lt;input v-focus&gt;
&lt;/div&gt;
 
&lt;script&gt;
const app = Vue.createApp(&#123;&#125;)
// 注册一个全局自定义指令 `v-focus`
app.directive(&#39;focus&#39;, &#123;
  // 当被绑定的元素挂载到 DOM 中时……
  mounted(el) &#123;
    // 聚焦元素
    el.focus()
  &#125;
&#125;)
app.mount(&#39;#app&#39;)
&lt;/script&gt;
</code></pre><h3 id="v-clock和v-pre"><a href="#v-clock和v-pre" class="headerlink" title="v-clock和v-pre"></a>v-clock和v-pre</h3><blockquote><p>v-clock在编译成功后会删除，可以使用属性选择器解决加载闪烁问题<br>v-pre会阻止编译，有此指令的的标签内部的内容不会被编译，会原样输出</p></blockquote><h3 id="为什么需要状态管理器？"><a href="#为什么需要状态管理器？" class="headerlink" title="为什么需要状态管理器？"></a>为什么需要状态管理器？</h3><blockquote><p>多个视图依赖同一个状态多个</p><p>视图都需要变更状态</p><p>例如：各个组件都需要检测用户登录状态</p></blockquote><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><blockquote><p>三大类：全局 组件内 路由独享</p></blockquote><h3 id="Vue单页面优缺点"><a href="#Vue单页面优缺点" class="headerlink" title="Vue单页面优缺点"></a>Vue单页面优缺点</h3><blockquote><p>一旦页面加载完成，SPA不会因为用户操作而进行页面重新加载或跳转，取而代之的是利用路由机制实现Html内容的变换。<br>优点：</p><p>用户体验好、快，内容改变不需要加载整个页面，对服务器压力小<br>前后端分离 完全的前端组件化，代码结构和组织方式更加规范化，便于修改和调整</p><p>缺点：</p><p>首次加载页面需大量加载静态资源，时间相对比较长 不利于seo优化，单页面数据在前端渲染意味着没有seo<br>页面导航不可用 如果要导航需要自行实现前进后退<br>页面复杂度提高很多</p></blockquote><h3 id="V-model的三个修饰符"><a href="#V-model的三个修饰符" class="headerlink" title="V-model的三个修饰符"></a>V-model的三个修饰符</h3><blockquote><p>1.lazy：可以等待用户敲回车或者输入框输入焦点时才将数据写到data中<br>（可以提高效率）接管 input 的事件监听事件，输入的时候不会马上响应在展示层，当数据确认改变的时候才会显示出来；<br>2.number：只有输入数字才会显示<br>（v-<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1tb2RlbCZzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA==">model</span>默认将输入的数字当成字符串类型，使用number就直接当成数字类型）<br>3.trim：去除左右两边多余空格</p></blockquote><h3 id="Vue的路由传参"><a href="#Vue的路由传参" class="headerlink" title="Vue的路由传参"></a>Vue的路由传参</h3><blockquote><p><strong>ue</strong> 路由传参的使用场景一般都是应用在父路由跳转到子路由时，携带参数跳转。传参方式可划分为 <code>params</code> 传参和 <code>query</code> 传参，而 <code>params</code> 传参又可分为在 <strong>url</strong> 中显示参数和不显示参数两种方式，这就是vue路由传参的三种方式。</p><h2 id="方式一：params-传参（显示参数）"><a href="#方式一：params-传参（显示参数）" class="headerlink" title="方式一：params 传参（显示参数）"></a>方式一：<code>params</code> 传参（显示参数）</h2><p>1、声明式 <code>router-link</code></p><pre><code class="vue">//子路由配置
&#123;
 path: &#39;/child/:id&#39;,
 component: Child
&#125;
//父路由组件
&lt;router-link :to=&quot;/child/123&quot;&gt;进入Child路由&lt;/router-link&gt;
</code></pre><p>2、编程式 <code>this.$router.push</code></p><pre><code class="vue">//子路由配置
&#123;
 path: &#39;/child/:id&#39;,
 component: Child
&#125;
//父路由编程式传参(一般通过事件触发)
this.$router.push(&#123;
   path:&#39;/child/$&#123;id&#125;&#39;,
&#125;)
</code></pre><p><strong>在子路由中可以通过下面代码来获取传递的参数值</strong></p><pre><code class="js">this.$route.params.id
</code></pre><h2 id="方式二：params-传参（不显示参数）"><a href="#方式二：params-传参（不显示参数）" class="headerlink" title="方式二：params 传参（不显示参数）"></a>方式二：<code>params</code> 传参（不显示参数）</h2><p>params 传参（不显示参数）也可分为 声明式 和 编程式 两种方式，与方式一不同的是，这里是通过路由的别名 name 进行传值的</p><p>1、声明式 router-link</p><p>该方式也是通过 router-link 组件的 to 属性实现，例如：</p><pre><code class="vue">&lt;router-link :to=&quot;&#123;name:&#39;Child&#39;,params:&#123;id:123&#125;&#125;&quot;&gt;进入Child路由&lt;/router-link&gt;
</code></pre><p>2、编程式 this.$router.push</p><p>使用该方式传值的时候，同样需要子路由提前配置好参数，不过不能再使用 :&#x2F;id 来传递参数了，因为父路由中，已经使用 params 来携带参数了，例如：</p><pre><code class="vue">//子路由配置
&#123;
 path: &#39;/child,
 name: &#39;Child&#39;,
 component: Child
&#125;
//父路由编程式传参(一般通过事件触发)
this.$router.push(&#123;
   name:&#39;Child&#39;,
   params:&#123;
    id:123
   &#125;
&#125;)
</code></pre><p>在子路由中可以通过下面代码来获取传递的参数值</p><pre><code class="vue">this.$route.params.id
</code></pre><p><strong>注意：上述这种利用 <code>params</code> 不显示 <code>url</code> 传参的方式会导致在刷新页面的时候，传递的值会丢失</strong></p><p>方式三：query 传参（显示参数）<br>query 传参（显示参数）也可分为 声明式 和 编程式 两种方式</p><p>1、声明式 router-link</p><p>该方式也是通过 router-link 组件的 to 属性实现，不过使用该方式传值的时候，需要子路由提前配置好路由别名（name 属性），例如：</p><pre><code>//子路由配置
&#123;
 path: &#39;/child,
 name: &#39;Child&#39;,
 component: Child
&#125;
//父路由组件
&lt;router-link :to=&quot;&#123;name:&#39;Child&#39;,query:&#123;id:123&#125;&#125;&quot;&gt;进入Child路由&lt;/router-link&gt;
</code></pre><p>2、编程式 this.$router.push</p><p>使用该方式传值的时候，同样需要子路由提前配置好路由别名（name 属性），例如：</p><pre><code>//子路由配置
&#123;
 path: &#39;/child,
 name: &#39;Child&#39;,
 component: Child
&#125;
//父路由编程式传参(一般通过事件触发)
this.$router.push(&#123;
   name:&#39;Child&#39;,
   query:&#123;
    id:123
   &#125;
&#125;)
</code></pre><p>在子路由中可以通过下面代码来获取传递的参数值</p><pre><code>this.$route.query.id
</code></pre></blockquote><p>Vue的路由模式</p><blockquote><p>Vue-Router有两个路由模式，分别是哈希hash模式和历史history模式，然后默认的是哈希hash模式。</p><p>hash模式是开发中默认的模式，它的URL带着一个#，例如：<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20vIy92dWUlRUYlQkMlOEMlRTUlQUUlODMlRTclOUElODRoYXNoJUU1JTgwJUJDJUU1JUIwJUIxJUU2JTk4JUFGIy92dWU=">www.baidu.com/#/vue，它的hash值就是#/vue</span></p><p>hash的值会出现再URL里面的，但是不会出现再HTTP请求之中的，也就是说，它并没有向后端发起请求，对后端是没有影响的</p><p>history模式的URL中没有#，它使用传统的路由分发模式，就是说用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的处理，也就是它向服务器发起了一个请求差不错</p></blockquote><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h3 id="严格模式的理解"><a href="#严格模式的理解" class="headerlink" title="严格模式的理解"></a>严格模式的理解</h3><blockquote><p>打开方式：React.StricMode<br>识别不安全的生命周期<br>关于使用过时字符串 ref API 的警告<br>关于使用废弃的 findDOMNode 方法的警告<br>检测意外的副作用<br>检测过时的 context API<br>确保可复用的状态 从 React 18 开始的严格模式，每当组件在开发中挂载时，React 会模拟立即卸载和重新挂载组件：在第二次挂载时，React 将恢复第一次装载时的状态。<br>卸载和重新挂载的函数，包括<br>componentDidMount<br>componentWillUnmount<br>useEffect<br>useLayoutEffect<br>useInsertionEffect<br>这只适用于开发模式，生产环境没有变化。</p></blockquote><h3 id="react修改状态对象和函数的不同之处"><a href="#react修改状态对象和函数的不同之处" class="headerlink" title="react修改状态对象和函数的不同之处"></a>react修改状态对象和函数的不同之处</h3><blockquote><p>对象会合并，this.setState() 的第一个参数也可以是函数，这个函数接收两个参数：<br>第一个参数为更新前的状态值，第二个参数为 props（可获取父级组件传递的数据）；当修改状态时涉及到前一个状态值时就可以使用这种形式。<br>函数会拿到上一次状态结果的值</p></blockquote><h3 id="React事件绑定的原理"><a href="#React事件绑定的原理" class="headerlink" title="React事件绑定的原理"></a>React事件绑定的原理</h3><blockquote><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p></blockquote><h3 id="Reack状态提示以及使用场景"><a href="#Reack状态提示以及使用场景" class="headerlink" title="Reack状态提示以及使用场景"></a>Reack状态提示以及使用场景</h3><blockquote><p>实现方式是 利用最近的共同的父级组件中，用<code>props</code>的方式传过去到两个子组件，<code>props</code>中传的是一个<code>setState</code>的方法，通过子组件触发<code>props</code>传过去的方法，进而调用父级组件的<code>setState</code>的方法，改变了父级组件的<code>state</code>，调用父级组件的<code>add</code>方法，进而同时改变了两个子级组件的<code>数据</code>。</p><p>这是 两个有关连的<strong>同级组件</strong>的传值，因为<code>react</code>的单项数据流，所以不在两个组件中进行传值，而是提升到 最近的共同的父级组件中，改变父级的<code>state</code>,进而影响了两个子级组件的<code>render</code>。</p><p>组件之间状态共享</p></blockquote><h3 id="React高阶组件"><a href="#React高阶组件" class="headerlink" title="React高阶组件"></a>React高阶组件</h3><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p></blockquote><h3 id="React路由跳转-路由传参-路由拿到参数"><a href="#React路由跳转-路由传参-路由拿到参数" class="headerlink" title="React路由跳转 路由传参 路由拿到参数"></a>React路由跳转 路由传参 路由拿到参数</h3><blockquote></blockquote><h3 id="React组件优化-类组件-函数式组件"><a href="#React组件优化-类组件-函数式组件" class="headerlink" title="React组件优化 类组件 函数式组件"></a>React组件优化 类组件 函数式组件</h3><blockquote><p>类组件中：</p><p>继承Component改为React.PureComponent 或者用shouldComponentUpdate</p><p>某一个组件内部所有的数据都来源于父级，子组件只负责渲染，如果数据不变就不重新渲染</p><h3 id="React-memo-基本使用"><a href="#React-memo-基本使用" class="headerlink" title="React.memo 基本使用"></a>React.memo 基本使用</h3><p>将函数组件变成纯组件，将当前props 和上一次的 props 进行浅层比较，如果相同就阻止组件重新渲染</p><p>组件懒加载</p><p>组件创建错误边界</p></blockquote><p>React状态管理器有哪几个，rtk的流程</p><blockquote></blockquote><p>React中类组件和函数式组件的区别</p><blockquote></blockquote><div class="tags"><a href="/tags/js/" rel="tag"><i class="ic i-tag"></i> js</a> <a href="/tags/react/" rel="tag"><i class="ic i-tag"></i> react</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="ic i-tag"></i> 面试</a> <a href="/tags/vue/" rel="tag"><i class="ic i-tag"></i> vue</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-25 00:00:00" itemprop="dateModified" datetime="2022-10-25T00:00:00+08:00">2022-10-25</time> </span><span id="interview/interview/" class="item leancloud_visitors" data-flag-title="面试题总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 联系我</button><p>来交朋友吧！</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="叶星辰 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="叶星辰 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="叶星辰 QQ"><p>QQ</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>叶星辰 <i class="ic i-at"><em>@</em></i>永不陨落的星辰</li><li class="link"><strong>本文链接：</strong> <a href="https://www.yexingcheng.com/interview/interview/" title="面试题总结">https://www.yexingcheng.com/interview/interview/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/react-study/8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="React学习第八天"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> react学习</span><h3>React学习第八天</h3></a></div><div class="item right"><a href="/interview/programming/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="编程题总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 面试用</span><h3>编程题总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%92%8C%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">1.0.1.</span> <span class="toc-text">柯里化和反柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait"><span class="toc-number">1.0.2.</span> <span class="toc-text">async和await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.0.3.</span> <span class="toc-text">对象类型的数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">2.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.0.1.</span> <span class="toc-text">vue3的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="toc-number">2.0.2.</span> <span class="toc-text">vue命名路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.3.</span> <span class="toc-text">浏览器渲染的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">vue3自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-clock%E5%92%8Cv-pre"><span class="toc-number">2.0.5.</span> <span class="toc-text">v-clock和v-pre</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%9F"><span class="toc-number">2.0.6.</span> <span class="toc-text">为什么需要状态管理器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">2.0.7.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.0.8.</span> <span class="toc-text">Vue单页面优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-model%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.0.9.</span> <span class="toc-text">V-model的三个修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">2.0.10.</span> <span class="toc-text">Vue的路由传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Aparams-%E4%BC%A0%E5%8F%82%EF%BC%88%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">方式一：params 传参（显示参数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aparams-%E4%BC%A0%E5%8F%82%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">方式二：params 传参（不显示参数）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-number">3.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.0.1.</span> <span class="toc-text">严格模式的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.0.2.</span> <span class="toc-text">react修改状态对象和函数的不同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.3.</span> <span class="toc-text">React事件绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reack%E7%8A%B6%E6%80%81%E6%8F%90%E7%A4%BA%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.0.4.</span> <span class="toc-text">Reack状态提示以及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">3.0.5.</span> <span class="toc-text">React高阶组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82-%E8%B7%AF%E7%94%B1%E6%8B%BF%E5%88%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.0.6.</span> <span class="toc-text">React路由跳转 路由传参 路由拿到参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E4%BC%98%E5%8C%96-%E7%B1%BB%E7%BB%84%E4%BB%B6-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">3.0.7.</span> <span class="toc-text">React组件优化 类组件 函数式组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-memo-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.8.</span> <span class="toc-text">React.memo 基本使用</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/interview/programming/" rel="bookmark" title="编程题总结">编程题总结</a></li><li class="active"><a href="/interview/interview/" rel="bookmark" title="面试题总结">面试题总结</a></li><li><a href="/interview/Array.Methods/" rel="bookmark" title="JS中数组方法总结">JS中数组方法总结</a></li><li><a href="/interview/Currying/" rel="bookmark" title="详解柯里化和反柯里化">详解柯里化和反柯里化</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="叶星辰" data-src="/images/avatar.jpg"><p class="name" itemprop="name">叶星辰</p><div class="description" itemprop="description">温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhMW1EMHduMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Ca1mD0wn1"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9VZmRIbw==" title="https:&#x2F;&#x2F;twitter.com&#x2F;UfdHo"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tZW5nLXhpbmcteW91LWppLXNpLXl1ZS1odWFuZy0yNw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;meng-xing-you-ji-si-yue-huang-27"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTUwMjkxOTQ0NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;502919445"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NTc4MjU1ODg1" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7578255885"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="aHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvI2luYm94" title="https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;u&#x2F;0&#x2F;#inbox"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/react-study/8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/interview/programming/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/6/" title="vue-mobile项目开发流程第六部分(构建home页面)">vue-mobile项目开发流程第六部分(构建home页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Screeps/" title="分类于 screeps">screeps</a></div><span><a href="/Screeps/action1/" title="screeps日记 part1">screeps日记 part1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/8/" title="vue-mobile项目开发流程第八部分(构建register页面)">vue-mobile项目开发流程第八部分(构建register页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/8/" title="React学习第八天">React学习第八天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 微信小程序">微信小程序</a></div><span><a href="/wx-app/day1/" title="微信小程序学习第一天">微信小程序学习第一天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/9/" title="vue-mobile项目开发流程第九部分(构建login页面)">vue-mobile项目开发流程第九部分(构建login页面)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/3/" title="React学习第三天">React学习第三天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="分类于 vue3移动端项目开发">vue3移动端项目开发</a></div><span><a href="/vue-mobile/3/" title="vue-mobile项目开发流程第三部分(TS与选项式API)">vue-mobile项目开发流程第三部分(TS与选项式API)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/react%E5%AD%A6%E4%B9%A0/" title="分类于 react学习">react学习</a></div><span><a href="/react-study/5/" title="React学习第五天">React学习第五天</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面试用">面试用</a></div><span><a href="/interview/Array.Methods/" title="JS中数组方法总结">JS中数组方法总结</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">叶星辰 @ 永不陨落的星辰</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">615k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/interview/",favicon:{show:"星辰",hide:"你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/miku.model.json"},display:{position:"right",width:250,height:500},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by hrmmi -->