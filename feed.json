{
    "version": "https://jsonfeed.org/version/1",
    "title": "永不陨落的星辰",
    "subtitle": "",
    "icon": "https://www.yexingcheng.com/images/favicon.ico",
    "description": "温柔正确的人总是难以生存，因为这个世界既不温柔 也不正确",
    "home_page_url": "https://www.yexingcheng.com",
    "items": [
        {
            "id": "https://www.yexingcheng.com/interview/wrapper-object/",
            "url": "https://www.yexingcheng.com/interview/wrapper-object/",
            "title": "js中包装对象",
            "date_published": "2022-11-08T13:08:22.631Z",
            "content_html": "<h1 id=\"先来看定义\"><a href=\"#先来看定义\" class=\"headerlink\" title=\"先来看定义\"></a>先来看定义</h1><p>对象是javascript语言最主要的数据类型，三种原始类型的值————Number,string,boolean在一定条件下，也会自动转为对象，也就是原始类型的<code>包装对象</code>(wrapper)</p>\n<p>所谓<code>包装对象</code> 指的是Number,string,boolean分别对应的Number,String,Boolean三个原生对象。这三个原生对象可以把原始类型的值变成(包装成)对象</p>\n<pre><code class=\"js\">var v1 = new Number(123);\nvar v2 = new String(&#39;abc&#39;);\nvar v3 = new Boolean(true);\n\ntypeof v1 // &quot;object&quot;\ntypeof v2 // &quot;object&quot;\ntypeof v3 // &quot;object&quot;\n\nv1 === 123 // false\nv2 === &#39;abc&#39; // false\nv3 === true // false\n</code></pre>\n<p>面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，v1、v2、v3都是对象，且与对应的简单类型值不相等。</p>\n<p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</p>\n<p><code>Number</code>、<code>String</code>和<code>Boolean</code>这三个原生对象，如果不作为构造函数调用（即调用时不加new），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。</p>\n<pre><code class=\"js\">// 字符串转为数值\nNumber(&#39;123&#39;) // 123\n\n// 数值转为字符串\nString(123) // &quot;123&quot;\n\n// 数值转为布尔值\nBoolean(123) // true\n</code></pre>\n<p>总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p>\n<h1 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h1><p>三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从Object对象继承的方法:<code>valueOf()</code>和<code>toString()</code></p>\n<ul>\n<li>valueOf()<br><code>valueOf()</code>方法返回包装对象实例对应的原始类型的值。</li>\n</ul>\n<pre><code class=\"js\">new Number(123).valueOf()  // 123\nnew String(&#39;abc&#39;).valueOf() // &quot;abc&quot;\nnew Boolean(true).valueOf() // true\n</code></pre>\n<ul>\n<li>toString()<br><code>toString()</code>方法返回对应的字符串形式</li>\n</ul>\n<pre><code class=\"js\">new Number(123).toString() // &quot;123&quot;\nnew String(&#39;abc&#39;).toString() // &quot;abc&quot;\nnew Boolean(true).toString() // &quot;true&quot;\n</code></pre>\n<h2 id=\"原始类型与实例对象的自动转换\"><a href=\"#原始类型与实例对象的自动转换\" class=\"headerlink\" title=\"原始类型与实例对象的自动转换\"></a>原始类型与实例对象的自动转换</h2><p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p>\n<p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。</p>\n<pre><code class=\"js\">&#39;abc&#39;.length // 3\n</code></pre>\n<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换</p>\n<pre><code class=\"js\">var str = &#39;abc&#39;;\nstr.length // 3\n\n// 等同于\nvar strObj = new String(str)\n// String &#123;\n//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;\n// &#125;\nstrObj.length // 3\n</code></pre>\n<p>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p>\n<pre><code class=\"js\">var s = &#39;Hello World&#39;;\ns.x = 123;\ns.x // undefined\n</code></pre>\n<p>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。</p>\n<h2 id=\"自定义方法\"><a href=\"#自定义方法\" class=\"headerlink\" title=\"自定义方法\"></a>自定义方法</h2><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p>\n<p>比如，我们可以新增一个double方法，使得字符串和数字翻倍。</p>\n<pre><code class=\"js\">String.prototype.double = function () &#123;\n  return this.valueOf() + this.valueOf();\n&#125;;\n\n&#39;abc&#39;.double() // abcabc\n\nNumber.prototype.double = function () &#123;\n  return this.valueOf() + this.valueOf();\n&#125;;\n\n(123).double() // 246\n</code></pre>\n<p>上面代码在String和Number这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后的123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。</p>\n<h1 id=\"Boolean对象\"><a href=\"#Boolean对象\" class=\"headerlink\" title=\"Boolean对象\"></a>Boolean对象</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述:\"></a>概述:</h2><p>Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p>\n<pre><code class=\"js\">var b = new Boolean(true);\n\ntypeof b // &quot;object&quot;\nb.valueOf() // true\n</code></pre>\n<p>上面代码的变量b是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>。</p>\n<p>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code>。</p>\n<pre><code class=\"js\">if (new Boolean(false)) &#123;\n  console.log(&#39;true&#39;);\n&#125; // true\n\nif (new Boolean(false).valueOf()) &#123;\n  console.log(&#39;true&#39;);\n&#125; // 无输出\n</code></pre>\n<p>上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始值，本例为false。</p>\n<h2 id=\"Boolean-函数的类型转换作用\"><a href=\"#Boolean-函数的类型转换作用\" class=\"headerlink\" title=\"Boolean 函数的类型转换作用\"></a>Boolean 函数的类型转换作用</h2><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法。</p>\n<pre><code class=\"js\">Boolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean(&#39;&#39;) // false\nBoolean(NaN) // false\n\nBoolean(1) // true\nBoolean(&#39;false&#39;) // true\nBoolean([]) // true\nBoolean(&#123;&#125;) // true\nBoolean(function () &#123;&#125;) // true\nBoolean(/foo/) // true\n</code></pre>\n<p>上面代码中几种得到true的情况，都值得认真记住。</p>\n<p>顺便提一下，使用双重的否运算符（!）也可以将任意值转为对应的布尔值。</p>\n<pre><code class=\"js\">!!undefined // false\n!!null // false\n!!0 // false\n!!&#39;&#39; // false\n!!NaN // false\n\n!!1 // true\n!!&#39;false&#39; // true\n!![] // true\n!!&#123;&#125; // true\n!!function()&#123;&#125; // true\n!!/foo/ // true\n</code></pre>\n<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p>\n<pre><code class=\"js\">if (Boolean(false)) &#123;\n  console.log(&#39;true&#39;);\n&#125; // 无输出\n\nif (new Boolean(false)) &#123;\n  console.log(&#39;true&#39;);\n&#125; // true\n\nif (Boolean(null)) &#123;\n  console.log(&#39;true&#39;);\n&#125; // 无输出\n\nif (new Boolean(null)) &#123;\n  console.log(&#39;true&#39;);\n&#125; // true\n</code></pre>\n<h1 id=\"Number-对象\"><a href=\"#Number-对象\" class=\"headerlink\" title=\"Number 对象\"></a>Number 对象</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p>\n<p>作为构造函数时，它用于生成值为数值的对象。</p>\n<pre><code class=\"js\">var n = new Number(1);\ntypeof n // &quot;object&quot;\n</code></pre>\n<p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为1的对象。</p>\n<p>作为工具函数时，它可以将任何类型的值转为数值。</p>\n<pre><code class=\"js\">Number(true) // 1\n</code></pre>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><p><code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）。</p>\n<ul>\n<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向Infinity。</li>\n<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向-Infinity。</li>\n<li><code>Number.NaN</code>：表示非数值，指向NaN。</li>\n<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应- 的，最接近0的负数为-<code>Number.MIN_VALUE</code>。</li>\n<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即9007199254740991。</li>\n<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即-9007199254740991。</li>\n</ul>\n<p>实例方法<br><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关。</p>\n<p><strong>Number.prototype.toString()</strong><br><code>Numbe</code>r对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式。</p>\n<pre><code class=\"js\">(10).toString() // &quot;10&quot;\n</code></pre>\n<p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p>\n<pre><code class=\"js\">(10).toString(2) // &quot;1010&quot;\n(10).toString(8) // &quot;12&quot;\n(10).toString(16) // &quot;a&quot;\n</code></pre>\n<p>上面代码中，10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p>\n<pre><code class=\"js\">10.toString(2)\n// SyntaxError: Unexpected token ILLEGAL\n</code></pre>\n<p>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为10加上括号，还可以在<code>10</code>后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。</p>\n<pre><code class=\"js\">10..toString(2) // &quot;1010&quot;\n\n// 其他方法还包括\n10 .toString(2) // &quot;1010&quot;\n10.0.toString(2) // &quot;1010&quot;\n</code></pre>\n<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法。</p>\n<pre><code class=\"js\">10.5.toString() // &quot;10.5&quot;\n10.5.toString(2) // &quot;1010.1&quot;\n10.5.toString(8) // &quot;12.4&quot;\n10.5.toString(16) // &quot;a.8&quot;\n</code></pre>\n<p>通过方括号运算符也可以调用<code>toString</code>方法。</p>\n<pre><code class=\"js\">10[&#39;toString&#39;](2) // &quot;1010&quot;\n</code></pre>\n<p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法。</p>\n<p><strong>Number.prototype.toFixed()</strong></p>\n<p>toPrecision方法用于将一个数转为指定位数的有效数字。</p>\n<pre><code class=\"js\">(12.34).toPrecision(1) // &quot;1e+1&quot;\n(12.34).toPrecision(2) // &quot;12&quot;\n(12.34).toPrecision(3) // &quot;12.3&quot;\n(12.34).toPrecision(4) // &quot;12.34&quot;\n(12.34).toPrecision(5) // &quot;12.340&quot;\n</code></pre>\n<p><code>toPrecision</code>方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出<code>RangeError</code>错误。</p>\n<p><code>toPrecision</code>方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p>\n<pre><code class=\"js\">(12.35).toPrecision(3) // &quot;12.3&quot;\n(12.25).toPrecision(3) // &quot;12.3&quot;\n(12.15).toPrecision(3) // &quot;12.2&quot;\n(12.45).toPrecision(3) // &quot;12.4&quot;\n</code></pre>\n<h1 id=\"String-对象\"><a href=\"#String-对象\" class=\"headerlink\" title=\"String 对象\"></a>String 对象</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p>\n<pre><code class=\"js\">var s1 = &#39;abc&#39;;\nvar s2 = new String(&#39;abc&#39;);\n\ntypeof s1 // &quot;string&quot;\ntypeof s2 // &quot;object&quot;\n\ns2.valueOf() // &quot;abc&quot;\n</code></pre>\n<p>字符串对象是一个类似数组的对象（很像数组，但不是数组）。</p>\n<pre><code class=\"js\">new String(&#39;abc&#39;)\n// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;\n\n(new String(&#39;abc&#39;))[1] // &quot;b&quot;\n</code></pre>\n<h2 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h2><p><strong>String.prototype.length</strong><br>字符串实例的length属性返回字符串的长度。</p>\n<pre><code class=\"js\">&#39;abc&#39;.length // 3\n</code></pre>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法:\"></a>静态方法:</h2><p><strong>String.prototype.match()</strong></p>\n<p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。</p>\n<pre><code class=\"js\">&#39;cat, bat, sat, fat&#39;.match(&#39;at&#39;) // [&quot;at&quot;]\n&#39;cat, bat, sat, fat&#39;.match(&#39;xt&#39;) // null\n</code></pre>\n<p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。</p>\n<pre><code class=\"js\">var matches = &#39;cat, bat, sat, fat&#39;.match(&#39;at&#39;);\nmatches.index // 1\nmatches.input // &quot;cat, bat, sat, fat&quot;\nmatch方法还可以使用正则表达式作为参数。\n</code></pre>\n<p><strong>String.prototype.localeCompare()</strong></p>\n<p><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p>\n<pre><code class=\"js\">&#39;apple&#39;.localeCompare(&#39;banana&#39;) // -1\n&#39;apple&#39;.localeCompare(&#39;apple&#39;) // 0\n</code></pre>\n<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p>\n<pre><code class=\"js\">&#39;B&#39; &gt; &#39;a&#39; // false\n</code></pre>\n<p>上面代码中，字母B小于字母a。因为 JavaScript 采用的是 Unicode 码点比较，B的码点是<code>66</code>，而a的码点是<code>97</code>。</p>\n<p>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将B排在a的前面。</p>\n<pre><code class=\"js\">&#39;B&#39;.localeCompare(&#39;a&#39;) // 1\n</code></pre>\n<p>上面代码中，<code>localeCompare</code>方法返回整数1，表示B较大。</p>\n<p><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</p>\n<pre><code class=\"JS\">&#39;ä&#39;.localeCompare(&#39;z&#39;, &#39;de&#39;) // -1\n&#39;ä&#39;.localeCompare(&#39;z&#39;, &#39;sv&#39;) // 1\n</code></pre>\n<p>上面代码中，de表示德语，sv表示瑞典语。德语中，ä小于z，所以返回-1；瑞典语中，ä大于z，所以返回1。</p>\n",
            "tags": [
                "面试用",
                "js"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/interview/Variable-recycling/",
            "url": "https://www.yexingcheng.com/interview/Variable-recycling/",
            "title": "JS变量回收机制",
            "date_published": "2022-11-06T16:09:01.945Z",
            "content_html": "<h1 id=\"先看题目\"><a href=\"#先看题目\" class=\"headerlink\" title=\"先看题目:\"></a>先看题目:</h1><ol>\n<li><p>下列代码有几个变量没有被回收？<code>点我查看</code> [3]{.gap}。 {.quiz .fill}</p>\n<blockquote>\n<p>即i和add,局部变量有一个i，因为局部变量被另一个作用域引用，所以局部变量i也不回收</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"js\">var i = 1;\nvar i = 2;\nvar add = function() &#123;\n    var i = 0;\n    return function()\n&#123;\n        i++;\n        console.log(i);\n    &#125;\n&#125;();\nadd();\n</code></pre>\n<h1 id=\"变量回收原则\"><a href=\"#变量回收原则\" class=\"headerlink\" title=\"变量回收原则:\"></a>变量回收原则:</h1><ul>\n<li>全局变量不会回收</li>\n<li>局部变量会被回收,也就是函数一旦运行完后，函数内部的东西都会被销毁</li>\n<li>只要被另外一个作用域引用就不会被回收</li>\n</ul>\n<pre><code class=\"js\">var i = 1;   // 全局变量不会被回收\nvar i = 2;   // 这里重复声明变量i,因此var声明被忽略，只是把i赋值为2\nvar add = function() &#123;  // 全局变量不会被回收\n    var i = 0;  // 局部变量\n    return function() &#123;\n        i++;\n        console.log(i); // 被另一个作用域引用导致不会被回收\n    &#125;\n&#125;();\nadd();\n</code></pre>\n<h1 id=\"JS的垃圾回收机制\"><a href=\"#JS的垃圾回收机制\" class=\"headerlink\" title=\"JS的垃圾回收机制\"></a>JS的垃圾回收机制</h1><h2 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h2><blockquote>\n<p>js中最常见的垃圾回收方式是标记清除<br>标记清除就是从根部出发，看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它。<br>这个过程大致分为三步</p>\n</blockquote>\n<ul>\n<li>垃圾回收器创建roots列表,roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局变量window作为root,也就是所谓的跟部</li>\n<li>从根部出发检查所有的roots,所有的children也会被递归检查，能从root到达的都会被标记为active</li>\n<li>未被标记为active的数据被认定为不再需要，垃圾回收器开始释放他们</li>\n</ul>\n<p>注意:<br>当一个对象<code>零引用</code>时，我们从根部<code>一定无法到达</code>。<br>但反过来，从<code>根部无法到达</code>的<code>不一定</code>是严格意义上的零引用，比如循环引用，所以标记清除要<code>更优于引用计数</code>。</p>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>工作原理:工作原理：跟踪记录每个值被引用的次数。</p>\n<h2 id=\"什么情况会引起内存泄漏-无法释放已经不使用的内存\"><a href=\"#什么情况会引起内存泄漏-无法释放已经不使用的内存\" class=\"headerlink\" title=\"什么情况会引起内存泄漏(无法释放已经不使用的内存)?\"></a>什么情况会引起内存泄漏(无法释放已经不使用的内存)?</h2><blockquote>\n<p>虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。</p>\n</blockquote>\n<ul>\n<li>1、意外的全局变量引起的内存泄漏。</li>\n</ul>\n<p>原因：全局变量，不会被回收。<br>解决：使用严格模式避免。</p>\n<ul>\n<li>2、闭包引起的内存泄漏</li>\n</ul>\n<p>原因：闭包可以维持函数内局部变量，使其得不到释放。<br>解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。</p>\n<ul>\n<li>3、没有清理的DOM元素引用</li>\n</ul>\n<p>原因：虽然别的地方删除了，但是对象中还存在对dom的引用<br>解决：手动删除。</p>\n<ul>\n<li>4、被遗忘的定时器或者回调</li>\n</ul>\n<p>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。<br>解决：手动删除定时器和dom。</p>\n<ul>\n<li>5、子元素存在引用引起的内存泄漏</li>\n</ul>\n<p>原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。<br>解决：手动删除清空。</p>\n",
            "tags": [
                "面试用",
                "js"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/algorithm/toTree/",
            "url": "https://www.yexingcheng.com/algorithm/toTree/",
            "title": "扁平数据结构转tree",
            "date_published": "2022-11-04T02:11:00.788Z",
            "content_html": "<h1 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h1><p>首先来看下题目:打平的数据内容如下：</p>\n<pre><code class=\"javascript\">let arr = [\n    &#123;id: 1, name: &#39;部门1&#39;, pid: 0&#125;,\n    &#123;id: 2, name: &#39;部门2&#39;, pid: 1&#125;,\n    &#123;id: 3, name: &#39;部门3&#39;, pid: 1&#125;,\n    &#123;id: 4, name: &#39;部门4&#39;, pid: 3&#125;,\n    &#123;id: 5, name: &#39;部门5&#39;, pid: 4&#125;,\n]\n</code></pre>\n<p>我们想要的输出结果如下:</p>\n<pre><code class=\"json\">[\n    &#123;\n        &quot;id&quot;: 1,\n        &quot;name&quot;: &quot;部门1&quot;,\n        &quot;pid&quot;: 0,\n        &quot;children&quot;: [\n            &#123;\n                &quot;id&quot;: 2,\n                &quot;name&quot;: &quot;部门2&quot;,\n                &quot;pid&quot;: 1,\n                &quot;children&quot;: []\n            &#125;,\n            &#123;\n                &quot;id&quot;: 3,\n                &quot;name&quot;: &quot;部门3&quot;,\n                &quot;pid&quot;: 1,\n                &quot;children&quot;: [\n                    // 结果 ,,,\n                ]\n            &#125;\n        ]\n    &#125;\n]\n</code></pre>\n<p>首先我们要了解一个概念，衡量一个算法的好坏，主要看算法的时间复杂度和空间复杂度</p>\n<blockquote>\n<p>时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 随着n的不断增大，时间复杂度不断增大，算法花费时间越多。</p>\n</blockquote>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><h3 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><ul>\n<li>选取相对增长最高的项</li>\n<li>最高项系数是都化为1</li>\n<li>若是常数的话用O(1)表示 举个例子：如f(n)&#x3D;3*n^4+3n+300 则 O(n)&#x3D;n^4</li>\n</ul>\n<p>通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点</p>\n<ul>\n<li>如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 举例如下：代码执行100次，是一个常数，复杂度也是O(1)</li>\n</ul>\n<pre><code class=\"js\">    let x = 1;\n    while (x &lt;100) &#123;\n     x++;\n    &#125;\n</code></pre>\n<ul>\n<li>有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。</li>\n</ul>\n<pre><code class=\"js\">  for (i = 0; i &lt; n; i++)&#123;\n         for (j = 0; j &lt; n; j++) &#123;\n             // ...code\n         &#125;\n     &#125;\n</code></pre>\n<ul>\n<li>循环不仅与n有关，还与执行循环判断条件有关。举例如下：在代码中，如果arr[i]不等于1的话，时间复杂度是O(n)。如果arr[i]等于1的话，循环不执行，时间复杂度是O(0)。</li>\n</ul>\n<pre><code class=\"js\">    for(var i = 0; i&lt;n &amp;&amp; arr[i] !=1; i++) &#123;\n    // ...code\n    &#125;\n</code></pre>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><blockquote>\n<p>空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。</p>\n</blockquote>\n<h3 id=\"计算方法-1\"><a href=\"#计算方法-1\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><p>1、 忽略常数，用O(1)表示</p>\n<p>2、 递归算法的空间复杂度 &#x3D; （递归深度n）*(每次递归所要的辅助空间)</p>\n<p>计算空间复杂度的简单几点</p>\n<ul>\n<li>仅仅只复制单个变量，空间复杂度为O(1)。 以下例子空间复杂度为O(1)</li>\n</ul>\n<pre><code class=\"js\">   let a = 1;\n   let b = 2;\n   let c = 3;\n   console.log(&#39;输出a,b,c&#39;, a, b, c);\n</code></pre>\n<ul>\n<li>递归实现，调用fun函数，每次都创建一个变量K，调用n次，空间复杂度O(n*1) &#x3D; O(n)</li>\n</ul>\n<pre><code class=\"js\">    function fun(n) &#123;\n       let k = 10;\n       if (n == k) &#123;\n           return n;\n       &#125; else &#123;\n           return fun(++n)\n       &#125;\n    &#125;\n</code></pre>\n<h1 id=\"不考虑性能实现，递归遍历查找\"><a href=\"#不考虑性能实现，递归遍历查找\" class=\"headerlink\" title=\"不考虑性能实现，递归遍历查找\"></a>不考虑性能实现，递归遍历查找</h1>",
            "tags": [
                "面试用",
                "js",
                "面试",
                "算法"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/interview/Array.Methods/",
            "url": "https://www.yexingcheng.com/interview/Array.Methods/",
            "title": "JS中数组方法总结",
            "date_published": "2022-11-03T16:00:00.000Z",
            "content_html": "<h1 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h1><p>**<code>concat()</code>**此方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>一个或多个数组</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>一个新数组</p>\n<pre><code class=\"js\">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\nconst array2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];\nconst array3 = array1.concat(array2);\n\nconsole.log(array3);\n// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]\n</code></pre>\n<h1 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h1><p><strong><code>copyWithin()</code></strong> 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</p>\n<pre><code class=\"js\">copyWithin(target, start, end)\n</code></pre>\n<h2 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li><p><code>target</code></p>\n<p>0 为基底的索引，复制序列到该位置。如果是负数，<code>target</code> 将从末尾开始计算。如果 <code>target</code> 大于等于 <code>arr.length</code>，将不会发生拷贝。如果 <code>target</code> 在 <code>start</code> 之后，复制的序列将被修改以符合 <code>arr.length</code>。</p>\n</li>\n<li><p><code>start</code></p>\n<p>0 为基底的索引，开始复制元素的起始位置。如果是负数，<code>start</code> 将从末尾开始计算。如果 <code>start</code> 被忽略，<code>copyWithin</code> 将会从 0 开始复制。</p>\n</li>\n<li><p><code>end</code></p>\n<p>0 为基底的索引，开始复制元素的结束位置。<code>copyWithin</code> 将会拷贝到该位置，但不包括 <code>end</code> 这个位置的元素。如果是负数， <code>end</code> 将从末尾开始计算。如果 <code>end</code> 被忽略，<code>copyWithin</code> 方法将会一直复制至数组结尾（默认为 <code>arr.length</code>）。</p>\n</li>\n</ul>\n<h2 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值 :\"></a>返回值 :</h2><p>改变后的数组。</p>\n<pre><code class=\"js\">[1, 2, 3, 4, 5].copyWithin(-2)\n// [1, 2, 3, 1, 2]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1)\n// [1, 2, 3, 3, 4]\n</code></pre>\n<h1 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h1><p><strong><code>filter()</code></strong> 方法创建给定数组一部分的浅拷贝 ,其包含通过所提供函数实现的测试的所有元素。</p>\n<pre><code class=\"js\">// 箭头函数\nfilter((element) =&gt; &#123; /* … */ &#125; )\nfilter((element, index) =&gt; &#123; /* … */ &#125; )\nfilter((element, index, array) =&gt; &#123; /* … */ &#125; )\n\n// 回调函数\nfilter(callbackFn)\nfilter(callbackFn, thisArg)\n\n// 内联回调函数\nfilter(function(element) &#123; /* … */ &#125;)\nfilter(function(element, index) &#123; /* … */ &#125;)\nfilter(function(element, index, array)&#123; /* … */ &#125;)\nfilter(function(element, index, array) &#123; /* … */ &#125;, thisArg)\n</code></pre>\n<h2 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h2><pre><code>callbackFn\n</code></pre>\n<p>用来测试数组中每个元素的函数。返回 <code>true</code> 表示该元素通过测试，保留该元素，<code>false</code> 则不保留。它接受以下三个参数：</p>\n<ul>\n<li><p><code>element</code></p>\n<p>数组中当前正在处理的元素。</p>\n</li>\n<li><p><code>index</code></p>\n<p>正在处理的元素在数组中的索引。</p>\n</li>\n<li><p><code>array</code></p>\n<p>调用了 <code>filter()</code> 的数组本身。</p>\n</li>\n</ul>\n<p><code>thisArg</code>可选</p>\n<p>执行 <code>callbackFn</code> 时，用于 <code>this</code> 的值。</p>\n<h2 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>​\t一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>\n<h1 id=\"flat\"><a href=\"#flat\" class=\"headerlink\" title=\"flat()\"></a>flat()</h1><p><strong><code>flat()</code></strong> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>\n<pre><code class=\"js\">const arr1 = [0, 1, 2, [3, 4]];\n\nconsole.log(arr1.flat());\n// expected output: [0, 1, 2, 3, 4]\n\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr2.flat(2));\n// expected output: [0, 1, 2, [3, 4]]\n</code></pre>\n<h2 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li><p><code>depth</code> 可选</p>\n<p>指定要提取嵌套数组的结构深度，默认值为 1。</p>\n</li>\n</ul>\n<h2 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>一个包含将数组与子数组中所有元素的新数组。</p>\n<h1 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap()\"></a>flatMap()</h1><p><strong><code>flatMap()</code></strong> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFw\">map</span> 连着深度值为 1 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdA==\">flat</span> 几乎相同，但 <code>flatMap</code> 通常在合并成一种方法的效率稍微高一些。</p>\n<pre><code class=\"js\">const arr1 = [1, 2, [3], [4, 5], 6, []];\n\nconst flattened = arr1.flatMap(num =&gt; num);\n\nconsole.log(flattened);\n// expected output: Array [1, 2, 3, 4, 5, 6]\n</code></pre>\n<h2 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li><p><code>callback</code></p>\n<p>可以生成一个新数组中的元素的函数，可以传入三个参数：<code>currentValue</code>当前正在数组中处理的元素<code>index</code>可选可选的。数组中正在处理的当前元素的索引。<code>array</code>可选可选的。被调用的 <code>map</code> 数组</p>\n</li>\n<li><p><code>thisArg</code>可选</p>\n<p>可选的。执行 <code>callback</code> 函数时 使用的<code>this</code> 值。</p>\n</li>\n</ul>\n<h2 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 <code>depth</code> 值为 1。</p>\n<h2 id=\"map-和flatMap-的区别\"><a href=\"#map-和flatMap-的区别\" class=\"headerlink\" title=\"map()和flatMap()的区别\"></a>map()和flatMap()的区别</h2><pre><code class=\"js\">var arr1 = [1, 2, 3, 4];\n\narr1.map(x =&gt; [x * 2]);\n// [[2], [4], [6], [8]]\n\narr1.flatMap(x =&gt; [x * 2]);\n// [2, 4, 6, 8]\n\n// only one level is flattened\narr1.flatMap(x =&gt; [[x * 2]]);\n// [[2], [4], [6], [8]]\n</code></pre>\n",
            "tags": [
                "面试用",
                "js",
                "Array"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/interview/Currying/",
            "url": "https://www.yexingcheng.com/interview/Currying/",
            "title": "详解柯里化和反柯里化",
            "date_published": "2022-11-03T16:00:00.000Z",
            "content_html": "<h1 id=\"一、柯里化\"><a href=\"#一、柯里化\" class=\"headerlink\" title=\"一、柯里化\"></a>一、柯里化</h1><p>维基百科：在计算机科学中，柯里化（Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n<blockquote>\n<p>函数柯里化是前端面试过程中场景的一种题目，它不算上高深莫测，但是又混合了多个JS语法，属于高阶函数中一种特殊的用法。</p>\n</blockquote>\n<p>在前端面试中有一个关于柯里化的面试题，流传甚广。</p>\n<pre><code class=\"js\">// 实现一个add方法，使计算结果能够满足如下预期：\nadd(1)(2)(3) = 6\nadd(1, 2, 3)(4) = 10\nadd(1)(2)(3)(4)(5) = 15\n</code></pre>\n<p>很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。</p>\n<h4 id=\"1-如果只调用2次\"><a href=\"#1-如果只调用2次\" class=\"headerlink\" title=\"1. 如果只调用2次\"></a>1. 如果只调用2次</h4><pre><code class=\"js\">function add(a) &#123;\n    return function(b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\nconsole.log(add(1)(2));  // 3\n</code></pre>\n<h4 id=\"2-如果只调用3次\"><a href=\"#2-如果只调用3次\" class=\"headerlink\" title=\"2. 如果只调用3次\"></a>2. 如果只调用3次</h4><pre><code class=\"js\">function add(a) &#123;\n    return function(b) &#123;\n        return function (c) &#123;\n            return a + b + c;\n        &#125;\n    &#125;\n&#125;\n\nconsole.log(add(1)(2)(3)); // 6\n</code></pre>\n<h2 id=\"函数科里化\"><a href=\"#函数科里化\" class=\"headerlink\" title=\"函数科里化\"></a>函数科里化</h2><p>函数柯里化就是创建已经设置单个参数或者多个参数的函数，函数变为接受一个参数，返回一个值，柯里化的用途主要是参数复用。再举一个 demo :</p>\n<pre><code class=\"js\">\n// 参数复用\nfunction add(a, b) &#123;\n    return a + b;\n&#125;\nadd(1,2)  //3\n\n// 柯里化之后可以这样\nvar addCurry = curry(add);\naddCurry(1)(2); //3\n</code></pre>\n<h1 id=\"二、反柯里化\"><a href=\"#二、反柯里化\" class=\"headerlink\" title=\"二、反柯里化\"></a>二、反柯里化</h1>",
            "tags": [
                "面试用",
                "js",
                "Array"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/",
            "url": "https://www.yexingcheng.com/wx-app/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/",
            "title": "微信公众号的开发",
            "date_published": "2022-11-02T16:00:00.000Z",
            "content_html": "<h1 id=\"微信公众号开发\"><a href=\"#微信公众号开发\" class=\"headerlink\" title=\"微信公众号开发\"></a>微信公众号开发</h1><p>混入开发范畴</p>\n<p>nativeapp</p>\n<p>webapp</p>\n<p>Hybrid app</p>\n<p>webView 这个控件属于 android &#x2F; ios 原生自带的，它是浏览器，而js需要运行在浏览器，通过webview即可完成js和原生之间的通讯</p>\n<h1 id=\"1-傻瓜式配置\"><a href=\"#1-傻瓜式配置\" class=\"headerlink\" title=\"1.傻瓜式配置\"></a>1.傻瓜式配置</h1><h1 id=\"2-代码配置\"><a href=\"#2-代码配置\" class=\"headerlink\" title=\"2.代码配置\"></a>2.代码配置</h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>\n<h2 id=\"1-安装koa\"><a href=\"#1-安装koa\" class=\"headerlink\" title=\"1.安装koa\"></a>1.安装koa</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9rb2EuYm9vdGNzcy5jb20v\">https://koa.bootcss.com/</span></p>\n<pre><code class=\"powershell\">yarn init -y\nyarn add koa\n</code></pre>\n<h2 id=\"2-构建服务器\"><a href=\"#2-构建服务器\" class=\"headerlink\" title=\"2.构建服务器\"></a>2.构建服务器</h2><pre><code class=\"js\">// wxpage_app/app.js\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\n// 自定义中间件\napp.use(async (ctx, next) =&gt; &#123;\n  ctx.body = &#39;hello world&#39;\n  await next()\n&#125;)\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<pre><code class=\"json\">// package.json\n&#123;\n  &quot;name&quot;: &quot;wxpage-app&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;dev&quot;: &quot;nodemon app.js&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;koa&quot;: &quot;^2.13.4&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"sh\">$ cnpm run dev\n</code></pre>\n<h2 id=\"3-实现微信公众号自动回复\"><a href=\"#3-实现微信公众号自动回复\" class=\"headerlink\" title=\"3.实现微信公众号自动回复\"></a>3.实现微信公众号自动回复</h2><h3 id=\"1-接口测试账号申请\"><a href=\"#1-接口测试账号申请\" class=\"headerlink\" title=\"1.接口测试账号申请\"></a>1.接口测试账号申请</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL2RlYnVnL2NnaS1iaW4vc2FuZGJveD90PXNhbmRib3gvbG9naW4mYW1wO3Rva2VuPTIxNDc0MDkwNzEmYW1wO2xhbmc9emhfQ04=\">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&amp;token=2147409071&amp;lang=zh_CN</span></p>\n<h3 id=\"2-接口信息配置\"><a href=\"#2-接口信息配置\" class=\"headerlink\" title=\"2.接口信息配置\"></a>2.接口信息配置</h3><h4 id=\"1-必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）\"><a href=\"#1-必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）\" class=\"headerlink\" title=\"1.必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）\"></a>1.必须得有一个域名（IP地址），可以使用ssh穿透（避免每次写完都需要传递到服务器）</h4><p>本地新建_server&#x2F;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jb25mLw==\">www.conf</span></p>\n<blockquote>\n<p>服务器一定要在安全组规则配置7788端口</p>\n</blockquote>\n<pre><code>upstream tunel&#123;\n  server localhost:7788;\n&#125;\n\nserver&#123;\n  # 监听端口\n  listen 80;\n  server_name localhost;\n  # 根目录下\n  location / &#123;\n    # 选择哪个服务器列表\n    proxy_pass http://tunel;\n  &#125;\n\n&#125;\n</code></pre>\n<p>打开&#x2F;etc&#x2F;nginx&#x2F;nginx.config，注释原来的 80端口</p>\n<pre><code class=\"powershell\">cd /etc/nginx\ncd conf.d\n传递上一个文件\nnginx -s reload\n</code></pre>\n<pre><code class=\"powershell\">ssh -vnNt -R 7788:localhost:3333 root@47.93.246.252\n</code></pre>\n<blockquote>\n<p>如果测试成功重新更换服务器的操作系统以后，再次操作，可能会报错（本地记录了上一次的远程服务器信息）</p>\n<p>本地运行以下命令，清除上一次的缓存</p>\n<p>ssh-keygen -R ‘远程服务器的IP地址’</p>\n</blockquote>\n<p>浏览器输入 <span class=\"exturl\" data-url=\"aHR0cDovLzQ3LjkzLjI0Ni4yNTLljbPlj68v\">http://47.93.246.252即可</span></p>\n<h4 id=\"2-验证消息来自微信服务器\"><a href=\"#2-验证消息来自微信服务器\" class=\"headerlink\" title=\"2.验证消息来自微信服务器\"></a>2.验证消息来自微信服务器</h4><p>在开发具体的功能之前，需要先进行token的验证，验证消息来自于微信服务器，验证方法是提交接口配置信息时，微信服务器会发送一个get请求到我们自己的服务器，get请求携带signature:,timestamp:,nonce:,echostr:参数，通过检验signature对请求进行校验，若此次get请求来自微信服务器，就原样返回echostr参数内容</p>\n<p>检验流程</p>\n<pre><code>*\t将token，timestamp,nonce三个参数进行字典序排序\n*\t将三个参数字符串拼接程一个字符串进行sha1加密\n*\t将加密后的字符串与signature对比，相等则表示请求来自微信服务器\n*\t将echostr返回\n</code></pre>\n<p>Server.js</p>\n<pre><code class=\"js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\n// 使用中间件,koa默认是异步的，使用async以及await来构建应用\n// \napp.use(async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n   /**\n   * &#123;\n        signature: &#39;8bd9a5eb51774442313a7e09b55b44ae6e0e711e&#39;,\n        echostr: &#39;5864048842654539467&#39;,\n        timestamp: &#39;1638944331&#39;,\n        nonce: &#39;844212276&#39;\n      &#125;\n   */\n  // 给前端返回数据\n  ctx.body = &#39;hello world&#39;\n  await next()\n&#125;)\n\napp.listen(3333, &#39;localhost&#39;, () =&gt; &#123;\n  console.log(&#39;server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>点击微信公众号服务器的基本配置，查看本地日志</p>\n</blockquote>\n<pre><code class=\"js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\n// 使用中间件,koa默认是异步的，使用async以及await来构建应用\n// \napp.use(async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  const &#123;\n    signature,\n    echostr,\n    timestamp,\n    nonce\n  &#125; = query\n  console.log(query)\n  // 给前端返回数据，返回echostr表示成功\n  ctx.body = echostr\n  await next()\n&#125;)\n\napp.listen(3333, &#39;localhost&#39;, () =&gt; &#123;\n  console.log(&#39;server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>本次提交时发现成功,但是肯定不行的，无法得知是来自微信公众号平台的</p>\n<p>1）将token、timestamp、nonce三个参数进行字典序排序</p>\n<p> 2）将三个参数字符串拼接成一个字符串进行sha1加密 </p>\n<p> 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p>\n</blockquote>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst crypto = require(&#39;crypto&#39;)\nconst app = new Koa()\n\n// 自定义中间件\napp.use(async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;)\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<p>改造抽离中间件</p>\n<pre><code class=\"js\">// controllers/index.js\nconst crypto = require(&#39;crypto&#39;)\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign\n&#125;\n</code></pre>\n<p>添加路由</p>\n<pre><code>yarn add @koa/router\n</code></pre>\n<pre><code class=\"js\">// routes/index.js\nconst Router = require(&#39;@koa/router&#39;) // var express = require(&#39;express&#39;);\nconst &#123; sign &#125; = require(&#39;../controllers/index&#39;)\nconst router = new Router() // var router = express.Router();\n\n// router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;&#125;)\nrouter.get(&#39;/&#39;, sign)\n\nmodule.exports = router\n</code></pre>\n<p>注册路由</p>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst router = require(&#39;./routes/index&#39;)\nconst app = new Koa()\n\n// 注册路由\napp.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);\n// // 自定义中间件\n\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>测试项目</p>\n</blockquote>\n<h4 id=\"3-自动回复文本消息\"><a href=\"#3-自动回复文本消息\" class=\"headerlink\" title=\"3.自动回复文本消息\"></a>3.自动回复文本消息</h4><p>当用户发送消息给微信公众号时（或者某些特定的用户操作引发的事件推送时）,会产生一个post请求，开发者可以特定XML结构，来对该消息进行响应（现支持回复文本，图片，图文，语音，视频，音乐）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L01lc3NhZ2VfTWFuYWdlbWVudC9SZWNlaXZpbmdfc3RhbmRhcmRfbWVzc2FnZXMuaHRtbA==\">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html</span></p>\n<p>添加新的回复路由</p>\n<p>&#x2F;&#x2F; post\t请求</p>\n<blockquote>\n<p>yarn add koa-body</p>\n</blockquote>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst router = require(&#39;./routes/index&#39;)\nconst app = new Koa()\n\n// 一定要放在路由之前\napp.use(koaBody())\n\n// 注册路由\napp.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);\n\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<pre><code class=\"js\">// controllers/index.js\nconst crypto = require(&#39;crypto&#39;)\n// 验证消息来自微信服务器\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\n// 回复消息\nconst reply = async (ctx, next) =&gt; &#123;\n  const body = ctx.request.body\n  console.log(body)\n\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign,\n  reply\n&#125;\n</code></pre>\n<pre><code class=\"js\">// routes/index.js 添加post请求\nconst Router = require(&#39;@koa/router&#39;) // var express = require(&#39;express&#39;);\nconst &#123; sign, reply &#125; = require(&#39;../controllers/index&#39;)\nconst router = new Router() // var router = express.Router();\n\n// router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;&#125;)\nrouter.get(&#39;/&#39;, sign)\nrouter.post(&#39;/&#39;, reply) // 当普通微信用户向公众账号发消息时，微信服务器将 POST 消息的 XML 数据包到开发者填写的 URL 上。\n\nmodule.exports = router\n</code></pre>\n<blockquote>\n<p>从上面的记录中得知，获取到的数据是基于 xml 格式的，不便于处理</p>\n<p>将xml文件转换为js文件</p>\n</blockquote>\n<blockquote>\n<p>yarn add xml-js</p>\n</blockquote>\n<pre><code class=\"js\">// controllers/index.js\nconst crypto = require(&#39;crypto&#39;)\nvar convert = require(&#39;xml-js&#39;);\n// 验证消息来自微信服务器\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\n// 回复消息\nconst reply = async (ctx, next) =&gt; &#123;\n  const body = ctx.request.body\n  console.log(body)\n\n  const result = convert.xml2js(body, &#123;\n    compact: true,\n    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value\n    textKey: &#39;value&#39;// 将对象中的 _text 变成value\n  &#125;).xml\n\n  // object.keys -- 数组  - reduce \n  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;\n    resObj[key] = result[key].value\n    return resObj\n  &#125;, &#123;&#125;)\n  console.log(obj)\n\n\n  // 给用户回馈信息\n  ctx.body = `\n    &lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[$&#123;obj.FromUserName&#125;]]&gt;&lt;/ToUserName&gt;\n    &lt;FromUserName&gt;&lt;![CDATA[$&#123;obj.ToUserName&#125;]]&gt;&lt;/FromUserName&gt;\n    &lt;CreateTime&gt;$&#123;obj.CreateTime&#125;&lt;/CreateTime&gt;\n    &lt;MsgType&gt;&lt;![CDATA[$&#123;obj.MsgType&#125;]]&gt;&lt;/MsgType&gt;\n    &lt;Content&gt;&lt;![CDATA[武汉好程序员1期宣誓：我最强，我最棒，我是no.1]]&gt;&lt;/Content&gt;\n    &lt;MsgId&gt;$&#123;obj.MsgId&#125;&lt;/MsgId&gt;\n  &lt;/xml&gt;\n  `\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign,\n  reply\n&#125;\n</code></pre>\n<blockquote>\n<p>扫码微信公众号测试账号，发送任何消息，发现会自动回复消息</p>\n</blockquote>\n<h2 id=\"3-添加模版消息\"><a href=\"#3-添加模版消息\" class=\"headerlink\" title=\"3.添加模版消息\"></a>3.添加模版消息</h2><pre><code>yarn add koa-views koa-ejs -S\n</code></pre>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst router = require(&#39;./routes/index&#39;)\nconst views = require(&#39;koa-views&#39;)\nconst ejs = require(&#39;koa-ejs&#39;)\nconst app = new Koa()\n\n// 设置模版 \napp.use(views(path.join(__dirname, &#39;./views&#39;), &#123;\n  extension: &#39;ejs&#39;\n&#125;))\n\n// 一定要放在路由之前\napp.use(koaBody())\n\n// 注册路由\napp.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);\n\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<pre><code class=\"xml\">// views/index.ejs\n&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&lt;%- FromUserName%&gt;]]&gt;&lt;/ToUserName&gt;\n  &lt;FromUserName&gt;&lt;![CDATA[&lt;%- ToUserName%&gt;]]&gt;&lt;/FromUserName&gt;\n  &lt;CreateTime&gt;&lt;%- CreateTime%&gt;&lt;/CreateTime&gt;\n  &lt;MsgType&gt;&lt;![CDATA[&lt;%- MsgType%&gt;]]&gt;&lt;/MsgType&gt;\n  &lt;Content&gt;&lt;![CDATA[&lt;a href=&quot;https://www.baidu.com&quot;&gt;打开百度&lt;/a&gt;]]&gt;&lt;/Content&gt;\n  &lt;MsgId&gt;&lt;%- MsgId%&gt;&lt;/MsgId&gt;\n&lt;/xml&gt;\n</code></pre>\n<pre><code class=\"js\">// controller/index.js\nconst crypto = require(&#39;crypto&#39;)\nvar convert = require(&#39;xml-js&#39;);\n// 验证消息来自微信服务器\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\n// 回复消息\nconst reply = async (ctx, next) =&gt; &#123;\n  const body = ctx.request.body\n  console.log(body)\n\n  const result = convert.xml2js(body, &#123;\n    compact: true,\n    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value\n    textKey: &#39;value&#39;// 将对象中的 _text 变成value\n  &#125;).xml\n\n  // object.keys -- 数组  - reduce \n  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;\n    resObj[key] = result[key].value\n    return resObj\n  &#125;, &#123;&#125;)\n  console.log(obj)\n\n\n  // 使用模版发送消息\n  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId&#125; = obj\n\n  // express res.render(&#39;index&#39;, &#123;&#125;)\n  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId &#125;)\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign,\n  reply\n&#125;\n</code></pre>\n<blockquote>\n<p>模拟数据回复</p>\n</blockquote>\n<pre><code class=\"xml\">// views/index.ejs\n&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&lt;%- FromUserName%&gt;]]&gt;&lt;/ToUserName&gt;\n  &lt;FromUserName&gt;&lt;![CDATA[&lt;%- ToUserName%&gt;]]&gt;&lt;/FromUserName&gt;\n  &lt;CreateTime&gt;&lt;%- CreateTime%&gt;&lt;/CreateTime&gt;\n  &lt;MsgType&gt;&lt;![CDATA[&lt;%- MsgType%&gt;]]&gt;&lt;/MsgType&gt;\n  &lt;Content&gt;&lt;![CDATA[&lt;%- Content %&gt;]]&gt;&lt;/Content&gt;\n  &lt;MsgId&gt;&lt;%- MsgId%&gt;&lt;/MsgId&gt;\n&lt;/xml&gt;\n</code></pre>\n<pre><code class=\"js\">// controllers/index.js\nconst crypto = require(&#39;crypto&#39;)\nvar convert = require(&#39;xml-js&#39;);\n// 验证消息来自微信服务器\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\n// 回复消息\nconst reply = async (ctx, next) =&gt; &#123;\n  const body = ctx.request.body\n  console.log(body)\n \n  const result = convert.xml2js(body, &#123;\n    compact: true,\n    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value\n    textKey: &#39;value&#39;// 将对象中的 _text 变成value\n  &#125;).xml\n\n  // object.keys -- 数组  - reduce \n  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;\n    resObj[key] = result[key].value\n    return resObj\n  &#125;, &#123;&#125;)\n  console.log(obj)\n \n  // 使用模版发送消息\n  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content&#125; = obj\n  let str = &#39;你是最棒的&#39;\n  switch (Content) &#123;\n    case &#39;1&#39;:\n      str = &#39;中&#39;\n      break;\n    case &#39;2&#39;:\n      str = &#39;得劲&#39;\n      break;\n    case &#39;3&#39;:\n      str = &#39;美的很&#39;\n      break;\n    case &#39;4&#39;:\n      str = &#39;你个信球&#39;\n      break;\n    default:\n      break;\n  &#125;\n  // express res.render(&#39;index&#39;, &#123;&#125;)\n  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content: str &#125;)\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign,\n  reply\n&#125;\n</code></pre>\n<h1 id=\"3-拍照\"><a href=\"#3-拍照\" class=\"headerlink\" title=\"3.拍照\"></a>3.拍照</h1><p>回复自己的页面，不回复百度了</p>\n<h2 id=\"1-Koa-实现静态资源目录\"><a href=\"#1-Koa-实现静态资源目录\" class=\"headerlink\" title=\"1.Koa 实现静态资源目录\"></a>1.Koa 实现静态资源目录</h2><pre><code>yarn add koa-static\n</code></pre>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst router = require(&#39;./routes/index&#39;)\nconst views = require(&#39;koa-views&#39;)\nconst ejs = require(&#39;koa-ejs&#39;)\nconst static = require(&#39;koa-static&#39;)\nconst path = require(&#39;path&#39;)\nconst app = new Koa()\n\n// 设置模版 \napp.use(views(path.join(__dirname, &#39;./views&#39;), &#123;\n  extension: &#39;ejs&#39;\n&#125;))\n// 设置静态资源目录\napp.use(static(path.resolve(__dirname, &#39;./public&#39;)))\n\n// 一定要放在路由之前\napp.use(koaBody())\n\n// 注册路由\napp.use(router.routes()) //  app.use(&#39;/&#39;, indexRouter);\n// // 自定义中间件\n\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<pre><code class=\"html\">&lt;!--public/index.html--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;嗨购商城&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  嗨购商城\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>&#x2F;&#x2F; 浏览器访问ip地址即可 <span class=\"exturl\" data-url=\"aHR0cDovLzQ3LjkzLjI0Ni4yNTIv\">http://47.93.246.252/</span></p>\n<p><strong>消息回复提示</strong></p>\n<pre><code class=\"js\">// controllers/index.js\nconst crypto = require(&#39;crypto&#39;)\nvar convert = require(&#39;xml-js&#39;);\n// 验证消息来自微信服务器\nconst sign = async (ctx, next) =&gt; &#123;\n  const query = ctx.request.query\n  console.log(query)\n  const &#123; signature, echostr, timestamp, nonce &#125; = query\n  // 1.将token、timestamp、nonce三个参数进行字典序排序\n  const token = &#39;whgp01&#39;\n  const arr = [token, timestamp, nonce].sort() // 字典序排序 [ &#39;nonce&#39;, &#39;timestamp&#39;, &#39;token&#39; ]\n  console.log(arr)\n  // 2.将三个参数字符串拼接成一个字符串进行sha1加密 \n  const str = arr.join(&#39;&#39;)\n  const sign = crypto.createHash(&#39;sha1&#39;).update(str).digest(&#39;hex&#39;) // 16进制加密\n  // 3.开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信\n  if (sign === signature) &#123;\n    ctx.body = echostr // 返回 echostr 说明服务器验证来自于微信服务器\n  &#125; else &#123;\n    ctx.body = &#39;出错了&#39;\n  &#125;\n  await next()\n&#125;\n\n// 回复消息\nconst reply = async (ctx, next) =&gt; &#123;\n  const body = ctx.request.body\n  console.log(body)\n\n  const result = convert.xml2js(body, &#123;\n    compact: true,\n    cdataKey: &#39;value&#39;, // 将对象中的 _cdata 变成value\n    textKey: &#39;value&#39;// 将对象中的 _text 变成value\n  &#125;).xml\n\n  // object.keys -- 数组  - reduce \n  const obj = Object.keys(result).reduce((resObj, key) =&gt; &#123;\n    resObj[key] = result[key].value\n    return resObj\n  &#125;, &#123;&#125;)\n  console.log(obj)\n\n\n  const &#123;ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content&#125; = obj\n  let str = `\n    亲，你可以输入以下数字分别打开不同的网页：\n    [1] 打开嗨购商城\n    [2] 打开百度\n\n  `\n  switch (Content) &#123;\n    case &#39;1&#39;:\n      str = `&lt;a href=&quot;http://47.93.246.252/&quot;&gt;嗨购商城&lt;/a&gt;`\n      break;\n    case &#39;2&#39;:\n      str = `&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;`\n      break;\n    default:\n      break;\n  &#125;\n  // express res.render(&#39;index&#39;, &#123;&#125;)\n  await ctx.render(&#39;index&#39;, &#123; ToUserName, FromUserName, CreateTime, MsgType, MsgId, Content: str &#125;)\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign,\n  reply\n&#125;\n</code></pre>\n<blockquote>\n<p>目前可以在公众号中打开自己写网页— 微信公众号的开发</p>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1s\">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html</span></p>\n</blockquote>\n<h2 id=\"2-生成签名\"><a href=\"#2-生成签名\" class=\"headerlink\" title=\"2.生成签名\"></a>2.生成签名</h2><blockquote>\n<p>最好生成一个新的路由，配置子路由</p>\n</blockquote>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst routerIndex = require(&#39;./routes/index&#39;)\nconst views = require(&#39;koa-views&#39;)\nconst ejs = require(&#39;koa-ejs&#39;)\nconst static = require(&#39;koa-static&#39;)\nconst path = require(&#39;path&#39;)\nconst Router = require(&#39;@koa/router&#39;) // ++++++\nconst app = new Koa()\nconst router = new Router()// ++++++\n// 设置模版 \napp.use(views(path.join(__dirname, &#39;./views&#39;), &#123;\n  extension: &#39;ejs&#39;\n&#125;))\n// 设置静态资源目录\napp.use(static(path.resolve(__dirname, &#39;./public&#39;)))\n\n// 一定要放在路由之前\napp.use(koaBody())\n\n// 注册路由\nrouter.use(&#39;/wx&#39;, routerIndex.routes())// ++++++\napp.use(router.routes())\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>此时需要修改测试公众号的 配置，添加&#x2F;wx 验证token</p>\n</blockquote>\n<p><strong>构建生成签名的路由的中间件</strong></p>\n<pre><code class=\"js\">// controllers/sign.js\nconst sign = async (ctx, next) =&gt; &#123;\n  ctx.body=&quot;签名&quot;\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign\n&#125;\n</code></pre>\n<pre><code class=\"js\">// routes/sign.js\nconst Router = require(&#39;@koa/router&#39;)\nconst router = new Router()\nconst &#123; sign &#125; = require(&#39;../controllers/sign&#39;)\n\nrouter.get(&#39;/sign&#39;, sign)\n\nmodule.exports = router\n</code></pre>\n<pre><code class=\"js\">// app.js\nconst Koa = require(&#39;koa&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\n// const crypto = require(&#39;crypto&#39;)\nconst routerIndex = require(&#39;./routes/index&#39;)\nconst routerSign = require(&#39;./routes/sign&#39;)\nconst views = require(&#39;koa-views&#39;)\nconst ejs = require(&#39;koa-ejs&#39;)\nconst static = require(&#39;koa-static&#39;)\nconst path = require(&#39;path&#39;)\nconst Router = require(&#39;@koa/router&#39;) // ++++++\nconst app = new Koa()\nconst router = new Router()// ++++++\n// 设置模版 \napp.use(views(path.join(__dirname, &#39;./views&#39;), &#123;\n  extension: &#39;ejs&#39;\n&#125;))\n// 设置静态资源目录\napp.use(static(path.resolve(__dirname, &#39;./public&#39;)))\n\n// 一定要放在路由之前\napp.use(koaBody())\n\n// 注册路由\nrouter.use(&#39;/wx&#39;, routerIndex.routes()) \nrouter.use(&#39;/api&#39;, routerSign.routes()) \napp.use(router.routes())\n\n\n// 监听端口号\napp.listen(&#39;3333&#39;, &quot;localhost&quot;, () =&gt; &#123;\n  console.log(&#39;your server is running at http://localhost:3333&#39;)\n&#125;)\n</code></pre>\n<p>打开网页 <span class=\"exturl\" data-url=\"aHR0cDovLzQ3LjkzLjI0Ni4yNTIvYXBpL3NpZ24=\">http://47.93.246.252/api/sign</span> </p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1sIzYy\">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0dldF9hY2Nlc3NfdG9rZW4uaHRtbA==\">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html</span></p>\n<pre><code>yarn add axios randomstring\n</code></pre>\n<pre><code class=\"js\">// controllers/sign.js\nconst axios = require(&#39;axios&#39;)\nconst randomstring = require(&#39;randomstring&#39;)\nconst querystring = require(&#39;querystring&#39;)\nconst crypto = require(&#39;crypto&#39;)\nconst sign = async (ctx, next) =&gt; &#123;\n  const appid = &#39;wxbbdbe14f3df54d1a&#39;\n  const secret = &#39;522dbfad863073c6e02364b5544e5861&#39;\n  // 1.获取access_token\n  const &#123; data: &#123; access_token &#125;&#125; = await axios.get(&#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&#39;, &#123; params: &#123; appid, secret &#125;&#125;)\n  // console.log(access_token) // http://47.93.246.252/api/sign 得知\n  // 2.获取jsapi_ticket\n  const &#123; data: &#123; ticket &#125;&#125; = await axios.get(&#39;https://api.weixin.qq.com/cgi-bin/ticket/getticket&#39;, &#123; params: &#123; type: &#39;jsapi&#39;, access_token &#125;&#125;)\n  // console.log(ticket) //  http://47.93.246.252/api/sign 得知\n\n  const noncestr = randomstring.generate(32)\n  // console.log(noncestr)\n  const jsapi_ticket = ticket\n  const timestamp = new Date().getTime()\n  // console.log(timestamp)\n  const url = &#39;http://47.93.246.252/&#39;\n\n  const obj = &#123;\n    noncestr, jsapi_ticket, timestamp,  url\n  &#125;\n  // 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后\n  const newObj = Object.keys(obj).sort().reduce((o, key) =&gt; &#123;\n    o[key] = obj[key]\n    return o\n  &#125;, &#123;&#125;)\n  // console.log(newObj)\n  // 使用 URL 键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1\n  // const string1 = querystring.stringify(newObj)\n  // console.log(string1) // 发现 url地址进行了转义 http%3A%2F%2F47.93.246.252%2F\n  const string1 = querystring.stringify(newObj, null, null, &#123;\n    encodeURIComponent: (val) =&gt; decodeURIComponent(val)\n  &#125; )\n  // console.log(string1)\n  // 对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义\n  const signature = crypto.createHash(&#39;sha1&#39;).update(string1).digest(&#39;hex&#39;)\n  ctx.body = &#123;\n    appId: appid,\n    timestamp,\n    nonceStr: noncestr,\n    signature\n  &#125;\n  // ctx.body=&quot;签名&quot;\n  await next()\n&#125;\n\nmodule.exports = &#123;\n  sign\n&#125;\n</code></pre>\n<h2 id=\"3-前端调用接口\"><a href=\"#3-前端调用接口\" class=\"headerlink\" title=\"3.前端调用接口\"></a>3.前端调用接口</h2><pre><code class=\"html\">// public/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;嗨购商城&lt;/title&gt;\n  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  嗨购商城\n  &lt;button id=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n    console.log(res)\n    wx.config(&#123;\n      debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。\n      appId: res.appId, // 必填，公众号的唯一标识\n      timestamp: res.timestamp, // 必填，生成签名的时间戳\n      nonceStr: res.nonceStr, // 必填，生成签名的随机串\n      signature: res.signature,// 必填，签名\n      jsApiList: [\n        &#39;updateAppMessageShareData&#39;,\n        &#39;updateTimelineShareData&#39;,\n        &#39;onMenuShareWeibo&#39;,\n        &#39;onMenuShareQZone&#39;,\n        &#39;startRecord&#39;,\n        &#39;stopRecord&#39;,\n        &#39;onVoiceRecordEnd&#39;,\n        &#39;playVoice&#39;,\n        &#39;pauseVoice&#39;,\n        &#39;stopVoice&#39;,\n        &#39;onVoicePlayEnd&#39;,\n        &#39;uploadVoice&#39;,\n        &#39;downloadVoice&#39;,\n        &#39;chooseImage&#39;,\n        &#39;previewImage&#39;,\n        &#39;uploadImage&#39;,\n        &#39;downloadImage&#39;,\n        &#39;translateVoice&#39;,\n        &#39;getNetworkType&#39;,\n        &#39;openLocation&#39;,\n        &#39;getLocation&#39;,\n        &#39;hideOptionMenu&#39;,\n        &#39;showOptionMenu&#39;,\n        &#39;hideMenuItems&#39;,\n        &#39;showMenuItems&#39;,\n        &#39;hideAllNonBaseMenuItem&#39;,\n        &#39;showAllNonBaseMenuItem&#39;,\n        &#39;closeWindow&#39;,\n        &#39;scanQRCode&#39;,\n        &#39;chooseWXPay&#39;,\n        &#39;openProductSpecificView&#39;,\n        &#39;addCard&#39;,\n        &#39;chooseCard&#39;,\n        &#39;openCard&#39;\n      ] // 必填，需要使用的 JS 接口列表\n    &#125;);\n  &#125;)\n\n  wx.ready(function()&#123;\n    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中。\n  \n\n  &#125;);\n\n\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"4-最终测试-扫一扫\"><a href=\"#4-最终测试-扫一扫\" class=\"headerlink\" title=\"4.最终测试-扫一扫\"></a>4.最终测试-扫一扫</h2><pre><code class=\"html\">// public/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;嗨购商城&lt;/title&gt;\n  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  嗨购商城\n  &lt;button id=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n    console.log(res)\n    wx.config(&#123;\n      debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。\n      appId: res.appId, // 必填，公众号的唯一标识\n      timestamp: res.timestamp, // 必填，生成签名的时间戳\n      nonceStr: res.nonceStr, // 必填，生成签名的随机串\n      signature: res.signature,// 必填，签名\n      jsApiList: [\n        &#39;updateAppMessageShareData&#39;,\n        &#39;updateTimelineShareData&#39;,\n        &#39;onMenuShareWeibo&#39;,\n        &#39;onMenuShareQZone&#39;,\n        &#39;startRecord&#39;,\n        &#39;stopRecord&#39;,\n        &#39;onVoiceRecordEnd&#39;,\n        &#39;playVoice&#39;,\n        &#39;pauseVoice&#39;,\n        &#39;stopVoice&#39;,\n        &#39;onVoicePlayEnd&#39;,\n        &#39;uploadVoice&#39;,\n        &#39;downloadVoice&#39;,\n        &#39;chooseImage&#39;,\n        &#39;previewImage&#39;,\n        &#39;uploadImage&#39;,\n        &#39;downloadImage&#39;,\n        &#39;translateVoice&#39;,\n        &#39;getNetworkType&#39;,\n        &#39;openLocation&#39;,\n        &#39;getLocation&#39;,\n        &#39;hideOptionMenu&#39;,\n        &#39;showOptionMenu&#39;,\n        &#39;hideMenuItems&#39;,\n        &#39;showMenuItems&#39;,\n        &#39;hideAllNonBaseMenuItem&#39;,\n        &#39;showAllNonBaseMenuItem&#39;,\n        &#39;closeWindow&#39;,\n        &#39;scanQRCode&#39;,\n        &#39;chooseWXPay&#39;,\n        &#39;openProductSpecificView&#39;,\n        &#39;addCard&#39;,\n        &#39;chooseCard&#39;,\n        &#39;openCard&#39;\n      ] // 必填，需要使用的 JS 接口列表\n    &#125;);\n  &#125;)\n\n  wx.ready(function()&#123;\n    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中。\n    document.getElementById(&#39;scan&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;\n      wx.scanQRCode(&#123;\n        needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，\n        scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有\n        success: function (res) &#123;\n          var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果\n        &#125;\n      &#125;);\n\n\n    &#125;, false)\n\n  &#125;);\n\n\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>扫描测试公众号，输入1，点击嗨购商城，点击扫一扫测试</p>\n</blockquote>\n<h1 id=\"4-vue结合微信公众号开发\"><a href=\"#4-vue结合微信公众号开发\" class=\"headerlink\" title=\"4.vue结合微信公众号开发\"></a>4.vue结合微信公众号开发</h1><h2 id=\"1-实现扫码和拍照功能\"><a href=\"#1-实现扫码和拍照功能\" class=\"headerlink\" title=\"1.实现扫码和拍照功能\"></a>1.实现扫码和拍照功能</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;嗨购商城&lt;/title&gt;\n  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;\n  &lt;script src=&quot;/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;嗨购商城&lt;/h1&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button @click=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;\n    &lt;button @click=&quot;takephoto&quot;&gt;拍照&lt;/button&gt;\n    &lt;img :src=&quot;img&quot; alt=&quot;&quot;&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  \n\n  new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n      img: &#39;&#39;\n    &#125;,\n    mounted() &#123;\n      fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n        console.log(res)\n        wx.config(&#123;\n          debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。\n          appId: res.appId, // 必填，公众号的唯一标识\n          timestamp: res.timestamp, // 必填，生成签名的时间戳\n          nonceStr: res.nonceStr, // 必填，生成签名的随机串\n          signature: res.signature,// 必填，签名\n          jsApiList: [\n            &#39;updateAppMessageShareData&#39;,\n            &#39;updateTimelineShareData&#39;,\n            &#39;onMenuShareWeibo&#39;,\n            &#39;onMenuShareQZone&#39;,\n            &#39;startRecord&#39;,\n            &#39;stopRecord&#39;,\n            &#39;onVoiceRecordEnd&#39;,\n            &#39;playVoice&#39;,\n            &#39;pauseVoice&#39;,\n            &#39;stopVoice&#39;,\n            &#39;onVoicePlayEnd&#39;,\n            &#39;uploadVoice&#39;,\n            &#39;downloadVoice&#39;,\n            &#39;chooseImage&#39;,\n            &#39;previewImage&#39;,\n            &#39;uploadImage&#39;,\n            &#39;downloadImage&#39;,\n            &#39;translateVoice&#39;,\n            &#39;getNetworkType&#39;,\n            &#39;openLocation&#39;,\n            &#39;getLocation&#39;,\n            &#39;hideOptionMenu&#39;,\n            &#39;showOptionMenu&#39;,\n            &#39;hideMenuItems&#39;,\n            &#39;showMenuItems&#39;,\n            &#39;hideAllNonBaseMenuItem&#39;,\n            &#39;showAllNonBaseMenuItem&#39;,\n            &#39;closeWindow&#39;,\n            &#39;scanQRCode&#39;,\n            &#39;chooseWXPay&#39;,\n            &#39;openProductSpecificView&#39;,\n            &#39;addCard&#39;,\n            &#39;chooseCard&#39;,\n            &#39;openCard&#39;\n          ] // 必填，需要使用的 JS 接口列表\n        &#125;);\n      &#125;)\n    &#125;,\n    methods: &#123;\n      scan () &#123;\n        wx.scanQRCode(&#123;\n          needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，\n          scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有\n          success: function (res) &#123;\n            var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果\n          &#125;\n        &#125;);\n      &#125;,\n      takephoto () &#123;\n        wx.chooseImage(&#123;\n          count: 1, // 默认9\n          sizeType: [&#39;original&#39;, &#39;compressed&#39;], // 可以指定是原图还是压缩图，默认二者都有\n          sourceType: [&#39;album&#39;, &#39;camera&#39;], // 可以指定来源是相册还是相机，默认二者都有\n          success: (res) =&gt; &#123;\n            var localIds = res.localIds; // 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片\n            console.log(localIds[0])\n            this.img = localIds[0]\n          &#125;\n        &#125;);\n\n\n      &#125;\n    &#125;,\n  &#125;)\n\n \n\n\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"2-分享\"><a href=\"#2-分享\" class=\"headerlink\" title=\"2.分享\"></a>2.分享</h2><blockquote>\n<p>网页 — 直接分享到朋友圈 — 分享的内容就为你当前的网页</p>\n<p>网页 – 按钮 — 点击分享到朋友圈。— 再通过朋友圈分享 —- 自定义分享的内容</p>\n</blockquote>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;嗨购商城&lt;/title&gt;\n  &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;\n  &lt;script src=&quot;/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;嗨购商城&lt;/h1&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button @click=&quot;scan&quot;&gt;扫一扫&lt;/button&gt;\n    &lt;button @click=&quot;takephoto&quot;&gt;拍照&lt;/button&gt;\n    &lt;button @click=&quot;share&quot;&gt;分享到朋友圈&lt;/button&gt;\n    &lt;img :src=&quot;img&quot; alt=&quot;&quot;&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  \n\n  new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n      img: &#39;&#39;\n    &#125;,\n    mounted() &#123;\n      fetch(&#39;/api/sign&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n        console.log(res)\n        wx.config(&#123;\n          debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。\n          appId: res.appId, // 必填，公众号的唯一标识\n          timestamp: res.timestamp, // 必填，生成签名的时间戳\n          nonceStr: res.nonceStr, // 必填，生成签名的随机串\n          signature: res.signature,// 必填，签名\n          jsApiList: [\n            &#39;onMenuShareTimeline&#39;,\n            &#39;updateAppMessageShareData&#39;,\n            &#39;updateTimelineShareData&#39;,\n            &#39;onMenuShareWeibo&#39;,\n            &#39;onMenuShareQZone&#39;,\n            &#39;startRecord&#39;,\n            &#39;stopRecord&#39;,\n            &#39;onVoiceRecordEnd&#39;,\n            &#39;playVoice&#39;,\n            &#39;pauseVoice&#39;,\n            &#39;stopVoice&#39;,\n            &#39;onVoicePlayEnd&#39;,\n            &#39;uploadVoice&#39;,\n            &#39;downloadVoice&#39;,\n            &#39;chooseImage&#39;,\n            &#39;previewImage&#39;,\n            &#39;uploadImage&#39;,\n            &#39;downloadImage&#39;,\n            &#39;translateVoice&#39;,\n            &#39;getNetworkType&#39;,\n            &#39;openLocation&#39;,\n            &#39;getLocation&#39;,\n            &#39;hideOptionMenu&#39;,\n            &#39;showOptionMenu&#39;,\n            &#39;hideMenuItems&#39;,\n            &#39;showMenuItems&#39;,\n            &#39;hideAllNonBaseMenuItem&#39;,\n            &#39;showAllNonBaseMenuItem&#39;,\n            &#39;closeWindow&#39;,\n            &#39;scanQRCode&#39;,\n            &#39;chooseWXPay&#39;,\n            &#39;openProductSpecificView&#39;,\n            &#39;addCard&#39;,\n            &#39;chooseCard&#39;,\n            &#39;openCard&#39;\n          ] // 必填，需要使用的 JS 接口列表\n        &#125;);\n      &#125;)\n    &#125;,\n    methods: &#123;\n      scan () &#123;\n        wx.scanQRCode(&#123;\n          needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，\n          scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有\n          success: function (res) &#123;\n            var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果\n          &#125;\n        &#125;);\n      &#125;,\n      takephoto () &#123;\n        wx.chooseImage(&#123;\n          count: 1, // 默认9\n          sizeType: [&#39;original&#39;, &#39;compressed&#39;], // 可以指定是原图还是压缩图，默认二者都有\n          sourceType: [&#39;album&#39;, &#39;camera&#39;], // 可以指定来源是相册还是相机，默认二者都有\n          success: (res) =&gt; &#123;\n            var localIds = res.localIds; // 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片\n            console.log(localIds[0])\n            this.img = localIds[0]\n          &#125;\n        &#125;);\n\n\n      &#125;,\n      share () &#123;\n        wx.ready(function () &#123; \n          wx.onMenuShareTimeline(&#123; \n            title: &#39;自定义分享啦&#39;, // 分享标题 http://47.93.246.252/share.html\n            link: &#39;http://47.93.246.252/share.html&#39;, // 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致\n            imgUrl: &#39;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#39;, // 分享图标\n            success: function () &#123;\n              // 设置成功\n            &#125;\n          &#125;)\n        &#125;)\n      &#125;\n    &#125;,\n  &#125;)\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n",
            "tags": [
                "微信小程序",
                "wxapp",
                "ts"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/wx-app/day3/",
            "url": "https://www.yexingcheng.com/wx-app/day3/",
            "title": "构建电商界面的小程序（一）",
            "date_published": "2022-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"1-构建电商类型的小程序\"><a href=\"#1-构建电商类型的小程序\" class=\"headerlink\" title=\"1.构建电商类型的小程序\"></a>1.构建电商类型的小程序</h1><h2 id=\"1-1-准备对应的小程序UI库\"><a href=\"#1-1-准备对应的小程序UI库\" class=\"headerlink\" title=\"1.1 准备对应的小程序UI库\"></a>1.1 准备对应的小程序UI库</h2><p>所谓的UI库就是第三方创建的一些自定义的组件，我们可以拿来直接使用</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly95b3V6YW4uZ2l0aHViLmlvL3ZhbnQtd2VhcHAvIy9ob21l\">https://youzan.github.io/vant-weapp/#/home</span></p>\n<h3 id=\"1-1-1-配置UI库\"><a href=\"#1-1-1-配置UI库\" class=\"headerlink\" title=\"1.1.1 配置UI库\"></a>1.1.1 配置UI库</h3><p><strong>安装UI库</strong></p>\n<p><img data-src=\"/wx-app/day3/image-20221102202145423.png\" alt=\"image-20221102202145423\"></p>\n<pre><code class=\"sh\">$ yarn add @vant/weapp --production\n</code></pre>\n<blockquote>\n<p>如果提示你的 yarn 未安装，可以安装，但是要安装yarn，得先安装nodejs</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL25vZGVqcy5jbi9kb3dubG9hZC8=\">http://nodejs.cn/download/</span> 下载对应的版本，直接安装即可，记住不建议大家更改安装目录，如果更改了，后期需要配置环境变量</p>\n<pre><code class=\"sh\">$ npm i yarn -g\n</code></pre>\n<blockquote>\n<p>$ 符号表示这里需要输入命名，在命令行输入</p>\n</blockquote>\n</blockquote>\n<p><strong>修改App.json</strong></p>\n<blockquote>\n<p>将 app.json 中的 <code>&quot;style&quot;: &quot;v2&quot;</code> 去除</p>\n</blockquote>\n<h3 id=\"修改-project-config-json\"><a href=\"#修改-project-config-json\" class=\"headerlink\" title=\"修改 project.config.json\"></a>修改 project.config.json</h3><p>开发者工具创建的项目，<code>miniprogramRoot</code> 默认为 <code>miniprogram</code>，<code>package.json</code> 在其外部，npm 构建无法正常工作。</p>\n<p>需要手动在 <code>project.config.json</code> 内添加如下配置，使开发者工具可以正确索引到 npm 依赖的位置。</p>\n<pre><code class=\"json\">&#123;\n  ...\n  &quot;setting&quot;: &#123;\n    ...\n    &quot;packNpmManually&quot;: true,\n    &quot;packNpmRelationList&quot;: [\n      &#123;\n        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,\n        &quot;miniprogramNpmDistDir&quot;: &quot;./miniprogram/&quot;\n      &#125;\n    ]\n  &#125;\n&#125;\n</code></pre>\n<p>注意： 由于目前新版开发者工具创建的小程序目录文件结构问题，npm构建的文件目录为miniprogram_npm，并且开发工具会默认在当前目录下创建miniprogram_npm的文件名，所以新版本的miniprogramNpmDistDir配置为’.&#x2F;‘即可</p>\n<p><strong>构建 npm 包</strong></p>\n<p><img data-src=\"/wx-app/day3/image-20221102202238920.png\" alt=\"image-20221102202238920\"></p>\n<blockquote>\n<p>此时就可以删除 当前项目文件夹下的 node_modules 文件夹了</p>\n<p>miniprogram_npm 文件夹就是vantweapp 为我们所提供的自定义的组件库</p>\n</blockquote>\n<blockquote>\n<p>如果大家没有安装过node，也没有yarn，说明没有安装，如果不想安装，那么大家可以直接拷贝 miniprogram_npm 文件夹至你的项目即可</p>\n</blockquote>\n<h3 id=\"typescript-支持\"><a href=\"#typescript-支持\" class=\"headerlink\" title=\"typescript 支持\"></a>typescript 支持</h3><p>如果你使用 typescript 开发小程序，还需要做如下操作，以获得顺畅的开发体验。</p>\n<h4 id=\"安装-miniprogram-api-typings\"><a href=\"#安装-miniprogram-api-typings\" class=\"headerlink\" title=\"安装 miniprogram-api-typings\"></a>安装 miniprogram-api-typings</h4><pre><code class=\"bash\"># 通过 npm 安装\nnpm i -D miniprogram-api-typings\n\n# 通过 yarn 安装\nyarn add -D miniprogram-api-typings\n</code></pre>\n<h4 id=\"在-tsconfig-json-中增加如下配置，以防止-tsc-编译报错。\"><a href=\"#在-tsconfig-json-中增加如下配置，以防止-tsc-编译报错。\" class=\"headerlink\" title=\"在 tsconfig.json 中增加如下配置，以防止 tsc 编译报错。\"></a>在 tsconfig.json 中增加如下配置，以防止 tsc 编译报错。</h4><p>请将<code>path/to/node_modules/@vant/weapp</code>修改为项目的 <code>node_modules</code> 中 @vant&#x2F;weapp 所在的目录。</p>\n<pre><code class=\"json\">&#123;\n  ...\n  &quot;compilerOptions&quot;: &#123;\n    ...\n    &quot;baseUrl&quot;: &quot;.&quot;,\n    &quot;types&quot;: [&quot;miniprogram-api-typings&quot;],\n    &quot;paths&quot;: &#123;\n      &quot;@vant/weapp/*&quot;: [&quot;./node_modules/@vant/weapp/dist/*&quot;]\n    &#125;,\n    &quot;lib&quot;: [&quot;ES6&quot;]\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-构建小程序的首页\"><a href=\"#1-2-构建小程序的首页\" class=\"headerlink\" title=\"1.2 构建小程序的首页\"></a>1.2 构建小程序的首页</h2><p>准备接口文档：<span class=\"exturl\" data-url=\"aHR0cDovLzEyMS44OS4yMDUuMTg5OjMwMDAvYXBpZG9jLw==\">http://121.89.205.189:3000/apidoc/</span></p>\n<h3 id=\"1-2-1-构建轮播图\"><a href=\"#1-2-1-构建轮播图\" class=\"headerlink\" title=\"1.2.1 构建轮播图\"></a>1.2.1 构建轮播图</h3><pre><code class=\"ts\">// utils/request.ts\n// https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html\n// const request = &#123;\n// \tget () &#123;&#125;,\n// \tpost () &#123;&#125;\n// &#125;\n// request.get()\n// request.post()\n// 继承中间类型，data声明为any\ninterface AnyResult extends WechatMiniprogram.RequestSuccessCallbackResult &#123;\n  data: any\n&#125;\n// 从中间类型继承一个泛型接口，data声明为泛型\nexport interface SpecResult&lt;T&gt; extends AnyResult &#123;\n  data: T\n&#125;\n// 声明业务数据类型\nexport interface IMyData &#123;\n  code: string\n  msg: string\n  data?: any\n&#125;\n\nexport default function request (config: WechatMiniprogram.RequestOption) &#123;\n    // 显示loading动画\n    wx.showLoading(&#123;\n        title: &#39;加载中&#39;\n    &#125;)\n    const &#123; url = &#39;&#39;, data = &#123;&#125;, method = &#39;GET&#39;, header = &#123;&#125;&#125; = config\n    // Promise&lt;SpecResult&lt;IMyData&gt;&gt; 声明resolve参数的数据类型\n    return new Promise&lt;SpecResult&lt;IMyData&gt;&gt;((resolve, reject) =&gt; &#123;\n        wx.request(&#123;\n            url: &#39;http://121.89.205.189:3000/api&#39; + url,\n            method,\n            data,\n            header,\n            success: (res: SpecResult&lt;IMyData&gt;) =&gt; &#123;\n                resolve(res)\n            &#125;,\n            fail: () =&gt; &#123;\n                reject()\n            &#125;,\n            complete: () =&gt; &#123;\n                // 取消loading动画\n                wx.hideLoading()\n            &#125;\n        &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<pre><code class=\"ts\">// api/home.ts\n// api/home.ts\nimport request from &#39;../utils/request&#39;\nexport function getBannerList () &#123;\n    return  request(&#123;\n        url: &#39;/banner/list&#39;\n    &#125;)\n&#125;\n</code></pre>\n<pre><code class=\"js\">// pages/home/home.ts\nimport &#123; getBannerList &#125; from &#39;../../api/home&#39;\n\n// pages/home/home.ts\nPage(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: []\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() &#123;\n\n  &#125;,\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n\n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n\n  &#125;,\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<p>&#x2F;&#x2F; home 页面下创建组件 components&#x2F;banner&#x2F;Banner</p>\n<pre><code class=\"jspn\">// pages/home/home.json\n&#123;\n  &quot;navigationBarTitleText&quot;: &quot;首页&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;my-banner&quot;: &quot;./components/banner/Banner&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/home.wxml--&gt;\n&lt;!-- 轮播图 --&gt;\n&lt;my-banner list=&quot;&#123;&#123; bannerList &#125;&#125;&quot;&gt;&lt;/my-banner&gt;\n</code></pre>\n<pre><code class=\"ts\">// pages/home/components/banner/Banner.ts\nComponent(&#123;\n  /**\n   * 组件的属性列表\n   */\n  properties: &#123;\n    list: Array\n  &#125;,\n\n  /**\n   * 组件的初始数据\n   */\n  data: &#123;\n\n  &#125;,\n\n  /**\n   * 组件的方法列表\n   */\n  methods: &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/components/banner/Banner.wxml--&gt;\n&lt;swiper \n    class=&quot;bannerSwiper&quot;\n    indicator-dots\n    indicator-color=&quot;#fff&quot;\n    indicator-active-color=&quot;#f66&quot;\n    autoplay\n    interval=&quot;&#123;&#123;3000&#125;&#125;&quot;\n    circular\n&gt;\n    &lt;swiper-item wx:for=&quot;&#123;&#123; list &#125;&#125;&quot; wx:key=&quot;bannerid&quot;&gt;\n        &lt;image src=&quot;&#123;&#123; item.img &#125;&#125;&quot; class=&quot;bannerImg&quot;/&gt;\n    &lt;/swiper-item&gt;\n&lt;/swiper&gt;\n</code></pre>\n<pre><code class=\"css\">/* pages/home/components/banner/Banner.wxss */\n.bannerSwiper &#123;\n    width: 96%;\n    margin: 10px 2%;\n    height: 320rpx;\n    background-color: #ccc;\n    overflow: hidden;\n    border-radius: 10px;\n    .bannerImg &#123;\n        width: 100%;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"1-2-2-构建nav导航\"><a href=\"#1-2-2-构建nav导航\" class=\"headerlink\" title=\"1.2.2 构建nav导航\"></a>1.2.2 构建nav导航</h3><p>&#x2F;&#x2F; home 页面下创建组件 components&#x2F;nav&#x2F;Nav</p>\n<pre><code class=\"ts\">// utils/nav.ts\nconst navList = [\n  &#123; navid: 1, title: &#39;嗨购超市&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/125678/35/5947/4868/5efbf28cEbf04a25a/e2bcc411170524f0.png&#39; &#125;,\n  &#123; navid: 2, title: &#39;数码电器&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/178015/31/13828/6862/60ec0c04Ee2fd63ac/ccf74d805a059a44.png&#39; &#125;,\n  &#123; navid: 3, title: &#39;嗨购服饰&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/41867/2/15966/7116/60ec0e0dE9f50d596/758babcb4f911bf4.png&#39; &#125;,\n  &#123; navid: 4, title: &#39;嗨购生鲜&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/177902/16/13776/5658/60ec0e71E801087f2/a0d5a68bf1461e6d.png&#39; &#125;,\n  &#123; navid: 5, title: &#39;嗨购到家&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/196472/7/12807/7127/60ec0ea3Efe11835b/37c65625d94cae75.png&#39; &#125;,\n  &#123; navid: 6, title: &#39;充值缴费&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/185733/21/13527/6648/60ec0f31E0fea3e0a/d86d463521140bb6.png&#39; &#125;,\n  &#123; navid: 7, title: &#39;9.9元拼&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/36069/14/16068/6465/60ec0f67E155f9488/595ff3e606a53f02.png&#39; &#125;,\n  &#123; navid: 8, title: &#39;领券&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/186080/16/13681/8175/60ec0fcdE032af6cf/c5acd2f8454c40e1.png&#39; &#125;,\n  &#123; navid: 9, title: &#39;领金贴&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/196711/35/12751/6996/60ec1000E21b5bab4/38077313cb9eac4b.png&#39; &#125;,\n  &#123; navid: 10, title: &#39;plus会员&#39;, imgurl: &#39;https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/37709/6/15279/6118/60ec1046E4b5592c6/a7d6b66354efb141.png&#39; &#125;\n]\n\nexport default navList\n</code></pre>\n<pre><code class=\"json\">// pages/home/components/Nav.json\n&#123;\n  &quot;component&quot;: true,\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-grid&quot;: &quot;@vant/weapp/grid/index&quot;,\n    &quot;van-grid-item&quot;: &quot;@vant/weapp/grid-item/index&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"ts\">// pages/home/components/nav/Nav.ts\nComponent(&#123;\n  /**\n   * 组件的属性列表\n   */\n  properties: &#123;\n    list: Array\n  &#125;,\n\n  /**\n   * 组件的初始数据\n   */\n  data: &#123;\n\n  &#125;,\n\n  /**\n   * 组件的方法列表\n   */\n  methods: &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/components/nav/Nav.wxml--&gt;\n&lt;van-grid\n    column-num=&quot;&#123;&#123;5&#125;&#125;&quot;\n    icon-size =&quot;&#123;&#123;44&#125;&#125;&quot;\n    square\n    border=&quot;&#123;&#123;false&#125;&#125;&quot;\n&gt;\n  &lt;van-grid-item wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:key=&quot;navid&quot; icon=&quot;&#123;&#123; item.imgurl &#125;&#125;&quot; text=&quot;&#123;&#123;item.title&#125;&#125;&quot; /&gt;\n&lt;/van-grid&gt;\n</code></pre>\n<pre><code class=\"json\">// pages/home/home.json\n&#123;\n  &quot;navigationBarTitleText&quot;: &quot;首页&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;my-banner&quot;: &quot;./components/banner/Banner&quot;,\n    &quot;my-nav&quot;: &quot;./components/nav/Nav&quot;\n    \n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// pages/home/home.ts\nimport navList from &#39;../../utils/nav&#39;\nimport &#123; getBannerList &#125; from &#39;../../api/home&#39;\n\n// pages/home/home.ts\nPage(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: [],\n    navList: navList\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() &#123;\n\n  &#125;,\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n\n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n\n  &#125;,\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/home.wxml--&gt;\n&lt;!-- 轮播图 --&gt;\n&lt;my-banner list=&quot;&#123;&#123; bannerList &#125;&#125;&quot;&gt;&lt;/my-banner&gt;\n&lt;!-- nav导航 --&gt;\n&lt;my-nav list=&quot;&#123;&#123; navList &#125;&#125;&quot;&gt;&lt;/my-nav&gt;\n</code></pre>\n<blockquote>\n<p>如果项目不出效果，建议清楚缓存之后查看效果</p>\n</blockquote>\n<h3 id=\"1-2-3-秒杀列表\"><a href=\"#1-2-3-秒杀列表\" class=\"headerlink\" title=\"1.2.3 秒杀列表\"></a>1.2.3 秒杀列表</h3><h3 id=\"1-2-4-产品列表展示\"><a href=\"#1-2-4-产品列表展示\" class=\"headerlink\" title=\"1.2.4 产品列表展示\"></a>1.2.4 产品列表展示</h3><p>home 页面下创建组件 components&#x2F;proList&#x2F;ProList</p>\n<pre><code class=\"ts\">// api/home.ts\nimport request from &#39;../utils/request&#39;\ninterface IProParams &#123;\n    limitNum?: number\n    count?: number\n&#125;\nexport function getBannerList () &#123;\n    return  request(&#123;\n        url: &#39;/banner/list&#39;\n    &#125;)\n&#125;\n\nexport function getProList (params?: IProParams) &#123;\n    return  request(&#123;\n        url: &#39;/pro/list&#39;,\n        data: params\n    &#125;)\n&#125;\n</code></pre>\n<pre><code class=\"ts\">// pages/home/home.ts\nimport navList from &#39;../../utils/nav&#39;\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\n\n// pages/home/home.ts\nPage(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: [],\n    navList: navList,\n    proList: []\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() &#123;\n\n  &#125;,\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n\n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n\n  &#125;,\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"json\">&#123;\n  &quot;navigationBarTitleText&quot;: &quot;首页&quot;,\n  &quot;usingComponents&quot;: &#123;\n    &quot;my-banner&quot;: &quot;./components/banner/Banner&quot;,\n    &quot;my-nav&quot;: &quot;./components/nav/Nav&quot;,\n    &quot;pro-list&quot;: &quot;./components/proList/ProList&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/home.wxml--&gt;\n&lt;!-- 轮播图 --&gt;\n&lt;my-banner list=&quot;&#123;&#123; bannerList &#125;&#125;&quot;&gt;&lt;/my-banner&gt;\n&lt;!-- nav导航 --&gt;\n&lt;my-nav list=&quot;&#123;&#123; navList &#125;&#125;&quot;&gt;&lt;/my-nav&gt;\n&lt;!-- 产品列表 --&gt;\n&lt;pro-list list=&quot;&#123;&#123; proList &#125;&#125;&quot;&gt;&lt;/pro-list&gt;\n</code></pre>\n<pre><code class=\"ts\">// pages/home/components/proList/ProList.ts\nComponent(&#123;\n  /**\n   * 组件的属性列表\n   */\n  properties: &#123;\n    list: Array\n  &#125;,\n\n  /**\n   * 组件的初始数据\n   */\n  data: &#123;\n\n  &#125;,\n\n  /**\n   * 组件的方法列表\n   */\n  methods: &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"json\">// pages/home/components/proList/ProList.json\n&#123;\n  &quot;component&quot;: true,\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-card&quot;: &quot;@vant/weapp/card/index&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/components/proList/ProList.wxml--&gt;\n&lt;van-card\n    wx:for=&quot;&#123;&#123; list &#125;&#125;&quot;\n    wx:key=&quot;proid&quot;\n  price=&quot;&#123;&#123; item.originprice &#125;&#125;&quot;\n  title=&quot;&#123;&#123; item.proname &#125;&#125;&quot;\n  thumb=&quot;&#123;&#123; item.img1 &#125;&#125;&quot;\n/&gt;\n</code></pre>\n<h3 id=\"1-2-5-首页实现上拉加载效果\"><a href=\"#1-2-5-首页实现上拉加载效果\" class=\"headerlink\" title=\"1.2.5 首页实现上拉加载效果\"></a>1.2.5 首页实现上拉加载效果</h3><blockquote>\n<p>小程序自带一个上拉加载的实现的事件</p>\n<p>分析接口文档，发现列表的数据，可以分页 <span class=\"exturl\" data-url=\"aHR0cDovLzEyMS44OS4yMDUuMTg5OjMwMDAvYXBpZG9jLyNhcGktUHJvLUdldFByb0xpc3Q=\">http://121.89.205.189:3000/apidoc/#api-Pro-GetProList</span></p>\n<p>只需要不停的变换 页码即可</p>\n</blockquote>\n<pre><code class=\"js\">// pages/home/home.ts\nimport navList from &#39;../../utils/nav&#39;\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\nexport interface IBannerItem &#123;\n  alt: string\n  bannerid: string\n  flag: boolean\n  img: string\n  link: string\n&#125;\nexport interface INavItem &#123;\n  navid: number\n  title: string\n  imgurl: string\n&#125;\nexport interface IPro &#123;\n  banners: string[]\n  brand: string\n  category: string\n  desc: string\n  discount: number\n  img1: string\n  img2: string\n  img3: string\n  img4: string\n  isrecommend: number\n  issale: number\n  isseckill: number\n  originprice: number\n  proid: string\n  proname: string\n  sales: number\n  stock: number\n&#125;\ninterface IData &#123;\n  data: &#123;\n    proList: IPro[]\n    navList: INavItem[]\n    bannerList: IBannerItem[]\n    count: number\n  &#125;\n&#125;\n// pages/home/home.ts\nPage&lt;IData, any&gt;(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: [],\n    navList: navList,\n    proList: [],\n    count: 2\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() &#123;\n\n  &#125;,\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n    \n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n    // console.log(1)\n    getProList(&#123; count: this.data.count &#125;).then(res =&gt; &#123;\n      if (res.data.data.length === 0) &#123;\n        console.log(&#39;没有更多数据了&#39;)\n        wx.showToast(&#123;\n          title: &#39;没有更多数据了&#39;,\n          icon: &#39;none&#39;\n        &#125;)\n      &#125; else &#123;\n        this.setData(&#123;\n          proList: [...this.data.proList, ...res.data.data],\n          count: this.data.count + 1\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;,\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"1-2-6下拉刷新\"><a href=\"#1-2-6下拉刷新\" class=\"headerlink\" title=\"1.2.6下拉刷新\"></a>1.2.6下拉刷新</h3><p>&#x2F;&#x2F; pages&#x2F;home&#x2F;home.json</p>\n<pre><code class=\"json\">&#123;\n  &quot;navigationBarTitleText&quot;: &quot;嗨购-首页&quot;,\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;usingComponents&quot;: &#123;\n    &quot;van-grid&quot;: &quot;@vant/weapp/grid/index&quot;,\n    &quot;van-grid-item&quot;: &quot;@vant/weapp/grid-item/index&quot;,\n    &quot;pro-list&quot;: &quot;/components/proList/proList&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// pages/home/home.ts\nimport navList from &#39;../../utils/nav&#39;\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\nexport interface IBannerItem &#123;\n  alt: string\n  bannerid: string\n  flag: boolean\n  img: string\n  link: string\n&#125;\nexport interface INavItem &#123;\n  navid: number\n  title: string\n  imgurl: string\n&#125;\nexport interface IPro &#123;\n  banners: string[]\n  brand: string\n  category: string\n  desc: string\n  discount: number\n  img1: string\n  img2: string\n  img3: string\n  img4: string\n  isrecommend: number\n  issale: number\n  isseckill: number\n  originprice: number\n  proid: string\n  proname: string\n  sales: number\n  stock: number\n&#125;\ninterface IData &#123;\n  data: &#123;\n    proList: IPro[]\n    navList: INavItem[]\n    bannerList: IBannerItem[]\n    count: number\n  &#125;\n&#125;\n// pages/home/home.ts\nPage&lt;IData, any&gt;(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: [],\n    navList: navList,\n    proList: [],\n    count: 2\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() &#123;\n\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() &#123;\n\n  &#125;,\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data,\n        count: 2\n      &#125;)\n      wx.stopPullDownRefresh()\n    &#125;)\n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n    // console.log(1)\n    getProList(&#123; count: this.data.count &#125;).then(res =&gt; &#123;\n      if (res.data.data.length === 0) &#123;\n        console.log(&#39;没有更多数据了&#39;)\n        wx.showToast(&#123;\n          title: &#39;没有更多数据了&#39;,\n          icon: &#39;none&#39;\n        &#125;)\n      &#125; else &#123;\n        this.setData(&#123;\n          proList: [...this.data.proList, ...res.data.data],\n          count: this.data.count + 1\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;,\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() &#123;\n\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"1-2-7-返回顶部\"><a href=\"#1-2-7-返回顶部\" class=\"headerlink\" title=\"1.2.7 返回顶部\"></a>1.2.7 返回顶部</h3><p>&#x2F;&#x2F; pages&#x2F;home&#x2F;home.json</p>\n<pre><code class=\"json\">&#123;\n  &quot;navigationBarTitleText&quot;: &quot;首页&quot;,\n  &quot;enablePullDownRefresh&quot;: true,\n  &quot;usingComponents&quot;: &#123;\n    &quot;my-banner&quot;: &quot;./components/banner/Banner&quot;,\n    &quot;my-nav&quot;: &quot;./components/nav/Nav&quot;,\n    &quot;pro-list&quot;: &quot;./components/proList/ProList&quot;,\n    &quot;van-icon&quot;: &quot;@vant/weapp/icon/index&quot;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"html\">&lt;!--pages/home/home.wxml--&gt;\n&lt;!-- 轮播图 --&gt;\n&lt;my-banner list=&quot;&#123;&#123; bannerList &#125;&#125;&quot;&gt;&lt;/my-banner&gt;\n&lt;!-- nav导航 --&gt;\n&lt;my-nav list=&quot;&#123;&#123; navList &#125;&#125;&quot;&gt;&lt;/my-nav&gt;\n&lt;!-- 产品列表 --&gt;\n&lt;pro-list list=&quot;&#123;&#123; proList &#125;&#125;&quot;&gt;&lt;/pro-list&gt;\n\n&lt;view \n    class=&quot;backTop&quot;\n    bindtap=&quot;backTop&quot;\n    wx:if=&quot;&#123;&#123; scrollTop > 300 &#125;&#125;&quot;\n&gt;\n    &lt;van-icon name=&quot;arrow-up&quot; size=&quot;24&quot;/&gt;\n&lt;/view&gt;\n</code></pre>\n<pre><code class=\"typescript\">// pages/home/home.ts\nimport navList from &#39;../../utils/nav&#39;\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\nexport interface IBannerItem &#123;\n  alt: string\n  bannerid: string\n  flag: boolean\n  img: string\n  link: string\n&#125;\nexport interface INavItem &#123;\n  navid: number\n  title: string\n  imgurl: string\n&#125;\nexport interface IPro &#123;\n  banners: string[]\n  brand: string\n  category: string\n  desc: string\n  discount: number\n  img1: string\n  img2: string\n  img3: string\n  img4: string\n  isrecommend: number\n  issale: number\n  isseckill: number\n  originprice: number\n  proid: string\n  proname: string\n  sales: number\n  stock: number\n&#125;\ninterface IData &#123;\n  data: &#123;\n    proList: IPro[]\n    navList: INavItem[]\n    bannerList: IBannerItem[]\n    count: number\n    scrollTop: number\n  &#125;\n&#125;\n// pages/home/home.ts\nPage&lt;IData, any&gt;(&#123;\n\n  /**\n   * 页面的初始数据\n   */\n  data: &#123;\n    bannerList: [],\n    navList: navList,\n    proList: [],\n    count: 2,\n    scrollTop: 0\n  &#125;,\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad() &#123;\n    getBannerList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        bannerList: res.data.data\n      &#125;)\n    &#125;)\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data\n      &#125;)\n    &#125;)\n  &#125;,\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() &#123;\n    getProList().then((res) =&gt; &#123;\n      this.setData(&#123;\n        proList: res.data.data,\n        count: 2\n      &#125;)\n      wx.stopPullDownRefresh()\n    &#125;)\n  &#125;,\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() &#123;\n    // console.log(1)\n    getProList(&#123; count: this.data.count &#125;).then(res =&gt; &#123;\n      if (res.data.data.length === 0) &#123;\n        console.log(&#39;没有更多数据了&#39;)\n        wx.showToast(&#123;\n          title: &#39;没有更多数据了&#39;,\n          icon: &#39;none&#39;\n        &#125;)\n      &#125; else &#123;\n        this.setData(&#123;\n          proList: [...this.data.proList, ...res.data.data],\n          count: this.data.count + 1\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;,\n  backTop () &#123;\n    // https://developers.weixin.qq.com/miniprogram/dev/api/ui/scroll/wx.pageScrollTo.html\n    wx.pageScrollTo(&#123;\n      scrollTop: 0,\n      duration: 500\n    &#125;)\n  &#125;,\n  onPageScroll (&#123; scrollTop &#125;: &#123; scrollTop: number &#125;) &#123;\n    this.setData(&#123;\n      scrollTop\n    &#125;)\n  &#125;\n  \n&#125;)\n</code></pre>\n<pre><code class=\"css\">/* pages/home/home.wxss */\n.backTop &#123;\n    position: fixed;\n    bottom: 10px;\n    right: 10px;\n    width: 32px;\n    height: 32px;\n    border: 1rpx solid #ccc;\n    background-color: #fff;\n    border-radius: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n&#125;\n</code></pre>\n",
            "tags": [
                "微信小程序",
                "wxapp",
                "ts"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/wx-app/day2/",
            "url": "https://www.yexingcheng.com/wx-app/day2/",
            "title": "微信小程序学习第二天",
            "date_published": "2022-10-31T16:00:00.000Z",
            "content_html": "<h1 id=\"8-小程序代码的构成\"><a href=\"#8-小程序代码的构成\" class=\"headerlink\" title=\"8.小程序代码的构成\"></a>8.小程序代码的构成</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay8=\">https://developers.weixin.qq.com/miniprogram/dev/framework/</span></p>\n<blockquote>\n<p>学习思路，从起步 - 小程序代码构成 开始，如果见到有链接，就跳转过去学习完整的知识</p>\n</blockquote>\n<h2 id=\"8-1-JSON配置\"><a href=\"#8-1-JSON配置\" class=\"headerlink\" title=\"8.1 JSON配置\"></a>8.1 JSON配置</h2><p>JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色</p>\n<h3 id=\"8-1-1-小程序的配置-app-json\"><a href=\"#8-1-1-小程序的配置-app-json\" class=\"headerlink\" title=\"8.1.1 小程序的配置 app.json\"></a>8.1.1 小程序的配置 app.json</h3><p><code>app.json</code> 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb25maWcuaHRtbA==\">https://developers.weixin.qq.com/miniprogram/dev/framework/config.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1s\">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html</span></p>\n<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2VudHJ5UGFnZVBhdGg=\">entryPagePath</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">小程序默认启动首页</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3BhZ2Vz\">pages</span></td>\n<td align=\"left\">string[]</td>\n<td align=\"left\">是</td>\n<td align=\"left\">页面路径列表</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3dpbmRvdw==\">window</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">全局的默认窗口表现</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3RhYkJhcg==\">tabBar</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">底部 <code>tab</code> 栏的表现</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI25ldHdvcmtUaW1lb3V0\">networkTimeout</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">网络超时时间</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2RlYnVn\">debug</span></td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是否开启 debug 模式，默认关闭</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2Z1bmN0aW9uYWxQYWdlcw==\">functionalPages</span></td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是否启用插件功能页，默认关闭</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.1.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3N1YnBhY2thZ2Vz\">subpackages</span></td>\n<td align=\"left\">Object[]</td>\n<td align=\"left\">否</td>\n<td align=\"left\">分包结构配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.7.3</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3dvcmtlcnM=\">workers</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\"><code>Worker</code> 代码放置的目录</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.9.90</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3JlcXVpcmVkQmFja2dyb3VuZE1vZGVz\">requiredBackgroundModes</span></td>\n<td align=\"left\">string[]</td>\n<td align=\"left\">否</td>\n<td align=\"left\">需要在后台使用的能力，如「音乐播放」</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3BsdWdpbnM=\">plugins</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">使用到的插件</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.9.6</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3ByZWxvYWRSdWxl\">preloadRule</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">分包预下载规则</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.3.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3Jlc2l6YWJsZQ==\">resizable</span></td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.3.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3VzaW5nQ29tcG9uZW50cw==\">usingComponents</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">全局<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jdXN0b20tY29tcG9uZW50Lw==\">自定义组件</span>配置</td>\n<td align=\"left\">开发者工具 1.02.1810190</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3Blcm1pc3Npb24=\">permission</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">小程序接口权限相关设置</td>\n<td align=\"left\">微信客户端 7.0.0</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3NpdGVtYXBMb2NhdGlvbg==\">sitemapLocation</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">是</td>\n<td align=\"left\">指明 sitemap.json 的位置</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3N0eWxl\">style</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">指定使用升级后的 weui 样式</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.8.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3VzZWV4dGVuZGVkbGli\">useExtendedLib</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">指定需要引用的扩展库</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.2.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2VudHJhbmNlRGVjbGFyZQ==\">entranceDeclare</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">微信消息用小程序打开</td>\n<td align=\"left\">微信客户端 7.0.9</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2Rhcmttb2Rl\">darkmode</span></td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">小程序支持 DarkMode</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.11.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3RoZW1lTG9jYXRpb24=\">themeLocation</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">指明 theme.json 的位置，darkmode为 true 为必填</td>\n<td align=\"left\">开发者工具 1.03.2004271</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2xhenlDb2RlTG9hZGluZw==\">lazyCodeLoading</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">配置自定义组件代码按需注入</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.11.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3NpbmdsZVBhZ2U=\">singlePage</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">单页模式相关配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.12.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">supportedMaterials</td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9tYXRlcmlhbC9zdXBwb3J0X21hdGVyaWFsLmh0bWw=\">聊天素材小程序打开</span>相关配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.14.3</span></td>\n</tr>\n<tr>\n<td align=\"left\">serviceProviderTicket</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL29wZXJhdGlvbi90aGlyZHBhcnR5L2N1c3RvbWl6ZWRfc2VydmljZV9wbGF0Zm9ybV9ndWlkZWxpbmVzLmh0bWw=\">定制化型服务商</span>票据</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2VtYmVkZGVkQXBwSWRMaXN0\">embeddedAppIdList</span></td>\n<td align=\"left\">string[]</td>\n<td align=\"left\">否</td>\n<td align=\"left\">半屏小程序 appId</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.20.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2hhbGZQYWdl\">halfPage</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">视频号直播半屏场景设置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.18.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2RlYnVnT3B0aW9ucw==\">debugOptions</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">调试相关配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.22.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI2VuYWJsZVBhc3NpdmVFdmVudA==\">enablePassiveEvent</span></td>\n<td align=\"left\">Object或boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">touch 事件监听是否为 passive</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.24.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3Jlc29sdmVBbGlhcw==\">resolveAlias</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">自定义模块映射规则</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>entryPagePath</strong></li>\n</ul>\n<p>设置小程序默认的启动页面，如果不作设置，那么将会取pages数组 的第一项为默认启动项，开发过程中，一般不建议这么使用，你可以使用开发者工具中 添加编译模式 快速解决问题</p>\n<p><img data-src=\"/wx-app/day2/13.png\" alt=\"image-20220530113321490\"></p>\n<p><img data-src=\"/wx-app/day2/14.png\" alt=\"image-20220530113402566\"></p>\n<ul>\n<li><strong>pages</strong></li>\n</ul>\n<p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。</p>\n<p>如何给小程序快速添加页面,写好页面后直接保存即可</p>\n<pre><code class=\"json\">&#123;\n &quot;pages&quot;:[\n    &quot;pages/home/home&quot;,\n    &quot;pages/index/index&quot;,\n    &quot;pages/logs/logs&quot;,\n    &quot;pages/kind/kind&quot;,\n    &quot;pages/cart/cart&quot;,\n    &quot;pages/user/user&quot;\n  ],\n  ...\n&#125;\n</code></pre>\n<ul>\n<li><strong>window</strong></li>\n</ul>\n<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">navigationBarBackgroundColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">#000000</td>\n<td align=\"left\">导航栏背景颜色，如 <code>#000000</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationBarTextStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">white</td>\n<td align=\"left\">导航栏标题颜色，仅支持 <code>black</code> &#x2F; <code>white</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationBarTitleText</td>\n<td align=\"left\">string</td>\n<td align=\"left\"></td>\n<td align=\"left\">导航栏标题文字内容</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">default</td>\n<td align=\"left\">导航栏样式，仅支持以下值： <code>default</code> 默认样式 <code>custom</code> 自定义导航栏，只保留右上角胶囊按钮。参见注 2。</td>\n<td align=\"left\">iOS&#x2F;Android 微信客户端 6.6.0，Windows 微信客户端不支持</td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">窗口的背景色</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">backgroundTextStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">dark</td>\n<td align=\"left\">下拉 loading 的样式，仅支持 <code>dark</code> &#x2F; <code>light</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColorTop</td>\n<td align=\"left\">string</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">顶部窗口的背景色，仅 iOS 支持</td>\n<td align=\"left\">微信客户端 6.5.16</td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColorBottom</td>\n<td align=\"left\">string</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">底部窗口的背景色，仅 iOS 支持</td>\n<td align=\"left\">微信客户端 6.5.16</td>\n</tr>\n<tr>\n<td align=\"left\">enablePullDownRefresh</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">false</td>\n<td align=\"left\">是否开启全局的下拉刷新。 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29ucHVsbGRvd25yZWZyZXNo\">Page.onPullDownRefresh</span></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">onReachBottomDistance</td>\n<td align=\"left\">number</td>\n<td align=\"left\">50</td>\n<td align=\"left\">页面上拉触底事件触发时距页面底部距离，单位为 px。 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29ucmVhY2hib3R0b20=\">Page.onReachBottom</span></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">pageOrientation</td>\n<td align=\"left\">string</td>\n<td align=\"left\">portrait</td>\n<td align=\"left\">屏幕旋转设置，支持 <code>auto</code> &#x2F; <code>portrait</code> &#x2F; <code>landscape</code> 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L3Jlc2l6YWJsZS5odG1s\">响应显示区域变化</span></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.4.0</span> (auto) &#x2F; <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.5.0</span> (landscape)</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1sI3Jlc3RhcnRTdHJhdGVneQ==\">restartStrategy</span></td>\n<td align=\"left\">string</td>\n<td align=\"left\">homePage</td>\n<td align=\"left\">重新启动策略配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.8.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">initialRenderingCache</td>\n<td align=\"left\">string</td>\n<td align=\"left\"></td>\n<td align=\"left\">页面<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L2luaXRpYWwtcmVuZGVyaW5nLWNhY2hlLmh0bWw=\">初始渲染缓存</span>配置，支持 <code>static</code> &#x2F; <code>dynamic</code></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.11.1</span></td>\n</tr>\n<tr>\n<td align=\"left\">visualEffectInBackground</td>\n<td align=\"left\">string</td>\n<td align=\"left\">none</td>\n<td align=\"left\">切入系统后台时，隐藏页面内容，保护用户隐私。支持 <code>hidden</code> &#x2F; <code>none</code></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.15.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">handleWebviewPreload</td>\n<td align=\"left\">string</td>\n<td align=\"left\">static</td>\n<td align=\"left\">控制<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9wZXJmb3JtYW5jZS90aXBzL3J1bnRpbWVfbmF2Lmh0bWwjXzItNC0lRTYlOEUlQTclRTUlODglQjYlRTklQTIlODQlRTUlOEElQTAlRTglQkQlQkQlRTQlQjglOEIlRTQlQjglQUElRTklQTElQjUlRTklOUQlQTIlRTclOUElODQlRTYlOTclQjYlRTYlOUMlQkE=\">预加载下个页面的时机</span>。支持 <code>static</code> &#x2F; <code>manual</code> &#x2F; <code>auto</code></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.15.0</span></td>\n</tr>\n</tbody></table>\n<pre><code class=\"json\">&#123;\n ...,\n &quot;window&quot;: &#123;\n        &quot;navigationBarBackgroundColor&quot;: &quot;#f66&quot;,\n        &quot;navigationBarTextStyle&quot;: &quot;white&quot;,\n        &quot;navigationBarTitleText&quot;: &quot;嗨购&quot;,\n        &quot;navigationStyle&quot;: &quot;default&quot;,\n        &quot;homeButton&quot;: true,\n        &quot;backgroundColor&quot;: &quot;#123123&quot;,\n        &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n        &quot;enablePullDownRefresh&quot;: true,\n        &quot;pageOrientation&quot;: &quot;portrait&quot;\n      &#125;,\n  ....\n&#125;\n</code></pre>\n<ul>\n<li><strong>tabBar</strong></li>\n</ul>\n<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">color</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">是</td>\n<td align=\"left\"></td>\n<td align=\"left\">tab 上的文字默认颜色，仅支持十六进制颜色</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">selectedColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">是</td>\n<td align=\"left\"></td>\n<td align=\"left\">tab 上的文字选中时的颜色，仅支持十六进制颜色</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">是</td>\n<td align=\"left\"></td>\n<td align=\"left\">tab 的背景色，仅支持十六进制颜色</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">borderStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">black</td>\n<td align=\"left\">tabbar 上边框的颜色， 仅支持 <code>black</code> &#x2F; <code>white</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">list</td>\n<td align=\"left\">Array</td>\n<td align=\"left\">是</td>\n<td align=\"left\"></td>\n<td align=\"left\">tab 的列表，详见 <code>list</code> 属性说明，最少 2 个、最多 5 个 tab</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">position</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">bottom</td>\n<td align=\"left\">tabBar 的位置，仅支持 <code>bottom</code> &#x2F; <code>top</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">custom</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">false</td>\n<td align=\"left\">自定义 tabBar，见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9hYmlsaXR5L2N1c3RvbS10YWJiYXIuaHRtbA==\">详情</span></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.5.0</span></td>\n</tr>\n</tbody></table>\n<p>其中 list 接受一个数组，<strong>只能配置最少 2 个、最多 5 个 tab</strong>。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">pagePath</td>\n<td align=\"left\">string</td>\n<td align=\"left\">是</td>\n<td align=\"left\">页面路径，必须在 pages 中先定义</td>\n</tr>\n<tr>\n<td align=\"left\">text</td>\n<td align=\"left\">string</td>\n<td align=\"left\">是</td>\n<td align=\"left\">tab 上按钮文字</td>\n</tr>\n<tr>\n<td align=\"left\">iconPath</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 <strong>当 <code>position</code> 为 <code>top</code> 时，不显示 icon。</strong></td>\n</tr>\n<tr>\n<td align=\"left\">selectedIconPath</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 <strong>当 <code>position</code> 为 <code>top</code> 时，不显示 icon。</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如何获取项目需要的图片</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvbmZvbnQuY24v\">https://www.iconfont.cn/</span></p>\n<p>搜索图标 - 加入购物车 - 点击购物车 - 下载素材</p>\n<p>输入颜色 #333333 和 #ff6666。选择大小为81px，下载png图片即可</p>\n</blockquote>\n<pre><code class=\"json\">&#123;\n ...,\n &quot;tabBar&quot;: &#123;\n        &quot;color&quot;: &quot;#333&quot;,\n        &quot;selectedColor&quot;: &quot;#f66&quot;,\n        &quot;backgroundColor&quot;: &quot;#efefef&quot;,\n        &quot;borderStyle&quot;: &quot;black&quot;,\n        &quot;list&quot;: [\n          &#123;\n            &quot;pagePath&quot;: &quot;pages/home/home&quot;,\n            &quot;text&quot;: &quot;首页&quot;,\n            &quot;iconPath&quot;: &quot;resources/tabBar/home.png&quot;,\n            &quot;selectedIconPath&quot;: &quot;resources/tabBar/home_active.png&quot;\n          &#125;,\n          &#123;\n            &quot;pagePath&quot;: &quot;pages/kind/kind&quot;,\n            &quot;text&quot;: &quot;分类&quot;,\n            &quot;iconPath&quot;: &quot;resources/tabBar/kind.png&quot;,\n            &quot;selectedIconPath&quot;: &quot;resources/tabBar/kind_active.png&quot;\n          &#125;,\n          &#123;\n            &quot;pagePath&quot;: &quot;pages/cart/cart&quot;,\n            &quot;text&quot;: &quot;购物车&quot;,\n            &quot;iconPath&quot;: &quot;resources/tabBar/cart.png&quot;,\n            &quot;selectedIconPath&quot;: &quot;resources/tabBar/cart_active.png&quot;\n          &#125;,\n          &#123;\n            &quot;pagePath&quot;: &quot;pages/user/user&quot;,\n            &quot;text&quot;: &quot;我的&quot;,\n            &quot;iconPath&quot;: &quot;resources/tabBar/user.png&quot;,\n            &quot;selectedIconPath&quot;: &quot;resources/tabBar/user_active.png&quot;\n          &#125;\n        ]\n      &#125;,\n  ...\n&#125;\n</code></pre>\n<ul>\n<li><strong>networkTimeout</strong></li>\n</ul>\n<p>各类网络请求的超时时间，单位均为毫秒。</p>\n<pre><code class=\"json\">&#123;\n ...,\n &quot;networkTimeout&quot;: &#123;\n        &quot;request&quot;: 6000,\n        &quot;connectSocket&quot;: 4000,\n        &quot;uploadFile&quot;: 600000,\n        &quot;downloadFile&quot;: 6000000\n      &#125;,\n  ....\n&#125;\n</code></pre>\n<ul>\n<li>debug</li>\n</ul>\n<p>可以在开发者工具中开启 <code>debug</code> 模式，在开发者工具的控制台面板，调试信息以 <code>info</code> 的形式给出，其信息有 Page 的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。</p>\n<pre><code>&#123;\n ...,\n &quot;debug&quot;: false,\n ....\n&#125;\n</code></pre>\n<blockquote>\n<p>底部tab选项卡对应的页面，会自动添加类似vue中的 keep-alive的功能，原来的activated 和 deactivated 分别对应小程序中的。onShow 和 onHide</p>\n</blockquote>\n<ul>\n<li><strong>subpackages</strong></li>\n</ul>\n<p>启用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9zdWJwYWNrYWdlcy5odG1s\">分包加载</span>时，声明项目分包结构。</p>\n<blockquote>\n<p>分包加载：</p>\n<ul>\n<li>整个小程序所有分包大小不超过 20M</li>\n<li>单个分包&#x2F;主包大小不能超过 2M</li>\n</ul>\n<p><strong>使用分包</strong></p>\n<p><strong>独立分包</strong></p>\n<pre><code class=\"json\">&quot;subPackages&quot;: [\n    &#123;\n      &quot;root&quot;: &quot;pckSearch&quot;,\n      &quot;name&quot;: &quot;search&quot;,\n      &quot;pages&quot;: [\n        &quot;pages/search/search&quot;,\n        &quot;pages/result/result&quot;\n      ],\n      &quot;independent&quot;: true \n    &#125;,\n    &#123;\n      &quot;root&quot;: &quot;pckUser&quot;,\n      &quot;name&quot;: &quot;user&quot;,\n      &quot;pages&quot;: [\n        &quot;pages/login/login&quot;,\n        &quot;pages/register/register&quot;\n      ]\n    &#125;\n  ],\n  &quot;debug&quot;: true,\n</code></pre>\n<blockquote>\n<p><strong>开启debug模式，添加编译模式，调试分包的页面，观察 独立分包和 非独立分包的效果，通过控制台的console查看</strong></p>\n</blockquote>\n<p><strong>分包预下载</strong></p>\n<p>开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。</p>\n<blockquote>\n<p>做一个电商类型的小程序，大部分的用户一定回去搜索，所以可以把搜索相关业务写到分包，当用户打开主包时，预下载 搜索的分包</p>\n</blockquote>\n<pre><code class=\"json\">&#123;\n ...,\n &quot;subPackages&quot;: [\n        &#123;\n          &quot;root&quot;: &quot;pckSearch&quot;,\n          &quot;name&quot;: &quot;pckSearch&quot;,\n          &quot;pages&quot;: [\n            &quot;pages/search/search&quot;,\n            &quot;pages/result/result&quot;\n          ],\n          &quot;independent&quot;: true \n        &#125;,\n        &#123;\n          &quot;root&quot;: &quot;pckUser&quot;,\n          &quot;name&quot;: &quot;pckUser&quot;,\n          &quot;pages&quot;: [\n            &quot;pages/login/login&quot;,\n            &quot;pages/register/register&quot;\n          ]\n        &#125;\n      ],\n     &quot;preloadRule&quot;: &#123;\n       &quot;pages/home/home&quot;: &#123;\n         &quot;network&quot;: &quot;all&quot;,\n         &quot;packages&quot;: [\n          &quot;pckSearch&quot;\n         ]\n       &#125;\n     &#125;,\n  ...\n&#125;\n</code></pre>\n</blockquote>\n<p>整体的全局配置文件如下：</p>\n<pre><code class=\"json\">&#123;\n  &quot;pages&quot;: [\n    &quot;pages/home/home&quot;,\n    &quot;pages/kind/kind&quot;,\n    &quot;pages/cart/cart&quot;,\n    &quot;pages/user/user&quot;,\n    &quot;pages/detail/detail&quot;,\n    &quot;pages/index/index&quot;,\n    &quot;pages/logs/logs&quot;\n  ],\n  &quot;window&quot;: &#123;\n    &quot;navigationBarBackgroundColor&quot;: &quot;#f66&quot;,\n    &quot;navigationBarTextStyle&quot;: &quot;white&quot;,\n    &quot;navigationBarTitleText&quot;: &quot;嗨购&quot;,\n    &quot;navigationStyle&quot;: &quot;default&quot;,\n    &quot;backgroundColor&quot;: &quot;#efefef&quot;,\n    &quot;backgroundTextStyle&quot;: &quot;dark&quot;,\n    &quot;restartStrategy&quot;: &quot;homePageAndLatestPage&quot;,\n    &quot;visualEffectInBackground&quot;: &quot;hidden&quot;\n  &#125;,\n  &quot;tabBar&quot;: &#123;\n    &quot;color&quot;: &quot;#333&quot;,\n    &quot;selectedColor&quot;: &quot;#f66&quot;,\n    &quot;backgroundColor&quot;: &quot;#efefef&quot;,\n    &quot;borderStyle&quot;: &quot;black&quot;,\n    &quot;list&quot;: [\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/home/home&quot;,\n        &quot;text&quot;: &quot;首页&quot;,\n        &quot;iconPath&quot;: &quot;tabBar/home.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;tabBar/home_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/kind/kind&quot;,\n        &quot;text&quot;: &quot;分类&quot;,\n        &quot;iconPath&quot;: &quot;tabBar/kind.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;tabBar/kind_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/cart/cart&quot;,\n        &quot;text&quot;: &quot;购物车&quot;,\n        &quot;iconPath&quot;: &quot;tabBar/cart.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;tabBar/cart_active.png&quot;\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/user/user&quot;,\n        &quot;text&quot;: &quot;我的&quot;,\n        &quot;iconPath&quot;: &quot;tabBar/user.png&quot;,\n        &quot;selectedIconPath&quot;: &quot;tabBar/user_active.png&quot;\n      &#125;\n    ]\n  &#125;,\n  &quot;networkTimeout&quot;: &#123;\n    &quot;request&quot;: 6000,\n    &quot;connectSocket&quot;: 6000,\n    &quot;uploadFile&quot;: 60000,\n    &quot;downloadFile&quot;: 60000\n  &#125;,\n  &quot;subpackages&quot;: [\n    &#123;\n      &quot;root&quot;: &quot;packageSearch&quot;,\n      &quot;name&quot;: &quot;packageSearch&quot;,\n      &quot;independent&quot;: true,\n      &quot;pages&quot;: [\n        &quot;pages/search/search&quot;,\n        &quot;pages/result/result&quot;\n      ]\n    &#125;,\n    &#123;\n      &quot;root&quot;: &quot;packageUser&quot;,\n      &quot;name&quot;: &quot;packageUser&quot;,\n      &quot;pages&quot;: [\n        &quot;pages/register/register&quot;,\n        &quot;pages/login/login&quot;\n      ]\n    &#125;\n  ],\n  &quot;preloadRule&quot;: &#123;\n    &quot;pages/home/home&quot;: &#123;\n      &quot;network&quot;: &quot;all&quot;,\n      &quot;packages&quot;: [&quot;packageSearch&quot;]\n    &#125;\n  &#125;,\n  &quot;debug&quot;: false,\n  &quot;style&quot;: &quot;v2&quot;,\n  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;\n&#125;\n</code></pre>\n<h3 id=\"8-1-2-工具配置-project-config-json\"><a href=\"#8-1-2-工具配置-project-config-json\" class=\"headerlink\" title=\"8.1.2 工具配置 project.config.json\"></a>8.1.2 工具配置 project.config.json</h3><h2 id=\"项目配置文件\"><a href=\"#项目配置文件\" class=\"headerlink\" title=\"项目配置文件\"></a>项目配置文件</h2><ol>\n<li>项目根目录中的 <code>project.config.json</code> 和 <code>project.private.config.json</code> 文件可以对项目进行配置，</li>\n<li><code>project.private.config.json</code> 中的相同设置优先级高于 <code>project.config.json</code></li>\n<li>可以在 <code>project.config.json</code> 文件中配置公共的配置，在 <code>project.private.config.json</code> 配置个人的配置，可以将 <code>project.private.config.json</code> 写到 <code>.gitignore</code> 避免版本管理的冲突。</li>\n<li><code>project.private.config.json</code> 中有的字段，开发者工具内的设置修改会优先覆盖 <code>project.private.config.json</code> 的内容。如在 <code>project.private.config.json</code> 有 <code>appid</code> 字段，那么在 详情 - 基本信息 中修改了 appid，会写到 <code>project.private.config.json</code> 中，不会覆盖掉 <code>project.config.json</code> 的 <code>appid</code> 字段的内容</li>\n<li>开发阶段相关的设置修改优先同步到 <code>project.private.config.json</code> 中，但与最终编译产物有关的设置无法在 <code>project.private.config.json</code> 中生效，界面上的改动也不会同步到 <code>project.private.config.json</code> 文件中。详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNzZXR0aW5n\">表格</span> 是否允许私有设置。</li>\n</ol>\n<h2 id=\"一级字段\"><a href=\"#一级字段\" class=\"headerlink\" title=\"一级字段\"></a>一级字段</h2><p>可以在项目根目录使用 <code>project.config.json</code> 文件对项目进行配置。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">miniprogramRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">指定小程序源码的目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">qcloudRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">指定腾讯云项目的目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">pluginRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">指定插件项目的目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">cloudbaseRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">云开发代码根目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">cloudfunctionRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">云函数代码根目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">cloudfunctionTemplateRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">云函数本地调试请求模板的根目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\">cloudcontainerRoot</td>\n<td align=\"left\">Path String</td>\n<td align=\"left\">云托管代码根目录(需为相对路径)</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNjb21waWxlVHlwZQ==\">compileType</span></td>\n<td align=\"left\">String</td>\n<td align=\"left\">编译类型</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNzZXR0aW5n\">setting</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">项目设置</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNsaWJWZXJzaW9u\">libVersion</span></td>\n<td align=\"left\">String</td>\n<td align=\"left\">基础库版本</td>\n</tr>\n<tr>\n<td align=\"left\">appid</td>\n<td align=\"left\">String</td>\n<td align=\"left\">项目的 appid</td>\n</tr>\n<tr>\n<td align=\"left\">projectname</td>\n<td align=\"left\">String</td>\n<td align=\"left\">项目名字</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNwYWNrT3B0aW9ucw==\">packOptions</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">打包配置选项</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNkZWJ1Z09wdGlvbnM=\">debugOptions</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">调试配置选项</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCN3YXRjaE9wdGlvbnM=\">watchOptions</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">文件监听配置设置</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNzY3JpcHRz\">scripts</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">自定义预处理</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaWdhbWUvZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcjc3RhdGljU2VydmVyT3B0aW9ucw==\">staticServerOptions</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">仅在小游戏项目中有效</td>\n</tr>\n</tbody></table>\n<h3 id=\"compileType\"><a href=\"#compileType\" class=\"headerlink\" title=\"compileType\"></a>compileType</h3><p>编译类型作用于开发工具的以下设置</p>\n<p><img data-src=\"/wx-app/day2/image-20221101090136819.png\" alt=\"image-20221101090136819\"></p>\n<p>有效值</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名字</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">miniprogram</td>\n<td align=\"left\">当前为普通小程序项目</td>\n</tr>\n<tr>\n<td align=\"left\">plugin</td>\n<td align=\"left\">当前为小程序插件项目</td>\n</tr>\n</tbody></table>\n<h3 id=\"setting\"><a href=\"#setting\" class=\"headerlink\" title=\"setting\"></a>setting</h3><p>项目的编译设置，可以指定以下设置。部分设置无法在 <code>project.private.config.json</code> 中生效</p>\n<p>以下字段可以开发者工具 - 详情 - 本地设置可以对应上</p>\n<p><img data-src=\"/wx-app/day2/image-20221101090621855.png\" alt=\"image-20221101090621855\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">允许私有设置[1]</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">es6</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是否启用 es6 转 es5[2]</td>\n</tr>\n<tr>\n<td align=\"left\">enhance</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是否打开增强编译[2]</td>\n</tr>\n<tr>\n<td align=\"left\">postcss</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传代码时样式是否自动补全</td>\n</tr>\n<tr>\n<td align=\"left\">minified</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传代码时是否自动压缩脚本文件</td>\n</tr>\n<tr>\n<td align=\"left\">minifyWXSS</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传代码时是否自动压缩样式文件</td>\n</tr>\n<tr>\n<td align=\"left\">minifyWXML</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传代码时是否自动压缩 WXML 文件</td>\n</tr>\n<tr>\n<td align=\"left\">uglifyFileName</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传时进行代码保护</td>\n</tr>\n<tr>\n<td align=\"left\">ignoreUploadUnusedFiles</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传时是否过滤无依赖文件</td>\n</tr>\n<tr>\n<td align=\"left\">autoAudits</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否自动运行体验评分</td>\n</tr>\n<tr>\n<td align=\"left\">urlCheck</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否检查安全域名和 TLS 版本</td>\n</tr>\n<tr>\n<td align=\"left\">compileHotReLoad</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否开启文件保存后自动热重载</td>\n</tr>\n<tr>\n<td align=\"left\">preloadBackgroundData</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">小程序加载时是否数据预拉取</td>\n</tr>\n<tr>\n<td align=\"left\">lazyloadPlaceholderEnable</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否启用懒注入占位组件调试[3]</td>\n</tr>\n<tr>\n<td align=\"left\">useStaticServer</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">仅在小游戏项目有效，是否开启静态资源服务器[4]</td>\n</tr>\n<tr>\n<td align=\"left\">bigPackageSizeSupport</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">预览及真机调试的时主包、分包体积上限调整为4M（小程序）、8M（小游戏）</td>\n</tr>\n</tbody></table>\n<p>以下字段是开发者工具的隐式设置</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">允许私有设置[1]</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCNiYWJlbFNldHRpbmc=\">babelSetting</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">增强编译下 Babel 的配置项</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL3Byb2plY3Rjb25maWcuaHRtbCN1c2VDb21waWxlclBsdWdpbnM=\">useCompilerPlugins</span></td>\n<td align=\"left\">String[] 或 false</td>\n<td align=\"left\">否</td>\n<td align=\"left\">编译插件配置</td>\n</tr>\n<tr>\n<td align=\"left\">disableUseStrict</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">将 JS 编译成 ES5 时，是否禁用严格模式</td>\n</tr>\n<tr>\n<td align=\"left\">uploadWithSourceMap</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">上传时是否带上 sourcemap（默认为true）</td>\n</tr>\n<tr>\n<td align=\"left\">localPlugins</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">在小游戏插件项目中，是否启用 “以本地目录为插件资源来源”[5] 特性</td>\n</tr>\n<tr>\n<td align=\"left\">packNpmManually</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是否手动配置构建 npm 的路径</td>\n</tr>\n<tr>\n<td align=\"left\">packNpmRelationList</td>\n<td align=\"left\">Array</td>\n<td align=\"left\">否</td>\n<td align=\"left\">仅 <code>packNpmManually</code> 为 true 时生效，详细参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL25wbS5odG1s\">构建 npm 文档</span></td>\n</tr>\n<tr>\n<td align=\"left\">coverView</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否使用工具渲染 CoverView</td>\n</tr>\n<tr>\n<td align=\"left\">ignoreDevUnusedFiles</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">预览、真机调试和本地模拟器等开发阶段是否过滤无依赖文件（默认为true）</td>\n</tr>\n<tr>\n<td align=\"left\">checkInvalidKey</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否展示 JSON 文件校验错误信息</td>\n</tr>\n<tr>\n<td align=\"left\">showShadowRootInWxmlPanel</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否开启调试器 WXML 面板展示 shadow-root</td>\n</tr>\n<tr>\n<td align=\"left\">useIsolateContext</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否开启小程序独立域调试特性[6]</td>\n</tr>\n<tr>\n<td align=\"left\">useMultiFrameRuntime</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否开启模拟器预先载入小程序的某些资源[7]。此设定为 false 时会导致 <code>useIsolateContext</code> 失效</td>\n</tr>\n<tr>\n<td align=\"left\">useApiHook</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否启用 API Hook 功能[8]</td>\n</tr>\n<tr>\n<td align=\"left\">useApiHostProcess</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否在额外的进程处理一些小程序 API[9]</td>\n</tr>\n<tr>\n<td align=\"left\">useLanDebug</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">仅在小游戏有效，是否开启局域网调试服务器</td>\n</tr>\n<tr>\n<td align=\"left\">enableEngineNative</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否在游戏引擎项目中开启支持引用 node 原生模块的底层加速特性</td>\n</tr>\n<tr>\n<td align=\"left\">showES6CompileOption</td>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">是</td>\n<td align=\"left\">是否在本地设置中展示传统的 ES6 转 ES5 开关（对应 es6），增强编译开关 （对应 enhance）</td>\n</tr>\n</tbody></table>\n<p><strong>注 1</strong>: 开发阶段相关的设置修改优先同步到 <code>project.private.config.json</code> 中，但最终编译产物有关的设置无法在 <code>project.private.config.json</code> 中生效，界面上的改动也不会同步到 <code>project.private.config.json</code> 文件中。</p>\n<p><strong>注 2</strong>: <code>es6</code> 和 <code>enhance</code> 需同时为 true&#x2F;false，对应于 <code>将 JS 编译成 ES5</code></p>\n<p><strong>注 3</strong>: (<strong>懒注入占位组件调试</strong>) 开启<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9hYmlsaXR5L2xhenlsb2Fk\">按需注入</span>后在项目设置面板中会出现对应的勾选项，开启之后，按需注入的组件将会停止注入，页面停止在占位组件状态，便于调试自定义占位组件。</p>\n<p><strong>注 4</strong>: (<strong>静态资源服务器</strong>) 可以托管项目本地的静态资源，主要用于在预览时测试小游戏真机资源加载的效果。</p>\n<p><strong>注 5</strong>: (<strong>以本地目录为插件资源来源</strong>) 启用此特性后，工具将停止从线上获取小游戏插件包内容，并将检验本地相应目录的文件完整性。仅对小游戏插件项目有效。要以本地磁盘目录作为插件的资源来源，需要同时在小游戏插件项目的 game.json 中配置相关的属性。</p>\n<p><strong>注 6</strong>: (<strong>小程序独立域调试</strong>) 一种新的小程序内部代码的执行方式，仅影响工具侧的调试过程。未来将取代传统的执行方式并成为默认选择。仅在 2.11.1 及以上基础库有效。关闭此特性可能有助于规避一些调试中遇到的未知报错。</p>\n<p><strong>注 7</strong>: (<strong>预先载入小程序的某些资源</strong>) 开启此内部特性后，调试时小程序的重新载入可能会更快一些。此设定不影响真机和实际运行效果。</p>\n<p><strong>注 8</strong>: (<strong>API Hook 功能</strong>) 关闭此内部特性可能导致工具的某些调试功能（例如 mock）失效。此设定不影响真机运行效果。</p>\n<p><strong>注 9</strong>: (<strong>额外进程</strong>) 开启此内部特性后，部分 API 的调用会被移到单独的进程以减轻工具主进程的负担。此设定不影响真机运行效果。</p>\n<h4 id=\"useCompilerPlugins\"><a href=\"#useCompilerPlugins\" class=\"headerlink\" title=\"useCompilerPlugins\"></a>useCompilerPlugins</h4><p>编译插件配置，目前支持编译插件有 typescript、less、sass</p>\n<p>如</p>\n<pre><code class=\"json\">&#123;\n  &quot;setting&quot;: &#123;\n    &quot;useCompilerPlugins&quot;: [\n      &quot;typescript&quot;,\n      &quot;less&quot;\n    ]\n  &#125;\n&#125;\n</code></pre>\n<p>表示项目支持直接使用 typescript 和 less</p>\n<h4 id=\"babelSetting\"><a href=\"#babelSetting\" class=\"headerlink\" title=\"babelSetting\"></a>babelSetting</h4><p><code>将 JS 编译为 ES5</code> 时 Babel 的配置项，其中可以指定以下设置</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">outputPath</td>\n<td align=\"left\">String</td>\n<td align=\"left\">Babel 辅助函数的输出目录，默认为 <code>@babel/runtime</code></td>\n</tr>\n<tr>\n<td align=\"left\">ignore</td>\n<td align=\"left\">Array<code>&lt;String&gt;</code></td>\n<td align=\"left\">配置需要跳过 Babel 编译(包括代码压缩)处理的文件或目录</td>\n</tr>\n</tbody></table>\n<p><strong>注 1</strong>: 指定文件路径外，还可以指定目录，详见下面项目配置示例</p>\n<h3 id=\"libVersion\"><a href=\"#libVersion\" class=\"headerlink\" title=\"libVersion\"></a>libVersion</h3><p>可以指定项目运行的基础库具体的版本号 也可以 <code>project.config.json</code> 的 <code>libVersion</code> 指定以下值</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">latest</td>\n<td align=\"left\">最新的非灰度中的基础库</td>\n</tr>\n<tr>\n<td align=\"left\">trial</td>\n<td align=\"left\">最新的基础库</td>\n</tr>\n<tr>\n<td align=\"left\">widelyUsed</td>\n<td align=\"left\">使用比例最高的基础库</td>\n</tr>\n</tbody></table>\n<p>以上值在 <code>project.private.config.json</code> 文件中无效，因为手动在开发者工具 - 详情 - 本地设置中改变基础库的版本，会覆盖掉 <code>project.private.config.json</code> 的 <code>libVersion</code> 字段</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>指定自定义预处理的命令</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名字</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">beforeCompile</td>\n<td align=\"left\">编译前预处理命令</td>\n</tr>\n<tr>\n<td align=\"left\">beforePreview</td>\n<td align=\"left\">预览前预处理命令</td>\n</tr>\n<tr>\n<td align=\"left\">beforeUpload</td>\n<td align=\"left\">上传前预处理命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"packOptions\"><a href=\"#packOptions\" class=\"headerlink\" title=\"packOptions\"></a>packOptions</h3><p><code>packOptions</code> 用以配置项目在打包过程中的选项。打包是预览、上传时对项目进行的必须步骤。</p>\n<p>目前可以指定 <code>packOptions.include</code> 字段，用以配置打包时需要强制带上的文件（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9zdHJ1Y3R1cmUuaHRtbCMlRTUlODUlODElRTglQUUlQjglRTQlQjglOEElRTQlQkMlQTAlRTclOUElODQlRTYlOTYlODclRTQlQkIlQjY=\">仅限后缀名白名单内</span>）或者文件夹，匹配的这些文件或文件夹将一定会出现在预览或上传的结果内。（该字段的优先级高于 <code>packOptions.ignore</code>）</p>\n<p>同时可以指定 <code>packOptions.ignore</code> 字段，用以配置打包时对符合指定规则的文件或文件夹进行忽略，以跳过打包的过程，这些文件或文件夹将不会出现在预览或上传的结果内。</p>\n<p><code>packOptions.ignore</code> 和 <code>packOptions.include</code> 为一对象数组，对象元素类型如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">value</td>\n<td align=\"left\">string</td>\n<td align=\"left\">路径1或取值</td>\n</tr>\n<tr>\n<td align=\"left\">type</td>\n<td align=\"left\">string</td>\n<td align=\"left\">类型</td>\n</tr>\n</tbody></table>\n<p>其中，<code>type</code> 可以取的值为 <code>folder</code>、<code>file</code>、<code>suffix</code>、<code>prefix</code>、<code>regexp</code>2、<code>glob</code>2，分别对应文件夹、文件、后缀、前缀、正则表达式、Glob 规则。所有规则值都会自动忽略大小写。</p>\n<p><strong>注 1</strong>: <code>value</code> 字段的值若表示文件或文件夹路径，以小程序目录 (<code>miniprogramRoot</code>) 为根目录。</p>\n<p><strong>注 2</strong>: <code>regexp</code>、<code>glob</code> 仅 1.02.1809260 及以上版本工具支持。</p>\n<p>示例配置如下。</p>\n<pre><code class=\"json\">&#123;\n  &quot;packOptions&quot;: &#123;\n    &quot;ignore&quot;: [&#123;\n      &quot;type&quot;: &quot;file&quot;,\n      &quot;value&quot;: &quot;test/test.js&quot;\n    &#125;, &#123;\n      &quot;type&quot;: &quot;folder&quot;,\n      &quot;value&quot;: &quot;test&quot;\n    &#125;, &#123;\n      &quot;type&quot;: &quot;suffix&quot;,\n      &quot;value&quot;: &quot;.webp&quot;\n    &#125;, &#123;\n      &quot;type&quot;: &quot;prefix&quot;,\n      &quot;value&quot;: &quot;test-&quot;\n    &#125;, &#123;\n      &quot;type&quot;: &quot;glob&quot;,\n      &quot;value&quot;: &quot;test/**/*.js&quot;\n    &#125;, &#123;\n      &quot;type&quot;: &quot;regexp&quot;,\n      &quot;value&quot;: &quot;\\\\.jsx$&quot;\n    &#125;]\n  &#125;\n&#125;\n</code></pre>\n<p><strong>注</strong>: 这部分设置的更改可能需要重新打开项目才能生效。</p>\n<h3 id=\"debugOptions\"><a href=\"#debugOptions\" class=\"headerlink\" title=\"debugOptions\"></a>debugOptions</h3><p><code>debugOptions</code> 用以配置在对项目代码进行调试时的选项。</p>\n<p>目前可以指定 <code>debugOptions.hidedInDevtools</code> 字段，用以配置调试时于调试器 Sources 面板隐藏源代码的文件。</p>\n<p><code>hidedInDevtools</code> 的配置规则和 <code>packOptions.ignore</code> 是一致的。</p>\n<p>当某个 js 文件符合此规则时，调试器 Sources 面板中此文件源代码正文内容将被隐藏，显示为：</p>\n<pre><code class=\"javascript\">// xxx.js has been hided by project.config.json\n</code></pre>\n<blockquote>\n<p>注：配置此规则后，可能需要关闭并重新打开项目才能看到效果。</p>\n</blockquote>\n<p><strong>项目配置示例：</strong></p>\n<pre><code class=\"json\">&#123;\n  &quot;miniprogramRoot&quot;: &quot;./src&quot;,\n  &quot;qcloudRoot&quot;: &quot;./svr&quot;,\n  &quot;setting&quot;: &#123;\n    &quot;postcss&quot;: true,\n    &quot;es6&quot;: true,\n    &quot;minified&quot;: true,\n    &quot;urlCheck&quot;: false,\n    &quot;checkSiteMap&quot;: true,\n    &quot;enhance&quot;: true,\n    &quot;babelSetting&quot;: &#123;\n      &quot;ignore&quot;: [\n        &quot;utils/something_not_to_process.js&quot;,\n        &quot;miniprogram_npm/*&quot;,\n        &quot;utils/already_handle/*&quot;\n      ]\n    &#125;\n  &#125;,\n  &quot;packOptions&quot;: &#123;\n    &quot;ignore&quot;: []\n  &#125;,\n  &quot;debugOptions&quot;: &#123;&#125;\n&#125;\n</code></pre>\n<h3 id=\"watchOptions\"><a href=\"#watchOptions\" class=\"headerlink\" title=\"watchOptions\"></a>watchOptions</h3><p><code>watchOptions</code> 用以配置项目中可以被忽略展示和监听文件变化的文件匹配规则。 部分项目（如游戏项目）其项目文件可能成千上万，其中大部分可能是资源文件，并不是小程序和小游戏代码中关心展示的文件，这些文件在工具开发时可以不需要被开发者关注，因此工具可以增加一个配置去忽略指定的文件和目录，从而不对这些文件进行文件遍历获取和文件内容变更的监听（watch），从而提高开启工具的速度以及减少工具打开占用的内存。</p>\n<p>目前可以指定 <code>watchOptions.ignore</code> 字段，用以配置工具时对符合指定规则的文件或文件夹进行忽略(<code>忽略的文件将不展示在编辑器文件列表和对该文件进行监听</code>），以避免展示和监听项目中不必要的文件内容（这些文件或文件夹不需要去关心文件变化）</p>\n<p><code>watchOptions.ignore</code> 为 <code>glob pattern</code> 字符串数组,具体支持如下：</p>\n<ul>\n<li><ul>\n<li>匹配0到多个字符</li>\n</ul>\n</li>\n<li><p>? 匹配一个字符</p>\n</li>\n<li><p>[…] 匹配一个字符列表，类似正则表达式的字符列表</p>\n</li>\n<li><p>!(pattern|pattern|pattern) 反向匹配括号内的模式</p>\n</li>\n<li><p>?(pattern|pattern|pattern) 匹配0或1个括号内的模式</p>\n</li>\n<li><p>+(pattern|pattern|pattern) 匹配至少1个括号内的模式</p>\n</li>\n<li><p>*(pattern|pattern|pattern) 匹配0到多个括号内的模式</p>\n</li>\n<li><p>@(pattern|pat*|pat?erN) 精确匹配括号内的模式</p>\n</li>\n<li><p>** 匹配0到多个子目录，递归匹配子目录</p>\n</li>\n</ul>\n<p>示例配置如下。</p>\n<p>如下所示</p>\n<pre><code class=\"json\">&#123;\n  &quot;description&quot;: &quot;项目配置文件&quot;,\n  &quot;watchOptions&quot;: &#123;\n     &quot;ignore&quot;: [\n        &quot;utils/util.js&quot;,\n        &quot;libs/**/**&quot;\n     ]\n  &#125;\n&#125;\n</code></pre>\n<p><strong>注 1</strong> : watchOptions.ignore 数组中的值若表示文件或文件夹路径，以项目根目录为基准目录。 <strong>注 2</strong> : 由于文件遍历和 watch 都是在项目启动时执行，因此如果修改了 watchOptions 需要重新打开项目 <strong>注 3</strong>: 该配置仅 1.02.1910220 及以上版本工具支持。</p>\n<h3 id=\"8-1-3-页面配置-page-json\"><a href=\"#8-1-3-页面配置-page-json\" class=\"headerlink\" title=\"8.1.3 页面配置 page.json\"></a>8.1.3 页面配置 page.json</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL3BhZ2UuaHRtbA==\">页面配置page.json</span></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">navigationBarBackgroundColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">#000000</td>\n<td align=\"left\">导航栏背景颜色，如 <code>#000000</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationBarTextStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">white</td>\n<td align=\"left\">导航栏标题颜色，仅支持 <code>black</code> &#x2F; <code>white</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationBarTitleText</td>\n<td align=\"left\">string</td>\n<td align=\"left\"></td>\n<td align=\"left\">导航栏标题文字内容</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">navigationStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">default</td>\n<td align=\"left\">导航栏样式，仅支持以下值： <code>default</code> 默认样式 <code>custom</code> 自定义导航栏，只保留右上角胶囊按钮。</td>\n<td align=\"left\">iOS&#x2F;Android 微信客户端 7.0.0，Windows 微信客户端不支持</td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColor</td>\n<td align=\"left\">HexColor</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">窗口的背景色</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">backgroundTextStyle</td>\n<td align=\"left\">string</td>\n<td align=\"left\">dark</td>\n<td align=\"left\">下拉 loading 的样式，仅支持 <code>dark</code> &#x2F; <code>light</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColorTop</td>\n<td align=\"left\">string</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">顶部窗口的背景色，仅 iOS 支持</td>\n<td align=\"left\">微信客户端 6.5.16</td>\n</tr>\n<tr>\n<td align=\"left\">backgroundColorBottom</td>\n<td align=\"left\">string</td>\n<td align=\"left\">#ffffff</td>\n<td align=\"left\">底部窗口的背景色，仅 iOS 支持</td>\n<td align=\"left\">微信客户端 6.5.16</td>\n</tr>\n<tr>\n<td align=\"left\">enablePullDownRefresh</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">false</td>\n<td align=\"left\">是否开启当前页面下拉刷新。 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29ucHVsbGRvd25yZWZyZXNo\">Page.onPullDownRefresh</span></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">onReachBottomDistance</td>\n<td align=\"left\">number</td>\n<td align=\"left\">50</td>\n<td align=\"left\">页面上拉触底事件触发时距页面底部距离，单位为px。 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29ucmVhY2hib3R0b20=\">Page.onReachBottom</span></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">pageOrientation</td>\n<td align=\"left\">string</td>\n<td align=\"left\">portrait</td>\n<td align=\"left\">屏幕旋转设置，支持 <code>auto</code> &#x2F; <code>portrait</code> &#x2F; <code>landscape</code> 详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L3Jlc2l6YWJsZS5odG1s\">响应显示区域变化</span></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.4.0</span> (auto) &#x2F; <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.5.0</span> (landscape)</td>\n</tr>\n<tr>\n<td align=\"left\">disableScroll</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">false</td>\n<td align=\"left\">设置为 <code>true</code> 则页面整体不能上下滚动。 只在页面配置中有效，无法在 <code>app.json</code> 中设置</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">usingComponents</td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">页面<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jdXN0b20tY29tcG9uZW50Lw==\">自定义组件</span>配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.6.3</span></td>\n</tr>\n<tr>\n<td align=\"left\">initialRenderingCache</td>\n<td align=\"left\">string</td>\n<td align=\"left\"></td>\n<td align=\"left\">页面<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L2luaXRpYWwtcmVuZGVyaW5nLWNhY2hlLmh0bWw=\">初始渲染缓存</span>配置，支持 <code>static</code> &#x2F; <code>dynamic</code></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.11.1</span></td>\n</tr>\n<tr>\n<td align=\"left\">style</td>\n<td align=\"left\">string</td>\n<td align=\"left\">default</td>\n<td align=\"left\">启用新版的组件样式</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.10.2</span></td>\n</tr>\n<tr>\n<td align=\"left\">singlePage</td>\n<td align=\"left\">Object</td>\n<td align=\"left\">否</td>\n<td align=\"left\">单页模式相关配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.12.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">restartStrategy</td>\n<td align=\"left\">string</td>\n<td align=\"left\">homePage</td>\n<td align=\"left\">重新启动策略配置</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.8.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">handleWebviewPreload</td>\n<td align=\"left\">string</td>\n<td align=\"left\">static</td>\n<td align=\"left\">控制<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9wZXJmb3JtYW5jZS90aXBzL3J1bnRpbWVfbmF2Lmh0bWwjXzItNC0lRTYlOEUlQTclRTUlODglQjYlRTklQTIlODQlRTUlOEElQTAlRTglQkQlQkQlRTQlQjglOEIlRTQlQjglQUElRTklQTElQjUlRTklOUQlQTIlRTclOUElODQlRTYlOTclQjYlRTYlOUMlQkE=\">预加载下个页面的时机</span>。支持 <code>static</code> &#x2F; <code>manual</code> &#x2F; <code>auto</code></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.15.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">visualEffectInBackground</td>\n<td align=\"left\">string</td>\n<td align=\"left\">否</td>\n<td align=\"left\">切入系统后台时，隐藏页面内容，保护用户隐私。支持 <code>hidden</code> &#x2F; <code>none</code>，若对页面单独设置则会覆盖全局的配置，详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1s\">全局配置</span></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.15.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">enablePassiveEvent</td>\n<td align=\"left\">Object或boolean</td>\n<td align=\"left\">否</td>\n<td align=\"left\">事件监听是否为 passive，若对页面单独设置则会覆盖全局的配置，详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uL2FwcC5odG1s\">全局配置</span></td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.24.1</span></td>\n</tr>\n</tbody></table>\n<p>&#x2F;&#x2F; pages&#x2F;home&#x2F;home.json</p>\n<pre><code class=\"json\">&#123;\n  &quot;navigationBarTitleText&quot;: &quot;嗨购-首页&quot;,\n  &quot;usingComponents&quot;: &#123;&#125;\n&#125;\n</code></pre>\n<h2 id=\"8-2-WXML模版\"><a href=\"#8-2-WXML模版\" class=\"headerlink\" title=\"8.2 WXML模版\"></a>8.2 WXML模版</h2><p>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2NvbXBvbmVudC8=\">基础组件</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L3d4bWwvZXZlbnQuaHRtbA==\">事件系统</span>，可以构建出页面的结构。</p>\n<p>要完整了解 WXML 语法，请参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sLw==\">WXML 语法参考</span>。</p>\n<p>用以下一些简单的例子来看看 WXML 具有什么能力：</p>\n<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><pre><code class=\"vue\">&lt;!--wxml--&gt;\n&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt;\n// page.js\nPage(&#123;\n  data: &#123;\n    message: &#39;Hello MINA!&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><pre><code class=\"vue\">&lt;!--wxml--&gt;\n&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;\n// page.js\nPage(&#123;\n  data: &#123;\n    array: [1, 2, 3, 4, 5]\n  &#125;\n&#125;)\n</code></pre>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><pre><code class=\"vue\">&lt;!--wxml--&gt;\n&lt;view wx:if=&quot;&#123;&#123;view == 'WEBVIEW'&#125;&#125;&quot;&gt; WEBVIEW &lt;/view&gt;\n&lt;view wx:elif=&quot;&#123;&#123;view == 'APP'&#125;&#125;&quot;&gt; APP &lt;/view&gt;\n&lt;view wx:else=&quot;&#123;&#123;view == 'MINA'&#125;&#125;&quot;&gt; MINA &lt;/view&gt;\n// page.js\nPage(&#123;\n  data: &#123;\n    view: &#39;MINA&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><pre><code class=\"vue\">&lt;template name=&quot;staffName&quot;&gt;\n  &lt;view&gt;\n    FirstName: &#123;&#123;firstName&#125;&#125;, LastName: &#123;&#123;lastName&#125;&#125;\n  &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;template is=&quot;staffName&quot; data=&quot;&#123;&#123;...staffA&#125;&#125;&quot;&gt;&lt;/template&gt;\n&lt;template is=&quot;staffName&quot; data=&quot;&#123;&#123;...staffB&#125;&#125;&quot;&gt;&lt;/template&gt;\n&lt;template is=&quot;staffName&quot; data=&quot;&#123;&#123;...staffC&#125;&#125;&quot;&gt;&lt;/template&gt;\n</code></pre>\n<p>具体的能力以及使用方式在以下章节查看：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sL2RhdGEuaHRtbA==\">数据绑定</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sL2xpc3QuaHRtbA==\">列表渲染</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sL2NvbmRpdGlvbmFsLmh0bWw=\">条件渲染</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sL3RlbXBsYXRlLmh0bWw=\">模板</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS93eG1sL2ltcG9ydC5odG1s\">引用</span></p>\n<h3 id=\"8-2-1-数据绑定\"><a href=\"#8-2-1-数据绑定\" class=\"headerlink\" title=\"8.2.1 数据绑定\"></a>8.2.1 数据绑定</h3><p>WXML 中的动态数据均来自对应 Page 的 data。</p>\n<h2 id=\"简单绑定\"><a href=\"#简单绑定\" class=\"headerlink\" title=\"简单绑定\"></a>简单绑定</h2><p>数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：</p>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><pre><code class=\"vue\">&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    message: &#39;Hello MINA!&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"组件属性-需要在双引号之内\"><a href=\"#组件属性-需要在双引号之内\" class=\"headerlink\" title=\"组件属性(需要在双引号之内)\"></a>组件属性(需要在双引号之内)</h3><pre><code class=\"vue\">&lt;view id=&quot;item-&#123;&#123;id&#125;&#125;&quot;&gt; &lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    id: 0\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"控制属性-需要在双引号之内\"><a href=\"#控制属性-需要在双引号之内\" class=\"headerlink\" title=\"控制属性(需要在双引号之内)\"></a>控制属性(需要在双引号之内)</h3><pre><code class=\"vue\">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; &lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    condition: true\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"关键字-需要在双引号之内\"><a href=\"#关键字-需要在双引号之内\" class=\"headerlink\" title=\"关键字(需要在双引号之内)\"></a>关键字(需要在双引号之内)</h3><p><code>true</code>：boolean 类型的 true，代表真值。</p>\n<p><code>false</code>： boolean 类型的 false，代表假值。</p>\n<pre><code class=\"html\">&lt;checkbox checked=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; &lt;/checkbox&gt;\n</code></pre>\n<p><em><strong>特别注意：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</strong></em></p>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>可以在 <code>&#123;&#123;&#125;&#125;</code> 内进行简单的运算，支持的有如下几种方式：</p>\n<h3 id=\"三元运算\"><a href=\"#三元运算\" class=\"headerlink\" title=\"三元运算\"></a>三元运算</h3><pre><code class=\"vue\">&lt;view hidden=&quot;&#123;&#123;flag ? true : false&#125;&#125;&quot;&gt; Hidden &lt;/view&gt;\n</code></pre>\n<h3 id=\"算数运算\"><a href=\"#算数运算\" class=\"headerlink\" title=\"算数运算\"></a>算数运算</h3><pre><code class=\"vue\">&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    a: 1,\n    b: 2,\n    c: 3\n  &#125;\n&#125;)\n</code></pre>\n<p>view中的内容为 <code>3 + 3 + d</code>。</p>\n<h3 id=\"逻辑判断\"><a href=\"#逻辑判断\" class=\"headerlink\" title=\"逻辑判断\"></a>逻辑判断</h3><pre><code class=\"vue\">&lt;view wx:if=&quot;&#123;&#123;length > 5&#125;&#125;&quot;&gt; &lt;/view&gt;\n</code></pre>\n<h3 id=\"字符串运算\"><a href=\"#字符串运算\" class=\"headerlink\" title=\"字符串运算\"></a>字符串运算</h3><pre><code class=\"vue\">&lt;view&gt;&#123;&#123;\"hello\" + name&#125;&#125;&lt;/view&gt;\n</code></pre>\n<pre><code class=\"javascript\">Page(&#123;\n  data:&#123;\n    name: &#39;MINA&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"数据路径运算\"><a href=\"#数据路径运算\" class=\"headerlink\" title=\"数据路径运算\"></a>数据路径运算</h3><pre><code>&lt;view&gt;&#123;&#123;object.key&#125;&#125; &#123;&#123;array[0]&#125;&#125;&lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    object: &#123;\n      key: &#39;Hello &#39;\n    &#125;,\n    array: [&#39;MINA&#39;]\n  &#125;\n&#125;)\n</code></pre>\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><p>也可以在 Mustache 内直接进行组合，构成新的对象或者数组</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><pre><code class=\"html\">&lt;view wx:for=&quot;&#123;&#123;[zero, 1, 2, 3, 4]&#125;&#125;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    zero: 0\n  &#125;\n&#125;)\n</code></pre>\n<p>最终组合成数组<code>[0, 1, 2, 3, 4]</code>。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><pre><code class=\"vue\">&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;for: a, bar: b&#125;&#125;&quot;&gt;&lt;/template&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    a: 1,\n    b: 2\n  &#125;\n&#125;)\n</code></pre>\n<p>最终组合成的对象是 <code>&#123;for: 1, bar: 2&#125;</code></p>\n<p>也可以用扩展运算符 <code>...</code> 来将一个对象展开</p>\n<pre><code>&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;...obj1, ...obj2, e: 5&#125;&#125;&quot;&gt;&lt;/template&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    obj1: &#123;\n      a: 1,\n      b: 2\n    &#125;,\n    obj2: &#123;\n      c: 3,\n      d: 4\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<p>最终组合成的对象是 <code>&#123;a: 1, b: 2, c: 3, d: 4, e: 5&#125;</code>。</p>\n<p>如果对象的 key 和 value 相同，也可以间接地表达。</p>\n<pre><code class=\"vue\">&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;foo, bar&#125;&#125;&quot;&gt;&lt;/template&gt;\n</code></pre>\n<pre><code class=\"js\">Page(&#123;\n  data: &#123;\n    foo: &#39;my-foo&#39;,\n    bar: &#39;my-bar&#39;\n  &#125;\n&#125;)\n</code></pre>\n<p>最终组合成的对象是 <code>&#123;foo: &#39;my-foo&#39;, bar:&#39;my-bar&#39;&#125;</code>。</p>\n<p><strong>注意</strong>：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：</p>\n<pre><code class=\"vue\">&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;...obj1, ...obj2, a, c: 6&#125;&#125;&quot;&gt;&lt;/template&gt;\nPage(&#123;\n  data: &#123;\n    obj1: &#123;\n      a: 1,\n      b: 2\n    &#125;,\n    obj2: &#123;\n      b: 3,\n      c: 4\n    &#125;,\n    a: 5\n  &#125;\n&#125;)\n</code></pre>\n<p>最终组合成的对象是 <code>&#123;a: 5, b: 3, c: 6&#125;</code>。</p>\n<p><strong>注意：</strong> 花括号和引号之间如果有空格，将最终被解析成为字符串</p>\n<pre><code class=\"vue\">&lt;view wx:for=&quot;&#123;&#123;[1,2,3]&#125;&#125; &quot;&gt;\n  &#123;&#123;item&#125;&#125;\n&lt;/view&gt;\n</code></pre>\n<p>等同于</p>\n<pre><code class=\"vue\">&lt;view wx:for=&quot;&#123;&#123;[1,2,3] + ' '&#125;&#125;&quot;&gt;\n  &#123;&#123;item&#125;&#125;\n&lt;/view&gt;\n</code></pre>\n<h2 id=\"8-3-WXSS-样式\"><a href=\"#8-3-WXSS-样式\" class=\"headerlink\" title=\"8.3 WXSS 样式\"></a>8.3 WXSS 样式</h2><p><code>WXSS</code> 具有 <code>CSS</code> 大部分的特性，小程序在 <code>WXSS</code> 也做了一些扩充和修改</p>\n<ol>\n<li>新增了尺寸单位。在写 <code>CSS</code> 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。<code>WXSS</code> 在底层支持新的尺寸单位 <code>rpx</code> ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</li>\n<li>提供了全局的样式和局部样式。和前边 <code>app.json</code>, <code>page.json</code> 的概念相同，你可以写一个 <code>app.wxss</code> 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 <code>page.wxss</code> 仅对当前页面生效。</li>\n<li>此外 <code>WXSS</code> 仅支持部分 <code>CSS</code> 选择器</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L3d4c3MuaHRtbA==\">https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html</span></p>\n<ul>\n<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx &#x3D; 375px &#x3D; 750物理像素，1rpx &#x3D; 0.5px &#x3D; 1物理像素。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">设备</th>\n<th align=\"left\">rpx换算px (屏幕宽度&#x2F;750)</th>\n<th align=\"left\">px换算rpx (750&#x2F;屏幕宽度)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">iPhone5</td>\n<td align=\"left\">1rpx &#x3D; 0.42px</td>\n<td align=\"left\">1px &#x3D; 2.34rpx</td>\n</tr>\n<tr>\n<td align=\"left\">iPhone6</td>\n<td align=\"left\">1rpx &#x3D; 0.5px</td>\n<td align=\"left\">1px &#x3D; 2rpx</td>\n</tr>\n<tr>\n<td align=\"left\">iPhone6 Plus</td>\n<td align=\"left\">1rpx &#x3D; 0.552px</td>\n<td align=\"left\">1px &#x3D; 1.81rpx</td>\n</tr>\n</tbody></table>\n<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p>\n<blockquote>\n<p>假如设计是给我们的设计稿，打开以后，发现 设计稿的宽度是 750px，那么我们在wxss中写宽度和高度时，可以直接写量取的数据，单位 rpx</p>\n<p>如果设计师给的设计稿为375px，假设量取的宽度为100px，那么建议将wxss的单位写为  200rpx</p>\n</blockquote>\n<p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>\n<h2 id=\"8-4-js逻辑交互\"><a href=\"#8-4-js逻辑交互\" class=\"headerlink\" title=\"8.4 js逻辑交互\"></a>8.4 js逻辑交互</h2><h3 id=\"8-4-1-什么是事件\"><a href=\"#8-4-1-什么是事件\" class=\"headerlink\" title=\"8.4.1 什么是事件\"></a>8.4.1 什么是事件</h3><ul>\n<li>事件是视图层到逻辑层的通讯方式。</li>\n<li>事件可以将用户的行为反馈到逻辑层进行处理。</li>\n<li>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</li>\n<li>事件对象可以携带额外信息，如 id, dataset, touches。</li>\n</ul>\n<blockquote>\n<p>切记，自定义的事件是需要写到 js中的 选项中的</p>\n</blockquote>\n<h3 id=\"8-4-2-如何给事件传递参数\"><a href=\"#8-4-2-如何给事件传递参数\" class=\"headerlink\" title=\"8.4.2 如何给事件传递参数\"></a>8.4.2 如何给事件传递参数</h3><blockquote>\n<p>传递参数时，id具有特殊性，其余数据通过 data-params 属性传值</p>\n</blockquote>\n<h3 id=\"8-4-3-冒泡\"><a href=\"#8-4-3-冒泡\" class=\"headerlink\" title=\"8.4.3 冒泡\"></a>8.4.3 冒泡</h3><blockquote>\n<p>biantap并不会阻止事件冒泡</p>\n<p>catchtap 会阻止冒泡</p>\n</blockquote>\n<pre><code class=\"js\">// pages/test/test.ts\nPage(&#123;\n  data: &#123;\n    message: &quot;&lt;mark&gt;&lt;i&gt;hello minpro&lt;/i&gt;&lt;/mark&gt;&quot;,\n    list: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],\n    arr: [\n      &#123; id: 1, name: &#39;曹喜龙&#39; &#125;,\n      &#123; id: 2, name: &#39;段泽楷&#39; &#125;,\n      &#123; id: 3, name: &#39;王喜珍&#39; &#125;\n    ],\n    cars: [\n      &#123;\n        brand: &#39;奔驰&#39;,\n        list: [ &#39;大G&#39;, &#39;c260&#39; ]\n      &#125;,\n      &#123;\n        brand: &#39;宝马&#39;,\n        list: [ &#39;X1&#39;, &#39;X3&#39; ]\n      &#125;\n    ],\n    name: &#39;&#39;,\n    obj: &#123;\n      index: &#39;0&#39;,\n      msg: &#39;vue&#39;,\n      time: &#39;00&#39;\n    &#125;,\n    msg: &#39;&#39;,\n    address: &quot;1&quot;,\n    latitude: 34.218172,\n    longitude: 108.875866,\n    company: &quot;2&quot;,\n    img: &#39;/resources/avatar.png&#39;\n  &#125;,\n  // changeName (event: &#123; detail: &#123;value: string &#125;&#125;) &#123;\n  changeName (event: WechatMiniprogram.CustomEvent) &#123;\n    console.log(event)\n    this.setData(&#123;\n      name: event.detail.value\n    &#125;)\n  &#125;,\n  changeMsg () &#123;\n    this.setData(&#123;\n      msg: &#39;hello 小程序&#39;\n    &#125;)\n  &#125;,\n  changeMsgOfParams (event: WechatMiniprogram.BaseEvent ) &#123;\n    this.setData(&#123;\n      msg: event.target.dataset.str\n    &#125;)\n  &#125;,\n  chooseLocation () &#123;\n    console.log(11111)\n    wx.chooseLocation(&#123;\n      success: (res) =&gt; &#123;\n        console.log(res)\n        this.setData(&#123;\n          address: res.address,\n          latitude: res.latitude,\n          longitude: res.longitude,\n          company: res.name\n        &#125;)\n      &#125;\n    &#125;)\n    // wx.chooseLocation(&#123;&#125;).then(res =&gt; &#123;\n    //   console.log(res)\n    // &#125;)\n  &#125;,\n  openLocation () &#123;\n    wx.openLocation(&#123;\n      latitude: this.data.latitude,\n      longitude: this.data.longitude,\n      scale: 18\n    &#125;)\n  &#125;,\n  changeAvatar () &#123;\n    wx.chooseMedia(&#123;\n      count: 9,\n      mediaType: [&#39;image&#39;],\n      sourceType: [&#39;album&#39;, &#39;camera&#39;],\n      maxDuration: 30,\n      camera: &#39;back&#39;,\n      success: (res) =&gt; &#123;\n        console.log(res.tempFiles[0].tempFilePath)\n        this.setData(&#123;\n          img: res.tempFiles[0].tempFilePath\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;\n&#125;)\n</code></pre>\n<h1 id=\"9-小程序的宿主环境\"><a href=\"#9-小程序的宿主环境\" class=\"headerlink\" title=\"9.小程序的宿主环境\"></a>9.小程序的宿主环境</h1><h2 id=\"9-1-渲染层和逻辑层\"><a href=\"#9-1-渲染层和逻辑层\" class=\"headerlink\" title=\"9.1 渲染层和逻辑层\"></a>9.1 渲染层和逻辑层</h2><p>WXML 模板和 WXSS 样式工作在渲染层</p>\n<p>JS 脚本工作在逻辑层</p>\n<h3 id=\"9-1-1-注册小程序\"><a href=\"#9-1-1-注册小程序\" class=\"headerlink\" title=\"9.1.1 注册小程序\"></a>9.1.1 注册小程序</h3><p>每个小程序都需要在 <code>app.js</code> 中调用 <code>App</code> 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWw=\">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html</span></p>\n<p>注册小程序。接受一个 <code>Object</code> 参数，其指定小程序的生命周期回调等。</p>\n<p><strong>App() 必须在 <code>app.js</code> 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25MYXVuY2gtT2JqZWN0LW9iamVjdA==\">onLaunch</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">生命周期回调——监听小程序初始化。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25TaG93LU9iamVjdC1vYmplY3Q=\">onShow</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">生命周期回调——监听小程序启动或切前台。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25IaWRl\">onHide</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">生命周期回调——监听小程序切后台。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25FcnJvci1TdHJpbmctZXJyb3I=\">onError</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">错误监听函数。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25QYWdlTm90Rm91bmQtT2JqZWN0LW9iamVjdA==\">onPageNotFound</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">页面不存在监听函数。</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.9.90</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25VbmhhbmRsZWRSZWplY3Rpb24tT2JqZWN0LW9iamVjdA==\">onUnhandledRejection</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">未处理的 Promise 拒绝事件监听函数。</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.10.0</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvQXBwLmh0bWwjb25UaGVtZUNoYW5nZS1PYmplY3Qtb2JqZWN0\">onThemeChange</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">监听系统主题变化</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.11.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">其他</td>\n<td align=\"left\">any</td>\n<td align=\"left\"></td>\n<td align=\"left\">否</td>\n<td align=\"left\">开发者可以添加任意的函数或数据变量到 <code>Object</code> 参数中，用 <code>this</code> 可以访问</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"js\">// app.js\n// app.js\nApp(&#123;\n  onLaunch() &#123;\n    console.log(&#39;onLaunch&#39;)\n    // 展示本地存储能力\n    const logs = wx.getStorageSync(&#39;logs&#39;) || []\n    logs.unshift(Date.now())\n    wx.setStorageSync(&#39;logs&#39;, logs)\n\n    // 登录\n    wx.login(&#123;\n      success: res =&gt; &#123;\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\n      &#125;\n    &#125;)\n  &#125;,\n  // 其他\n  globalData: &#123;\n    userInfo: null\n  &#125;,\n  onShow () &#123;\n    console.log(&#39;onShow&#39;)\n  &#125;,\n  onHide () &#123;\n    console.log(&#39;onHide&#39;)\n  &#125;,\n  onError () &#123;\n    console.log(&#39;onError&#39;)\n  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"9-1-2-注册页面\"><a href=\"#9-1-2-注册页面\" class=\"headerlink\" title=\"9.1.2 注册页面\"></a>9.1.2 注册页面</h3><p>对于小程序中的每个页面，都需要在页面对应的 <code>js</code> 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI2RhdGE=\">data</span></td>\n<td align=\"left\">Object</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面的初始数据</td>\n</tr>\n<tr>\n<td align=\"left\">options</td>\n<td align=\"left\">Object</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面的组件选项，同 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html\"><code>Component</code> 构造器</a> 中的 <code>options</code> ，需要基础库版本 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.10.1</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jdXN0b20tY29tcG9uZW50L2JlaGF2aW9ycy5odG1s\">behaviors</span></td>\n<td align=\"left\">String Array</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">类似于 mixins 和traits的组件间代码复用机制，参见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jdXN0b20tY29tcG9uZW50L2JlaGF2aW9ycy5odG1s\">behaviors</span>，需要基础库版本 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.9.2</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uTG9hZC1PYmplY3QtcXVlcnk=\">onLoad</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">生命周期回调—监听页面加载</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uU2hvdw==\">onShow</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">生命周期回调—监听页面显示</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uUmVhZHk=\">onReady</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">生命周期回调—监听页面初次渲染完成</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uSGlkZQ==\">onHide</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">生命周期回调—监听页面隐藏</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uVW5sb2Fk\">onUnload</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">生命周期回调—监听页面卸载</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uUHVsbERvd25SZWZyZXNo\">onPullDownRefresh</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">监听用户下拉动作</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uUmVhY2hCb3R0b20=\">onReachBottom</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面上拉触底事件的处理函数</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uU2hhcmVBcHBNZXNzYWdlLU9iamVjdC1vYmplY3Q=\">onShareAppMessage</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">用户点击右上角转发</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uU2hhcmVUaW1lbGluZQ==\">onShareTimeline</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">用户点击右上角转发到朋友圈</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uQWRkVG9GYXZvcml0ZXMtT2JqZWN0LW9iamVjdA==\">onAddToFavorites</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">用户点击右上角收藏</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uUGFnZVNjcm9sbC1PYmplY3Qtb2JqZWN0\">onPageScroll</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面滚动触发事件的处理函数</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uUmVzaXplLU9iamVjdC1vYmplY3Q=\">onResize</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面尺寸改变时触发，详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay92aWV3L3Jlc2l6YWJsZS5odG1sIyVFNSU5QyVBOCVFNiU4OSU4QiVFNiU5QyVCQSVFNCVCOCU4QSVFNSU5MCVBRiVFNyU5NCVBOCVFNSVCMSU4RiVFNSVCOSU5NSVFNiU5NyU4QiVFOCVCRCVBQyVFNiU5NCVBRiVFNiU4QyU4MQ==\">响应显示区域变化</span></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uVGFiSXRlbVRhcC1PYmplY3Qtb2JqZWN0\">onTabItemTap</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">当前是 tab 页时，点击 tab 时触发</td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvUGFnZS5odG1sI29uU2F2ZUV4aXRTdGF0ZQ==\">onSaveExitState</span></td>\n<td align=\"left\">function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">页面销毁前保留状态回调</td>\n</tr>\n<tr>\n<td align=\"left\">其他</td>\n<td align=\"left\">any</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">开发者可以添加任意的函数或数据到 <code>Object</code> 参数中，在页面的函数中用 <code>this</code> 可以访问。<strong>这部分属性会在页面实例创建时进行一次深拷贝</strong>。</td>\n</tr>\n</tbody></table>\n<h3 id=\"9-1-3页面路由\"><a href=\"#9-1-3页面路由\" class=\"headerlink\" title=\"9.1.3页面路由\"></a>9.1.3页面路由</h3><ul>\n<li><p>编程式导航路由</p>\n<ul>\n<li><p>wx.switchTab({})  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p>\n</li>\n<li><p>wx.reLaunch({}) 关闭所有页面，打开到应用内的某个页面</p>\n</li>\n<li><p>wx.redirectTo({}) 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</p>\n</li>\n<li><p>wx.navigateTo({}) 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5uYXZpZ2F0ZUJhY2suaHRtbA==\">wx.navigateBack</span> 可以返回到原页面。小程序中页面栈最多十层。</p>\n</li>\n<li><p>wx.navigateBack({}) 关闭当前页面，返回上一页面或多级页面。可通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L3JlZmVyZW5jZS9hcGkvZ2V0Q3VycmVudFBhZ2VzLmh0bWw=\">getCurrentPages</span> 获取当前的页面栈，决定需要返回几层</p>\n</li>\n</ul>\n</li>\n<li><p>声明式导航路由</p>\n</li>\n</ul>\n<p><code>&lt;navigator url=&quot;&quot; open-type=&quot;&quot;&gt;&lt;/navigator&gt;</code></p>\n<p>下面为open-type的属性值</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">合法值</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">最低版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">navigate</td>\n<td align=\"left\">对应 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5uYXZpZ2F0ZVRvLmh0bWw=\">wx.navigateTo</span> 或 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9uYXZpZ2F0ZS93eC5uYXZpZ2F0ZVRvTWluaVByb2dyYW0uaHRtbA==\">wx.navigateToMiniProgram</span> 的功能</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">redirect</td>\n<td align=\"left\">对应 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5yZWRpcmVjdFRvLmh0bWw=\">wx.redirectTo</span> 的功能</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">switchTab</td>\n<td align=\"left\">对应 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5zd2l0Y2hUYWIuaHRtbA==\">wx.switchTab</span> 的功能</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">reLaunch</td>\n<td align=\"left\">对应 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5yZUxhdW5jaC5odG1s\">wx.reLaunch</span> 的功能</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.1.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">navigateBack</td>\n<td align=\"left\">对应 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9yb3V0ZS93eC5uYXZpZ2F0ZUJhY2suaHRtbA==\">wx.navigateBack</span> 的功能</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">1.1.0</span></td>\n</tr>\n<tr>\n<td align=\"left\">exit</td>\n<td align=\"left\">退出小程序，<code>target=&quot;miniProgram&quot;</code>时生效</td>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jb21wYXRpYmlsaXR5Lmh0bWw=\">2.1.0</span></td>\n</tr>\n</tbody></table>\n<h3 id=\"9-1-4-模块化\"><a href=\"#9-1-4-模块化\" class=\"headerlink\" title=\"9.1.4 模块化\"></a>9.1.4 模块化</h3><p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。</p>\n<ul>\n<li>方式1:使用commonjs规范，模块只有通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html\"><code>module.exports</code></a> 或者 <code>exports</code> 才能对外暴露接口。</li>\n</ul>\n<pre><code class=\"js\">// pages/test/common.js\nfunction sayHello(name) &#123;\n  console.log(`Hello $&#123;name&#125; !`)\n&#125;\nfunction sayGoodbye(name) &#123;\n  console.log(`Goodbye $&#123;name&#125; !`)\n&#125;\n\nmodule.exports.sayHello = sayHello\nexports.sayGoodbye = sayGoodbye\n</code></pre>\n<pre><code class=\"js\">// pages/test/test.js\nvar common = require(&#39;common.js&#39;)\nPage(&#123;\n  ...,\n onLoad () &#123;\n  common.sayHello(&#39;千锋教育&#39;)\n  common.sayGoodbye(&#39;吴大勋&#39;)\n &#125;,\n  ...\n&#125;)\n</code></pre>\n<ul>\n<li>方式2:使用es6模块化规范</li>\n</ul>\n<pre><code class=\"js\">// pages/test/es6md.js\nexport function sayHello(name) &#123;\n  console.log(`Hello $&#123;name&#125; !`)\n&#125;\nexport function sayGoodbye(name) &#123;\n  console.log(`Goodbye $&#123;name&#125; !`)\n&#125;\n</code></pre>\n<pre><code class=\"js\">// pages/test/test.js\nimport &#123; sayHello, sayGoodbye &#125; from &#39;./es6md&#39;\nPage(&#123;\n ...,\n onLoad () &#123;\n  sayHello(&#39;千锋教育 - 太原&#39;)\n    sayGoodbye(&#39;吴大勋 - HTML5&#39;)\n &#125;,\n    ...\n&#125;)\n</code></pre>\n<h2 id=\"9-2-组件\"><a href=\"#9-2-组件\" class=\"headerlink\" title=\"9.2 组件\"></a>9.2 组件</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2NvbXBvbmVudC8=\">https://developers.weixin.qq.com/miniprogram/dev/component/</span></p>\n<p>搭建小程序页面时，参照组件篇章</p>\n<p>通过给<code>app.json</code>的pages选项添加<code>pages/com/com</code>测试小程序的常用组件</p>\n<h2 id=\"9-3-API\"><a href=\"#9-3-API\" class=\"headerlink\" title=\"9.3 API\"></a>9.3 API</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS8=\">https://developers.weixin.qq.com/miniprogram/dev/api/</span></p>\n<p>通过小程序调用微信的功能时，参照API章节</p>\n<p>通过给<code>app.json</code>的pages选项添加<code>pages/api/api</code>测试小程序的常用组件</p>\n<h1 id=\"10小程序的自定义组件\"><a href=\"#10小程序的自定义组件\" class=\"headerlink\" title=\"10小程序的自定义组件\"></a>10小程序的自定义组件</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2ZyYW1ld29yay9jdXN0b20tY29tcG9uZW50Lw==\">https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/</span></p>\n",
            "tags": [
                "微信小程序",
                "wxapp",
                "ts"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/Screeps/action1/",
            "url": "https://www.yexingcheng.com/Screeps/action1/",
            "title": "screeps日记 part1",
            "date_published": "2022-10-30T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "screeps",
                "javascript",
                "screeps"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/wx-app/day1/",
            "url": "https://www.yexingcheng.com/wx-app/day1/",
            "title": "微信小程序学习第一天",
            "date_published": "2022-10-30T16:00:00.000Z",
            "content_html": "<h1 id=\"1、小程序介绍\"><a href=\"#1、小程序介绍\" class=\"headerlink\" title=\"1、小程序介绍\"></a>1、小程序介绍</h1><p>小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p>\n<p>小程序种类</p>\n<ul>\n<li>微信小程序</li>\n<li>支付宝小程序</li>\n<li>百度小程序</li>\n<li>字节跳动小程序</li>\n<li>qq小程序</li>\n<li>京东小程序</li>\n<li>…..</li>\n</ul>\n<p>随着技术的发展，现在已经不满足只写某一个类型的小程序，这样开发成本太高，所以现在很多公司倾向于 使用一套代码同时部署到不同的小程序平台，简单一点来说就是，一次开发，多端运行，典型的代表有 uniapp，taro</p>\n<p>要想学好uniapp，前提条件是得学习vue以及微信小程序</p>\n<h1 id=\"2-准备小程序的账号\"><a href=\"#2-准备小程序的账号\" class=\"headerlink\" title=\"2.准备小程序的账号\"></a>2.准备小程序的账号</h1><p>打开网址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==\">https://mp.weixin.qq.com/</span></p>\n<p>账号分类—小程序 —- 鼠标移动上去 — 查看详情 — 滑动页面至底部 —- 前往注册</p>\n<p>也可以直接点击 网址进行注册： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3d4b3Blbi93YXJlZ2lzdGVyP2FjdGlvbj1zdGVwMQ==\">https://mp.weixin.qq.com/wxopen/waregister?action=step1</span></p>\n<blockquote>\n<p>账号选择个人即可</p>\n<p>账号类型一定要选择微信小程序</p>\n</blockquote>\n<h1 id=\"3-准备小程序开发者工具\"><a href=\"#3-准备小程序开发者工具\" class=\"headerlink\" title=\"3.准备小程序开发者工具\"></a>3.准备小程序开发者工具</h1><p>下载地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2RldnRvb2xzL2Rvd25sb2FkLmh0bWw=\">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</span></p>\n<p><img data-src=\"/wx-app/day1/02.png\" alt=\"image-20220530094135968\"></p>\n<h1 id=\"4-查看小程序的后台界面\"><a href=\"#4-查看小程序的后台界面\" class=\"headerlink\" title=\"4.查看小程序的后台界面\"></a>4.查看小程序的后台界面</h1><p>打开网址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==\">https://mp.weixin.qq.com/</span></p>\n<ul>\n<li>账户名密码登录</li>\n<li>扫码登录：扫码完成，选择自己的小程序项目即可</li>\n</ul>\n<p><img data-src=\"/wx-app/day1/03.png\" alt=\"image-20220530094630311\"></p>\n<h2 id=\"4-1-首页\"><a href=\"#4-1-首页\" class=\"headerlink\" title=\"4.1 首页\"></a>4.1 首页</h2><p>可视化说明小程序统计数据</p>\n<h2 id=\"4-2-管理\"><a href=\"#4-2-管理\" class=\"headerlink\" title=\"4.2 管理\"></a>4.2 管理</h2><p><strong>版本管理</strong></p>\n<ul>\n<li>开发版本：主要通过微信开发者工具开发，然后通过开发者工具上传即可显示体验二维码，只有项目成员和体验成员才可扫码查看效果</li>\n<li>审核版本：开发版本点击 提交审核 按钮，填写审核的信息，然后交给微信审核即可</li>\n<li>线上版本：微信审核通过，即可点击项目上线，所有人可以搜索微信小程序的名字从而使用小程序</li>\n</ul>\n<p><strong>成员管理</strong></p>\n<p>​\t可以添加项目成员以及体验成员</p>\n<ul>\n<li><p>项目成员：运营者，开发者，数据分析者，一个小程序项目最多含有15个项目成员</p>\n</li>\n<li><p>体验成员：只是拥有体验权限，一个小程序项目最多含有15个体验成员</p>\n<blockquote>\n<p>添加时注意要添加的是 成员的 微信号，记住不是微信绑定的手机号</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>用户反馈</strong></p>\n<h2 id=\"4-3-统计\"><a href=\"#4-3-统计\" class=\"headerlink\" title=\"4.3 统计\"></a>4.3 统计</h2><p>统计一般跟开发者无太大关系，数据分析者需要多加关注，通过数据分析，解析新的需求以及需要的改进点，项目组提出新的方案，再由开发者实现</p>\n<h2 id=\"4-4-功能\"><a href=\"#4-4-功能\" class=\"headerlink\" title=\"4.4 功能\"></a>4.4 功能</h2><ul>\n<li>微信搜一搜</li>\n<li>客服</li>\n<li>订阅消息</li>\n<li>页面内容接入</li>\n<li>实验工具</li>\n<li>小程序联盟</li>\n</ul>\n<h2 id=\"4-5-开发\"><a href=\"#4-5-开发\" class=\"headerlink\" title=\"4.5 开发\"></a>4.5 开发</h2><ul>\n<li><p>开发管理</p>\n<ul>\n<li>运维中心</li>\n<li>监控告警</li>\n<li>开发设置 **</li>\n</ul>\n<p><img data-src=\"/wx-app/day1/04.png\" alt=\"image-20220530101133559\"></p>\n<blockquote>\n<p>如果小程序项目要上线，就必须的配置 开发管理 - 开发设置 - 服务器域名</p>\n</blockquote>\n<p><img data-src=\"/wx-app/day1/05.png\" alt=\"image-20220530101346711\"></p>\n<ul>\n<li>接口设置 ** </li>\n<li>安全中心</li>\n</ul>\n</li>\n<li><p>开发工具</p>\n</li>\n<li><p>云服务</p>\n</li>\n</ul>\n<h2 id=\"4-6-设置\"><a href=\"#4-6-设置\" class=\"headerlink\" title=\"4.6 设置\"></a>4.6 设置</h2><ul>\n<li>基础设置</li>\n</ul>\n<blockquote>\n<p>根据小程序的业务需求，选择合适的 服务类目，否则小程序提交审核是会不通过</p>\n</blockquote>\n<h1 id=\"5-使用微信开发者工具\"><a href=\"#5-使用微信开发者工具\" class=\"headerlink\" title=\"5.使用微信开发者工具\"></a>5.使用微信开发者工具</h1><p><img data-src=\"/wx-app/day1/06.png\" alt=\"image-20220530102326201\"></p>\n<p><img data-src=\"/wx-app/day1/image-20221031185844387.png\" alt=\"image-20221031185844387\"></p>\n<h1 id=\"6-熟悉微信开发者工具\"><a href=\"#6-熟悉微信开发者工具\" class=\"headerlink\" title=\"6.熟悉微信开发者工具\"></a>6.熟悉微信开发者工具</h1><ul>\n<li><p>编辑器</p>\n</li>\n<li><p>调试器</p>\n</li>\n<li><p>可视化：不建议使用-拖拽布局页面</p>\n</li>\n<li><p>云开发：不需要单独的后端的接口，包含 数据库、存储、云函数、云托管</p>\n</li>\n<li><p>小程序模式：另一个插件模式</p>\n</li>\n<li><p>普通编译：小程序每次热更新都会让小程序从第一个页面开始渲染，那么为了提高开发效率，可以选择添加编译模式，从而快速调试页面</p>\n</li>\n<li><p>预览：拥有开发权限和体验权限的人，可以直接查看在手机上的实际的运行结果，它跟小程序的线上版本保持一致</p>\n</li>\n<li><p>真机调试：拥有开发权限和体验权限的人，可以直接查看在手机上的实际的运行结果，它跟小程序开发者工具中的模拟器效果保持一致（因为真机调试可以不需要后台配置服务器域名等就可以查看效果）</p>\n</li>\n<li><p>清缓存：清除模拟的缓存信息</p>\n</li>\n<li><p>上传：点击上传即可将项目进入 后台系统中的 开发版本和体验版本</p>\n</li>\n<li><p>版本管理：默认使用 git 作为代码版本管理工具，方便多人合作</p>\n</li>\n<li><p>详情</p>\n<ul>\n<li>基本信息</li>\n<li>性能分析</li>\n<li>本地设置<ul>\n<li>调试基础库：非常关键</li>\n<li>开发阶段：勾选不校验合法域名、web-view（业务域名）、TLS版本以及HTTPs证书</li>\n</ul>\n</li>\n<li>项目配置<ul>\n<li>高级配置<ul>\n<li>代码包总大小（使用分包）   20M</li>\n<li>代码包总大小（不使用分包） 2M</li>\n<li>单个分包&#x2F;主包大小                   2M</li>\n<li>Tabbar最小个数\t\t\t\t\t           2</li>\n<li>Tabbar最大个数                           5</li>\n<li>Tabbar的icon大小限制          40KB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消息</p>\n</li>\n<li><p>页面路径</p>\n<ul>\n<li>页面路径：路由，当前页面展示的一个标识</li>\n<li>页面参数：列表进入详情，详情区分产品的标识</li>\n<li>场景值：进入查看小程序的途径</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"7-熟悉小程序代码\"><a href=\"#7-熟悉小程序代码\" class=\"headerlink\" title=\"7.熟悉小程序代码\"></a>7.熟悉小程序代码</h1><pre><code>- miniprogram\n    - pages  存放该小程序所对应的页面，每个页面一个文件夹\n        - index  index页面\n            index.ts  index页面的逻辑文件\n            index.json index页面的配置文件\n            index.wxml  index页面的结构文件\n            index.scss  index页面的样式文件\n        - logs   logs 页面\n            logs.ts\n            logs.json\n            logs.wxml\n            logs.scss\n    - utils 自定义的工具包\n        util.js 自定义的函数\n    app.ts 全局的逻辑文件\n    app.json 全局的配置文件\n    app.wxss 全局的样式文件\n    sitemap.json 被搜索的配置文件\n- typings\n  - types\n      - wx\n        index.d.ts\n        lib.wx.api.d.ts\n        lib.wx.app.d.ts\n        lib.wx.behavior.d.ts\n        lib.wx.cloud.d.ts\n        lib.wx.component.d.ts\n        lib.ex.event.d.ts\n        lib.wx.page.d.ts\n      index.d.ts\n  index.d.ts\n.eslintrc.js js代码的规则描述\n project.config.json 项目的配置文件\n project.private.config.json 项目私有的配置文件\n tsconfig.json\n</code></pre>\n",
            "tags": [
                "微信小程序",
                "wxapp",
                "ts"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/Screeps/chinese/",
            "url": "https://www.yexingcheng.com/Screeps/chinese/",
            "title": "screeps汉化（steam)",
            "date_published": "2022-10-29T16:00:00.000Z",
            "content_html": "<p>如果你对 screeps 有所了解的话，那么你应该曾经听说过这个游戏的 steam 版本是基于 node 和 nw.js 进行开发的，说白了就是一个套壳浏览器，本质上还是一个 web 应用。既然是 web 应用，那么就可以用我们的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwczovL2dyZWFzeWZvcmsub3JnL3poLUNOL3NjcmlwdHMvNDE2NjUxLXNjcmVlcHMtY2hpbmVzZS1wYWNr\">web 端汉化补丁</span> 进行汉化。</p>\n<p>这里我们看到默认是全英文版本，但由于本人是英语小白，又懒得去一个一个翻译，所以就想翻译这个界面</p>\n<p><img data-src=\"/Screeps/chinese/image-20221102235142846.png\" alt=\"image-20221102235142846\"></p>\n<h1 id=\"汉化步骤\"><a href=\"#汉化步骤\" class=\"headerlink\" title=\"汉化步骤\"></a>汉化步骤</h1><p>实际操作也非常的简单，首先我们通过 steam 打开 screeps 的本地目录：</p>\n<p><img data-src=\"/Screeps/chinese/image-20221102235357536.png\" alt=\"image-20221102235357536\"></p>\n<p><img data-src=\"/Screeps/chinese/image-20221102235416601.png\" alt=\"image-20221102235416601\"></p>\n<p>然后，你应该可以 <strong>找到一个名为 package.nw 的文件</strong>，这个就是游戏的源码包。</p>\n<p>然后用压缩文件的格式打开，这里我用的是WINRAR</p>\n<p><img data-src=\"/Screeps/chinese/image-20221102235616013.png\" alt=\"image-20221102235616013\"></p>\n<p>打开之后我们可以 <strong>找到一个名为 index.html 的文件，对其右键并选择编辑</strong>，同理不要进行解压。</p>\n<p><img data-src=\"/Screeps/chinese/image-20221102235706903.png\" alt=\"image-20221102235706903\"></p>\n<p>然后我们添加汉化脚本到里面</p>\n<pre><code class=\"xml\">&lt;script src=&quot;https://screeps-cn.gitee.io/screeps-chinese-pack-release/main.js&quot; async defer&gt;&lt;/script&gt;\n</code></pre>\n<p>此时我们进入游戏发现已经汉化完毕</p>\n<p><img data-src=\"/Screeps/chinese/image-20221103000423147.png\" alt=\"image-20221103000423147\"></p>\n",
            "tags": [
                "screeps",
                "javascript",
                "screeps"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/computer/rightPointNewMd/",
            "url": "https://www.yexingcheng.com/computer/rightPointNewMd/",
            "title": "如何在右键菜单下添加一个新建markdown文件选项",
            "date_published": "2022-10-29T16:00:00.000Z",
            "content_html": "<h1 id=\"在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧\"><a href=\"#在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧\" class=\"headerlink\" title=\"在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧\"></a>在新建笔记的时候，我们都会用到md文件，但是windows11自带的新建文件夹下面没有新建md文件这一选项，让我们很苦恼，怎么办呢？下面就一起来看看吧</h1><h2 id=\"第一种方法：修改注册表\"><a href=\"#第一种方法：修改注册表\" class=\"headerlink\" title=\"第一种方法：修改注册表\"></a>第一种方法：修改注册表</h2><h3 id=\"一、win-R输入【regedit】\"><a href=\"#一、win-R输入【regedit】\" class=\"headerlink\" title=\"一、win + R输入【regedit】\"></a>一、win + R输入【regedit】</h3><p><img data-src=\"/computer/rightPointNewMd/image-20221030035511584.png\" alt=\"image-20221030035511584\"></p>\n<h3 id=\"二、定位路径-【计算机-HKEY-CLASSES-ROOT-md】\"><a href=\"#二、定位路径-【计算机-HKEY-CLASSES-ROOT-md】\" class=\"headerlink\" title=\"二、定位路径 【计算机\\HKEY_CLASSES_ROOT.md】\"></a>二、定位路径 【计算机\\HKEY_CLASSES_ROOT.md】</h3><p><img data-src=\"/computer/rightPointNewMd/image-20221030035632249.png\" alt=\"image-20221030035632249\"></p>\n<h3 id=\"三、右键-md文件夹-x3D-gt-新建-x3D-gt-项，把新建的项命名为【ShellNew】\"><a href=\"#三、右键-md文件夹-x3D-gt-新建-x3D-gt-项，把新建的项命名为【ShellNew】\" class=\"headerlink\" title=\"三、右键.md文件夹 &#x3D;&gt; 新建 &#x3D;&gt; 项，把新建的项命名为【ShellNew】\"></a>三、右键.md文件夹 &#x3D;&gt; 新建 &#x3D;&gt; 项，把新建的项命名为【ShellNew】</h3><p><img data-src=\"/computer/rightPointNewMd/image-20221030035755119.png\" alt=\"image-20221030035755119\"></p>\n<h3 id=\"四、右键ShellNew-x3D-gt-新建-x3D-gt-字符串值，将该字符串值名称改为【NullFile】\"><a href=\"#四、右键ShellNew-x3D-gt-新建-x3D-gt-字符串值，将该字符串值名称改为【NullFile】\" class=\"headerlink\" title=\"四、右键ShellNew &#x3D;&gt; 新建 &#x3D;&gt; 字符串值，将该字符串值名称改为【NullFile】\"></a>四、右键ShellNew &#x3D;&gt; 新建 &#x3D;&gt; 字符串值，将该字符串值名称改为【NullFile】</h3><p><img data-src=\"/computer/rightPointNewMd/image-20221030035848133.png\" alt=\"image-20221030035848133\"></p>\n<p>如果没有生效，请尝试注销重启系统。</p>\n<h2 id=\"二、注册表导入\"><a href=\"#二、注册表导入\" class=\"headerlink\" title=\"二、注册表导入\"></a>二、注册表导入</h2><p>我们可以新建文本文文档，将以下命名复制进去，将txt后缀名改为reg格式，直接双击reg文件进行注册表导入。</p>\n<pre><code class=\"powershell\">Windows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\.md]\n@=&quot;Marktext.exe&quot;\n\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n&quot;NullFile&quot;=&quot;&quot;\n\n[HKEY_CLASSES_ROOT\\Marktext.exe]\n@=&quot;Markdown&quot;\n</code></pre>\n<p><img data-src=\"/computer/rightPointNewMd/image-20221030040857071.png\" alt=\"image-20221030040857071\"></p>\n<h2 id=\"三、通过-Reg-注册表命令添加\"><a href=\"#三、通过-Reg-注册表命令添加\" class=\"headerlink\" title=\"三、通过 Reg 注册表命令添加\"></a>三、通过 Reg 注册表命令添加</h2><p>更深入一些，我们也可以通过 reg 注册表命令来进行修改。</p>\n<p>必须以管理员权限启动 CMD 窗口，输如下命令。</p>\n<pre><code class=\"powershell\">reg add &quot;HKEY_CLASSES_ROOT\\.md&quot; /d &quot;Marktext.exe&quot; /f\nreg add &quot;HKEY_CLASSES_ROOT\\.md\\ShellNew&quot; /v &quot;NullFile&quot; /t &quot;REG_SZ&quot;  /f\nreg add &quot;HKEY_CLASSES_ROOT\\Marktext.exe&quot; /d &quot;Markdown&quot; /f\n</code></pre>\n<p><img data-src=\"/computer/rightPointNewMd/image-20221030041025319.png\" alt=\"image-20221030041025319\"></p>\n<h1 id=\"最终我们发现可以在右键菜单下有了这个选项\"><a href=\"#最终我们发现可以在右键菜单下有了这个选项\" class=\"headerlink\" title=\"最终我们发现可以在右键菜单下有了这个选项\"></a>最终我们发现可以在右键菜单下有了这个选项</h1><p><img data-src=\"/computer/rightPointNewMd/image-20221030042132599.png\" alt=\"image-20221030042132599\"></p>\n",
            "tags": [
                "计算机相关",
                "windows",
                "windows11"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/react-study/react-router-params/",
            "url": "https://www.yexingcheng.com/react-study/react-router-params/",
            "title": "React路由传参的几种方式",
            "date_published": "2022-10-29T16:00:00.000Z",
            "content_html": "<h1 id=\"一、函数式组件\"><a href=\"#一、函数式组件\" class=\"headerlink\" title=\"一、函数式组件\"></a>一、函数式组件</h1><p>首先新建两个页面并导入到app.tsx页面中</p>\n<pre><code class=\"jsx\">import React,  from &quot;react&quot;;\n\nconst From = () =&gt; &#123;\n  return &lt;&gt;\n  &lt;h1&gt;函数式组件传值&lt;/h1&gt;\n  &lt;/&gt;;\n&#125;;\n\nexport default From;\n</code></pre>\n<pre><code class=\"jsx\">import React,  from &#39;react&#39;;\n\n\nconst To = () =&gt; &#123;\n\n\n  return (\n    &lt;&gt;\n    \n    &lt;h1&gt;函数式组件接受值&lt;/h1&gt;\n    &lt;/&gt;\n  )\n\n&#125;;\n\nexport default To;\n</code></pre>\n<pre><code class=\"tsx\">import React from &#39;react&#39;;\nimport &#123; Route, Routes &#125; from &#39;react-router-dom&#39;\nimport From from &#39;./From-function&#39;;\nimport To from &#39;./To-function&#39;;\n\nconst App= () =&gt; &#123;\n\n\n  return (\n\n    &lt;Routes&gt;\n      &lt;Route path=&#39;/&#39; element=&#123;&lt;From /&gt;&#125;&gt;&lt;/Route&gt;\n      &lt;Route path=&#39;to&#39; element=&#123;&lt;To /&gt;&#125;&gt;&lt;/Route&gt;\n    &lt;/Routes&gt;\n  )\n\n&#125;;\n\nexport default App;\n</code></pre>\n<pre><code class=\"jsx\">import App from &#39;./router-params/App&#39;\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;));\nroot.render(\n  &lt;BrowserRouter&gt;\n    &lt;App /&gt;\n  &lt;/BrowserRouter&gt;,\n)\n</code></pre>\n<h2 id=\"1、params传参\"><a href=\"#1、params传参\" class=\"headerlink\" title=\"1、params传参\"></a>1、params传参</h2><p>优点：刷新页面，参数不丢失</p>\n<p>缺点：1.只能传字符串，传值过多url会变得很长 2. 参数必须在路由上配置</p>\n<p>是通过在路由后面写&#x2F;:参数名将路径配合?name&#x3D;xxx的形式</p>\n<p>通过useParams来获取路径参数</p>\n<p><code>路由配置</code></p>\n<pre><code class=\"jsx\">&lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to:number&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>From组件</code></p>\n<pre><code class=\"jsx\">import React from &quot;react&quot;;\nimport &#123; useNavigate &#125; from &#39;react-router-dom&#39;;\nconst From = () =&gt; &#123;\n\n  const navigate = useNavigate()\n\n  const to =()=&gt;&#123;\n    navigate(&#39;to:666&#39;)\n  &#125;\n  return (&lt;&gt;\n  &lt;h1&gt;函数式组件传值&lt;/h1&gt;\n  &lt;button onClick=&#123;()=&gt;&#123;to()&#125;&#125;&gt;传参&lt;/button&gt;\n  &lt;/&gt;)\n&#125;;\n\nexport default From;\n</code></pre>\n<p><code>to组件</code></p>\n<pre><code class=\"jsx\">import React, &#123; FC &#125; from &#39;react&#39;;\nimport &#123;useParams&#125; from &#39;react-router-dom&#39;\n\nconst To = () =&gt; &#123;\n  const params = useParams()  \n  console.log(params)\n\n  return (\n    &lt;&gt;\n\n    &lt;h1&gt;函数式组件接受值&lt;/h1&gt;\n    传递的参数为&#123;params.number&#125;\n    &lt;/&gt;\n  )\n\n&#125;;\n\nexport default To;\n</code></pre>\n<p>运行结果:</p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030173426778.png\" alt=\"image-20221030173426778\"></p>\n<h2 id=\"2、-search传参\"><a href=\"#2、-search传参\" class=\"headerlink\" title=\"2、. search传参\"></a>2、. search传参</h2><p>优点：刷新页面，参数不丢失</p>\n<p>缺点：只能传字符串，传值过多url会变得很长，获取参数需要自定义hooks</p>\n<p><code>路由配置</code></p>\n<pre><code class=\"jsx\">    &lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>from组件</code></p>\n<pre><code>import React from &quot;react&quot;;\nimport &#123; useNavigate &#125; from &#39;react-router-dom&#39;;\nconst From = () =&gt; &#123;\n\n  const navigate = useNavigate()\n\n\n  const search =()=&gt;&#123;\n    navigate(&#39;to/?num=666&#39;)\n  &#125;\n\n\n  return (&lt;&gt;\n  &lt;h1&gt;函数式组件传值&lt;/h1&gt;\n  &lt;button onClick=&#123;()=&gt;&#123;search()&#125;&#125;&gt;search传参&lt;/button&gt;\n\n  &lt;/&gt;)\n&#125;;\n\nexport default From;\n</code></pre>\n<p><code>to组件</code></p>\n<pre><code>import React from &#39;react&#39;;\nimport &#123; useParams, useSearchParams ,useLocation&#125; from &#39;react-router-dom&#39;;\n\nconst To = () =&gt; &#123;\nconst [search] = useSearchParams()\nconsole.log(search.get(&#39;num&#39;));\n\n\n  return (\n    &lt;&gt;\n\n    &lt;h1&gt;函数式组件接受值&lt;/h1&gt;\n    \n    search传递的参数为\n   \n    &lt;/&gt;\n  )\n\n&#125;;\n\nexport default To;\n</code></pre>\n<p><code>运行结果</code></p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030190608909.png\" alt=\"image-20221030190608909\"></p>\n<h2 id=\"3、state传参\"><a href=\"#3、state传参\" class=\"headerlink\" title=\"3、state传参\"></a>3、state传参</h2><p>优点：可以传对象</p>\n<p>缺点： <code>&lt;HashRouter&gt;</code>刷新页面，参数丢失</p>\n<p><code>路由配置</code></p>\n<pre><code class=\"jsx\">&lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>from</code>组件</p>\n<pre><code class=\"jsx\">import React from &quot;react&quot;;\nimport &#123; useNavigate &#125; from &#39;react-router-dom&#39;;\nconst From = () =&gt; &#123;\n\n  const navigate = useNavigate()\n\n\n\n  const state = ()=&gt;&#123;\n\n    navigate(&#39;to&#39;,&#123;state:&#123;\n      name:&#39;叶星辰&#39;,\n      age:&#39;18&#39;,\n      hobby:&quot;敲代码&quot;\n    &#125;\n  \n    &#125;)\n  &#125;\n  return (&lt;&gt;\n  &lt;h1&gt;函数式组件传值&lt;/h1&gt;\n\n  &lt;button onClick=&#123;()=&gt;&#123;state()&#125;&#125;&gt;state传参&lt;/button&gt;\n  &lt;/&gt;)\n&#125;;\n\nexport default From;\n</code></pre>\n<p><code>to组件</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useParams, useSearchParams ,useLocation&#125; from &#39;react-router-dom&#39;;\n\nconst To = () =&gt; &#123;\n\nconst &#123; state: &#123; name, age, hobby &#125; &#125; = useLocation()\n\n  return (\n    &lt;&gt;\n    statec传递的参数为姓名&#123;name&#125;年纪&#123;age&#125;爱好&#123;hobby&#125;\n    &lt;/&gt;\n  )\n\n&#125;;\n\nexport default To;\n</code></pre>\n<p><code>运行结果</code></p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030180814827.png\" alt=\"image-20221030180814827\"></p>\n<h1 id=\"二、类组件\"><a href=\"#二、类组件\" class=\"headerlink\" title=\"二、类组件\"></a>二、类组件</h1><p>类组件不能用到useNavigate等hooks,所以采用NavLink的方式跳转路由，同理，函数式组件中也可以用NavLink的方式跳转路由</p>\n<p>如果不用withRouter，发现组件的this.props是一个空对象</p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030194100624.png\" alt=\"image-20221030194100624\"></p>\n<p>经过各方查阅，我们在react-router-dom v6版本中，已经去除了withRouter，所以在这里我们可以自己封装，但还是推荐使用函数式组件hooks</p>\n<p>js版本:</p>\n<pre><code class=\"js\">import &#123; useLocation, useNavigate &#125; from &quot;react-router-dom&quot;;\nexport function withRouter( Child ) &#123;\n  return ( props ) =&gt; &#123;\n    const location = useLocation();\n    const navigate = useNavigate();\n    const params = useParams();\n    return &lt;Child &#123; ...props &#125; navigate=&#123; navigate &#125; location=&#123; location &#125; params=&#123; params &#125;/&gt;;\n  &#125;\n&#125;\n</code></pre>\n<p>ts版本:</p>\n<pre><code class=\"ts\">import React from &quot;react&quot;;\nimport &#123; NavigateFunction, useLocation, useNavigate, useParams &#125; from &quot;react-router&quot;;\n\nexport interface RoutedProps&lt;Params = any, State = any&gt; &#123;\n    location: State;\n    navigate: NavigateFunction;\n    params: Params;\n&#125;\n\n\nexport function withRouter&lt;P extends RoutedProps&gt;( Child: React.ComponentClass&lt;P&gt; ) &#123;\n    return ( props: Omit&lt;P, keyof RoutedProps&gt; ) =&gt; &#123;\n        const location = useLocation();\n        const navigate = useNavigate();\n        const params = useParams();\n        return &lt;Child &#123; ...props as P &#125; navigate=&#123; navigate &#125; location=&#123; location &#125; params=&#123; params &#125;/&gt;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1、params传参-1\"><a href=\"#1、params传参-1\" class=\"headerlink\" title=\"1、params传参\"></a>1、params传参</h2><p><code>路由配置</code></p>\n<pre><code class=\"jsx\">&lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to:number&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>From组件</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; NavLink, Link &#125; from &quot;react-router-dom&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nclass FromClass extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;类组件传参&lt;/h1&gt;\n        &lt;Link to=&#123;&quot;/to:666&quot;&#125;&gt;详情&lt;/Link&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(FromClass);\n\n</code></pre>\n<p><code>to组件</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nclass ToClass extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        params传递的参数为&#123;this.props.params.number&#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(ToClass);\n</code></pre>\n<p>运行结果:</p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030195320898.png\" alt=\"image-20221030195320898\"></p>\n<h2 id=\"2、-search传参-1\"><a href=\"#2、-search传参-1\" class=\"headerlink\" title=\"2、. search传参\"></a>2、. search传参</h2><p><code>路由配置</code></p>\n<pre><code class=\"jsx\">    &lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>from组件</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; NavLink, Link &#125; from &quot;react-router-dom&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nclass FromClass extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;类组件传参&lt;/h1&gt;\n        &lt;Link to=&#123;&quot;/to/?number=666&quot;&#125;&gt;详情&lt;/Link&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(FromClass);\n</code></pre>\n<p><code>to组件</code></p>\n<p>由于search传递的参数比较特殊，所以用query-string解析一下就行</p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nimport qs from &quot;query-string&quot;;\nclass ToClass extends Component &#123;\n  render() &#123;\n    console.log(qs.parse(this.props.location.search));\n    return (\n      &lt;div&gt;\n        search传递的参数为&#123;qs.parse(this.props.location.search).number&#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(ToClass);\n</code></pre>\n<p><code>运行结果</code></p>\n<p><img data-src=\"/react-study/react-router-params/image-20221030200459605.png\" alt=\"image-20221030200459605\"></p>\n<h2 id=\"3、state传参-1\"><a href=\"#3、state传参-1\" class=\"headerlink\" title=\"3、state传参\"></a>3、state传参</h2><p><code>路由配置</code></p>\n<pre><code class=\"jsx\">&lt;Routes&gt;\n      &lt;Route path=&quot;/&quot; element=&#123;&lt;From /&gt;&#125; /&gt;\n      &lt;Route path=&quot;to&quot; element=&#123;&lt;To /&gt;&#125; /&gt;\n    &lt;/Routes&gt;\n</code></pre>\n<p><code>from</code>组件</p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; NavLink, Link &#125; from &quot;react-router-dom&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nclass FromClass extends Component &#123;\n  render() &#123;\n    const path = &#123;\n      pathname: &quot;to&quot;,\n      state: &#123;\n        name: &quot;叶星辰&quot;,\n        age: 18\n      &#125;\n    &#125;;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;类组件传参&lt;/h1&gt;\n        &lt;Link to=&#123;path&#125;&gt;传参&lt;/Link&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(FromClass);\n</code></pre>\n<p><code>to组件</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; withRouter &#125; from &quot;./withRouter&quot;;\nimport qs from &quot;query-string&quot;;\nclass ToClass extends Component &#123;\n  render() &#123;\n    console.log(this.props);\n    return (\n      &lt;div&gt;\n       \n        state传递的参数为&#123;this.props.location.state&#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(ToClass);\n</code></pre>\n<p><code>运行结果</code></p>\n<p>扩展延伸:react-router-dom中<code>NavLink</code>和<code>Link</code>的区别</p>\n<p>在 ReactJS 中，有三种不同的链接。这些是<code>NavLink</code>、、<code>Link</code>和<code>a</code>链接，它们都有不同的用途。</p>\n<ol>\n<li>**<code>NavLink</code>**：当您想要突出显示当前或活动链接时使用此选项。这与<code>activeClassName</code>启用它的属性一起使用。请参见下面的示例。</li>\n</ol>\n<pre><code>&lt;NavLink to=&quot;/home&quot; activeClassName=&quot;active&quot; &gt;Home&lt;/NavLink&gt;&lt;br/&gt;\n</code></pre>\n<p>然后<code>CSS</code>可以根据您在<code>App.css</code>文件中的选择设置样式。让我们将文本颜色设为红色以使其简单。</p>\n<pre><code>.active&#123;\n  color:red;\n&#125;\n</code></pre>\n<ol>\n<li>**<code>Link</code>**：当您的链接没有特殊样式或突出显示时使用。请参见下面的示例。</li>\n</ol>\n<pre><code>&lt;Link to=&quot;/not-active&quot;&gt;Not Active &lt;/Link&gt;&lt;br/&gt;\n</code></pre>\n<blockquote>\n<p>注意：当您需要链接到属于您的应用程序的页面时，请使用<code>NavLink</code>或。<code>Link</code>对于外部链接，<code>a</code>是首选。</p>\n</blockquote>\n<ol>\n<li>**锚标记<code>a</code>**：这用于网页外的链接。<br>请参见下面的示例。</li>\n</ol>\n<pre><code>&lt;a href=&quot;https://www.educative.io/edpresso&quot;&gt;Visit Edpresso &lt;/a&gt;\n</code></pre>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>当<code>NavLink</code>您想要将链接突出显示为活动时使用。因此，在每次路由到页面时，链接都会根据<code>activeClassName</code>. <code>Link</code>用于不需要突出显示的链接。并且<code>a</code>用于外部链接。</p>\n",
            "tags": [
                "react学习",
                "react",
                "router"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/Blog_introduction/Blog_introduction/",
            "url": "https://www.yexingcheng.com/Blog_introduction/Blog_introduction/",
            "title": "Welcome!",
            "date_published": "2022-09-30T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "index",
                "index"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/interview/interview/",
            "url": "https://www.yexingcheng.com/interview/interview/",
            "title": "面试题总结",
            "date_published": "2022-09-30T16:00:00.000Z",
            "content_html": "<h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h3 id=\"柯里化和反柯里化\"><a href=\"#柯里化和反柯里化\" class=\"headerlink\" title=\"柯里化和反柯里化\"></a>柯里化和反柯里化</h3><blockquote>\n<p>柯里化，可以理解为<strong>提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数</strong>。因为这样的特性，也被称为部分计算函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。</p>\n<p>反柯里化，是一个<strong>泛型化</strong>的过程。它使得被反柯里化的函数，可以<strong>接收更多参数</strong>。目的是创建一个更普适性的函数，可以被不同的对象使用。有鸠占鹊巢的效果。</p>\n</blockquote>\n<h3 id=\"async和await\"><a href=\"#async和await\" class=\"headerlink\" title=\"async和await\"></a>async和await</h3><blockquote>\n<p>async声明一个function来表示这个异步函数，await用于等待函数中某个异步操作执行完成。</p>\n</blockquote>\n<h3 id=\"对象类型的数组去重\"><a href=\"#对象类型的数组去重\" class=\"headerlink\" title=\"对象类型的数组去重\"></a>对象类型的数组去重</h3><pre><code class=\"js\">let arr = [\n  &#123;\n    key: &#39;1&#39;,\n    name: &#39;林青霞&#39;\n  &#125;,\n  &#123;\n    key: &#39;2&#39;,\n    name: &#39;张三丰&#39;\n  &#125;,\n  &#123;\n    key: &#39;1&#39;,\n    name: &#39;段誉&#39;\n  &#125;,\n]\nlet obj = &#123;&#125;\nlet res = arr.reduce(function (preValue, item) &#123;\n  obj[item.key] ? &#39;&#39; : obj[item.key] = true &amp;&amp; preValue.push(item);\n  return preValue\n&#125;, [])//将返回值的初始值定义为空数组\nconsole.log(res, &#39;===&#39;)//打印去重之后的数组\n</code></pre>\n<h3 id=\"箭头函数和普通函数的区别\"><a href=\"#箭头函数和普通函数的区别\" class=\"headerlink\" title=\"箭头函数和普通函数的区别\"></a>箭头函数和普通函数的区别</h3><blockquote>\n<p>箭头函数不会创建自己的<code>this</code>，所以它没有自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。</p>\n<p>箭头函数中的this指向永远不变</p>\n<p>而箭头函数就不可以使用<code>arguments</code>对象，获取不到输入的参数。</p>\n<p>使用场景</p>\n</blockquote>\n<p>判断一个变量类型的方式</p>\n<blockquote>\n<p>&#x2F;&#x2F;typeof</p>\n<pre><code class=\"js\">console.log(typeof a);    //&#39;undefined&#39;    \nconsole.log(typeof(true));  //&#39;boolean&#39;    \nconsole.log(typeof &#39;123&#39;);  //&#39;string&#39;   \nconsole.log(typeof 123);   //&#39;number&#39;    \nconsole.log(typeof NaN);   //&#39;number&#39;    \nconsole.log(typeof null);  //&#39;object&#39;       \nvar obj = new String();    console.log(typeof(obj));    //&#39;object&#39;    \nvar  fn = function()&#123;&#125;;    console.log(typeof(fn));  //&#39;function&#39;    \nconsole.log(typeof(class c&#123;&#125;));  //&#39;function&#39;\n</code></pre>\n<p>&#x2F;&#x2F;instanceof</p>\n<pre><code class=\"js\">var arr = []\n\n// example\nvar arr = [];\n\n//由于：\narr.constructor === Array\narr.__proto__ === Array.prototype\narr.__poto__.proto__ === Object.prototype\n\n//所以, 以下都返回true\narr instanceof arr.constructor(Array)\narr instanceof arr.__proto__.constructor(Array)\narr instanceof arr.__proto__.__poto__.constructor(Object)\n</code></pre>\n<pre><code class=\"js\">console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String]\nconsole.log(Object.prototype.toString.call(12));//[object Number]\nconsole.log(Object.prototype.toString.call(true));//[object Boolean]\nconsole.log(Object.prototype.toString.call(undefined));//[object Undefined]\nconsole.log(Object.prototype.toString.call(null));//[object Null]\nconsole.log(Object.prototype.toString.call(&#123;name: &quot;jerry&quot;&#125;));//[object Object]\nconsole.log(Object.prototype.toString.call(function()&#123;&#125;));//[object Function]\nconsole.log(Object.prototype.toString.call([]));//[object Array]\nconsole.log(Object.prototype.toString.call(new Date));//[object Date]\nconsole.log(Object.prototype.toString.call(/\\d/));//[object RegExp]\nfunction Person()&#123;&#125;;\nconsole.log(Object.prototype.toString.call(new Person));//[object Object]\n</code></pre>\n<p>constructor</p>\n<pre><code class=\"js\">function a() &#123;&#125;\nlet a = new b;\nconsole.log(a.constructor.name);//a\nconsole.log(b.constructor);//Function（）&#123;&#125;\nconsole.log(Function.constructor);//Function（）&#123;&#125;\n</code></pre>\n</blockquote>\n<p>ES5和ES6继承的区别</p>\n<blockquote>\n<p>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上<br>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改 this。<br>ES5 的继承时通过原型或构造函数机制来实现。<br>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。 子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。 super 关键字指代父类的实例，即父类的 this 对象。 在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。<br>ES5的构造函数可以不进行构造调用即可以当普通函数使用，而ES6的class只能通过new来调用。<br>class的所有方法（包括静态方法和实例方法）都是不可枚举的且都没有原型对象 prototype，所以也没有[[constructor]]，不能使用 new 来调用</p>\n</blockquote>\n<p>事件循环</p>\n<blockquote>\n</blockquote>\n<p>promise</p>\n<blockquote>\n<p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：</p>\n<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>\n<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>\n<p>但是请注意以下两点：</p>\n<ul>\n<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>\n<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>\n</ul>\n</blockquote>\n<h1 id=\"Vue3\"><a href=\"#Vue3\" class=\"headerlink\" title=\"Vue3\"></a>Vue3</h1><h3 id=\"vue3的缺点\"><a href=\"#vue3的缺点\" class=\"headerlink\" title=\"vue3的缺点\"></a>vue3的缺点</h3><blockquote>\n</blockquote>\n<h3 id=\"vue命名路由\"><a href=\"#vue命名路由\" class=\"headerlink\" title=\"vue命名路由\"></a>vue命名路由</h3><pre><code class=\"json\">  &#123;\n    path: &quot;/&quot;,//重定向\n    redirect: &quot;/home&quot;,\n  &#125;,\n&#125;\n    path: &quot;/home&quot;, // 地址栏地址 - 路由\n    name: &quot;home&quot;, // 命名路由  ---   唯一性\n    components: &#123;\n      default: HomeView,\n      footer: Footer\n    &#125;, // 路由映射的页面组件\n    //页面中\n &lt;router-view name = &quot;default&quot;/&gt;\n &lt;router-view name = &quot;footer&quot;/&gt;\n</code></pre>\n<h3 id=\"浏览器渲染的过程\"><a href=\"#浏览器渲染的过程\" class=\"headerlink\" title=\"浏览器渲染的过程\"></a>浏览器渲染的过程</h3><blockquote>\n<p>处理HTML 标记并构建DOM 树。<br>处理CSS 标记并构建CSSOM 树。<br>将DOM 与CSSOM 合并成一个渲染树。<br>根据渲染树来布局，计算每个节点的几何信息。<br>将各个节点绘制到屏幕上。</p>\n</blockquote>\n<h3 id=\"vue3自定义指令\"><a href=\"#vue3自定义指令\" class=\"headerlink\" title=\"vue3自定义指令\"></a>vue3自定义指令</h3><pre><code class=\"vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt;\n    &lt;input v-focus&gt;\n&lt;/div&gt;\n \n&lt;script&gt;\nconst app = Vue.createApp(&#123;&#125;)\n// 注册一个全局自定义指令 `v-focus`\napp.directive(&#39;focus&#39;, &#123;\n  // 当被绑定的元素挂载到 DOM 中时……\n  mounted(el) &#123;\n    // 聚焦元素\n    el.focus()\n  &#125;\n&#125;)\napp.mount(&#39;#app&#39;)\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"v-clock和v-pre\"><a href=\"#v-clock和v-pre\" class=\"headerlink\" title=\"v-clock和v-pre\"></a>v-clock和v-pre</h3><blockquote>\n<p>v-clock在编译成功后会删除，可以使用属性选择器解决加载闪烁问题<br>v-pre会阻止编译，有此指令的的标签内部的内容不会被编译，会原样输出</p>\n</blockquote>\n<h3 id=\"为什么需要状态管理器？\"><a href=\"#为什么需要状态管理器？\" class=\"headerlink\" title=\"为什么需要状态管理器？\"></a>为什么需要状态管理器？</h3><blockquote>\n<p>多个视图依赖同一个状态多个</p>\n<p>视图都需要变更状态</p>\n<p>例如：各个组件都需要检测用户登录状态</p>\n</blockquote>\n<h3 id=\"导航守卫\"><a href=\"#导航守卫\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h3><blockquote>\n<p>三大类：全局 组件内 路由独享</p>\n</blockquote>\n<h3 id=\"Vue单页面优缺点\"><a href=\"#Vue单页面优缺点\" class=\"headerlink\" title=\"Vue单页面优缺点\"></a>Vue单页面优缺点</h3><blockquote>\n<p>一旦页面加载完成，SPA不会因为用户操作而进行页面重新加载或跳转，取而代之的是利用路由机制实现Html内容的变换。<br>优点：</p>\n<p>用户体验好、快，内容改变不需要加载整个页面，对服务器压力小<br>前后端分离 完全的前端组件化，代码结构和组织方式更加规范化，便于修改和调整</p>\n<p>缺点：</p>\n<p>首次加载页面需大量加载静态资源，时间相对比较长 不利于seo优化，单页面数据在前端渲染意味着没有seo<br>页面导航不可用 如果要导航需要自行实现前进后退<br>页面复杂度提高很多</p>\n</blockquote>\n<h3 id=\"V-model的三个修饰符\"><a href=\"#V-model的三个修饰符\" class=\"headerlink\" title=\"V-model的三个修饰符\"></a>V-model的三个修饰符</h3><blockquote>\n<p>1.lazy：可以等待用户敲回车或者输入框输入焦点时才将数据写到data中<br>（可以提高效率）接管 input 的事件监听事件，输入的时候不会马上响应在展示层，当数据确认改变的时候才会显示出来；<br>2.number：只有输入数字才会显示<br>（v-<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1tb2RlbCZzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA==\">model</span>默认将输入的数字当成字符串类型，使用number就直接当成数字类型）<br>3.trim：去除左右两边多余空格</p>\n</blockquote>\n<h3 id=\"Vue的路由传参\"><a href=\"#Vue的路由传参\" class=\"headerlink\" title=\"Vue的路由传参\"></a>Vue的路由传参</h3><blockquote>\n<p><strong>ue</strong> 路由传参的使用场景一般都是应用在父路由跳转到子路由时，携带参数跳转。传参方式可划分为 <code>params</code> 传参和 <code>query</code> 传参，而 <code>params</code> 传参又可分为在 <strong>url</strong> 中显示参数和不显示参数两种方式，这就是vue路由传参的三种方式。</p>\n<h2 id=\"方式一：params-传参（显示参数）\"><a href=\"#方式一：params-传参（显示参数）\" class=\"headerlink\" title=\"方式一：params 传参（显示参数）\"></a>方式一：<code>params</code> 传参（显示参数）</h2><p>1、声明式 <code>router-link</code></p>\n<pre><code class=\"vue\">//子路由配置\n&#123;\n path: &#39;/child/:id&#39;,\n component: Child\n&#125;\n//父路由组件\n&lt;router-link :to=&quot;/child/123&quot;&gt;进入Child路由&lt;/router-link&gt;\n</code></pre>\n<p>2、编程式 <code>this.$router.push</code></p>\n<pre><code class=\"vue\">//子路由配置\n&#123;\n path: &#39;/child/:id&#39;,\n component: Child\n&#125;\n//父路由编程式传参(一般通过事件触发)\nthis.$router.push(&#123;\n   path:&#39;/child/$&#123;id&#125;&#39;,\n&#125;)\n</code></pre>\n<p><strong>在子路由中可以通过下面代码来获取传递的参数值</strong></p>\n<pre><code class=\"js\">this.$route.params.id\n</code></pre>\n<h2 id=\"方式二：params-传参（不显示参数）\"><a href=\"#方式二：params-传参（不显示参数）\" class=\"headerlink\" title=\"方式二：params 传参（不显示参数）\"></a>方式二：<code>params</code> 传参（不显示参数）</h2><p>params 传参（不显示参数）也可分为 声明式 和 编程式 两种方式，与方式一不同的是，这里是通过路由的别名 name 进行传值的</p>\n<p>1、声明式 router-link</p>\n<p>该方式也是通过 router-link 组件的 to 属性实现，例如：</p>\n<pre><code class=\"vue\">&lt;router-link :to=&quot;&#123;name:&#39;Child&#39;,params:&#123;id:123&#125;&#125;&quot;&gt;进入Child路由&lt;/router-link&gt;\n</code></pre>\n<p>2、编程式 this.$router.push</p>\n<p>使用该方式传值的时候，同样需要子路由提前配置好参数，不过不能再使用 :&#x2F;id 来传递参数了，因为父路由中，已经使用 params 来携带参数了，例如：</p>\n<pre><code class=\"vue\">//子路由配置\n&#123;\n path: &#39;/child,\n name: &#39;Child&#39;,\n component: Child\n&#125;\n//父路由编程式传参(一般通过事件触发)\nthis.$router.push(&#123;\n   name:&#39;Child&#39;,\n   params:&#123;\n    id:123\n   &#125;\n&#125;)\n</code></pre>\n<p>在子路由中可以通过下面代码来获取传递的参数值</p>\n<pre><code class=\"vue\">this.$route.params.id\n</code></pre>\n<p><strong>注意：上述这种利用 <code>params</code> 不显示 <code>url</code> 传参的方式会导致在刷新页面的时候，传递的值会丢失</strong></p>\n<p>方式三：query 传参（显示参数）<br>query 传参（显示参数）也可分为 声明式 和 编程式 两种方式</p>\n<p>1、声明式 router-link</p>\n<p>该方式也是通过 router-link 组件的 to 属性实现，不过使用该方式传值的时候，需要子路由提前配置好路由别名（name 属性），例如：</p>\n<pre><code>//子路由配置\n&#123;\n path: &#39;/child,\n name: &#39;Child&#39;,\n component: Child\n&#125;\n//父路由组件\n&lt;router-link :to=&quot;&#123;name:&#39;Child&#39;,query:&#123;id:123&#125;&#125;&quot;&gt;进入Child路由&lt;/router-link&gt;\n</code></pre>\n<p>2、编程式 this.$router.push</p>\n<p>使用该方式传值的时候，同样需要子路由提前配置好路由别名（name 属性），例如：</p>\n<pre><code>//子路由配置\n&#123;\n path: &#39;/child,\n name: &#39;Child&#39;,\n component: Child\n&#125;\n//父路由编程式传参(一般通过事件触发)\nthis.$router.push(&#123;\n   name:&#39;Child&#39;,\n   query:&#123;\n    id:123\n   &#125;\n&#125;)\n</code></pre>\n<p>在子路由中可以通过下面代码来获取传递的参数值</p>\n<pre><code>this.$route.query.id\n</code></pre>\n</blockquote>\n<p>Vue的路由模式</p>\n<blockquote>\n<p>Vue-Router有两个路由模式，分别是哈希hash模式和历史history模式，然后默认的是哈希hash模式。</p>\n<p>hash模式是开发中默认的模式，它的URL带着一个#，例如：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20vIy92dWUlRUYlQkMlOEMlRTUlQUUlODMlRTclOUElODRoYXNoJUU1JTgwJUJDJUU1JUIwJUIxJUU2JTk4JUFGIy92dWU=\">www.baidu.com/#/vue，它的hash值就是#/vue</span></p>\n<p>hash的值会出现再URL里面的，但是不会出现再HTTP请求之中的，也就是说，它并没有向后端发起请求，对后端是没有影响的</p>\n<p>history模式的URL中没有#，它使用传统的路由分发模式，就是说用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的处理，也就是它向服务器发起了一个请求差不错</p>\n</blockquote>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h3 id=\"严格模式的理解\"><a href=\"#严格模式的理解\" class=\"headerlink\" title=\"严格模式的理解\"></a>严格模式的理解</h3><blockquote>\n<p>打开方式：React.StricMode<br>识别不安全的生命周期<br>关于使用过时字符串 ref API 的警告<br>关于使用废弃的 findDOMNode 方法的警告<br>检测意外的副作用<br>检测过时的 context API<br>确保可复用的状态  从 React 18 开始的严格模式，每当组件在开发中挂载时，React 会模拟立即卸载和重新挂载组件：在第二次挂载时，React 将恢复第一次装载时的状态。<br>卸载和重新挂载的函数，包括<br>componentDidMount<br>componentWillUnmount<br>useEffect<br>useLayoutEffect<br>useInsertionEffect<br>这只适用于开发模式，生产环境没有变化。</p>\n</blockquote>\n<h3 id=\"react修改状态对象和函数的不同之处\"><a href=\"#react修改状态对象和函数的不同之处\" class=\"headerlink\" title=\"react修改状态对象和函数的不同之处\"></a>react修改状态对象和函数的不同之处</h3><blockquote>\n<p>对象会合并，this.setState()  的第一个参数也可以是函数，这个函数接收两个参数：<br>第一个参数为更新前的状态值，第二个参数为 props（可获取父级组件传递的数据）；当修改状态时涉及到前一个状态值时就可以使用这种形式。<br>函数会拿到上一次状态结果的值</p>\n</blockquote>\n<h3 id=\"React事件绑定的原理\"><a href=\"#React事件绑定的原理\" class=\"headerlink\" title=\"React事件绑定的原理\"></a>React事件绑定的原理</h3><blockquote>\n<p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p>\n</blockquote>\n<h3 id=\"Reack状态提示以及使用场景\"><a href=\"#Reack状态提示以及使用场景\" class=\"headerlink\" title=\"Reack状态提示以及使用场景\"></a>Reack状态提示以及使用场景</h3><blockquote>\n<p>实现方式是 利用最近的共同的父级组件中，用<code>props</code>的方式传过去到两个子组件，<code>props</code>中传的是一个<code>setState</code>的方法，通过子组件触发<code>props</code>传过去的方法，进而调用父级组件的<code>setState</code>的方法，改变了父级组件的<code>state</code>，调用父级组件的<code>add</code>方法，进而同时改变了两个子级组件的<code>数据</code>。</p>\n<p>这是 两个有关连的<strong>同级组件</strong>的传值，因为<code>react</code>的单项数据流，所以不在两个组件中进行传值，而是提升到 最近的共同的父级组件中，改变父级的<code>state</code>,进而影响了两个子级组件的<code>render</code>。</p>\n<p>组件之间状态共享</p>\n</blockquote>\n<h3 id=\"React高阶组件\"><a href=\"#React高阶组件\" class=\"headerlink\" title=\"React高阶组件\"></a>React高阶组件</h3><blockquote>\n<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>\n<p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p>\n</blockquote>\n<h3 id=\"React路由跳转-路由传参-路由拿到参数\"><a href=\"#React路由跳转-路由传参-路由拿到参数\" class=\"headerlink\" title=\"React路由跳转 路由传参 路由拿到参数\"></a>React路由跳转 路由传参 路由拿到参数</h3><blockquote>\n</blockquote>\n<h3 id=\"React组件优化-类组件-函数式组件\"><a href=\"#React组件优化-类组件-函数式组件\" class=\"headerlink\" title=\"React组件优化 类组件 函数式组件\"></a>React组件优化 类组件 函数式组件</h3><blockquote>\n<p>类组件中：</p>\n<p>继承Component改为React.PureComponent  或者用shouldComponentUpdate</p>\n<p>某一个组件内部所有的数据都来源于父级，子组件只负责渲染，如果数据不变就不重新渲染</p>\n<h3 id=\"React-memo-基本使用\"><a href=\"#React-memo-基本使用\" class=\"headerlink\" title=\"React.memo 基本使用\"></a>React.memo 基本使用</h3><p>将函数组件变成纯组件，将当前props 和上一次的 props 进行浅层比较，如果相同就阻止组件重新渲染</p>\n<p>组件懒加载</p>\n<p>组件创建错误边界</p>\n</blockquote>\n<p>React状态管理器有哪几个，rtk的流程</p>\n<blockquote>\n</blockquote>\n<p>React中类组件和函数式组件的区别</p>\n<blockquote>\n</blockquote>\n",
            "tags": [
                "面试用",
                "js",
                "面试",
                "vue",
                "react"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/interview/programming/",
            "url": "https://www.yexingcheng.com/interview/programming/",
            "title": "编程题总结",
            "date_published": "2022-09-30T16:00:00.000Z",
            "content_html": "<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><pre><code class=\"javascript\">const arr = [1, [2, [3, [4, 5]]], 6]\n\n\nfunction reduceDimension(arr) &#123;\n  let ret = [];\n  let toArr = function (arr) &#123;\n    arr.forEach(function (item) &#123;\n      item instanceof Array ? toArr(item) : ret.push(item);\n    &#125;);\n  &#125;\n  toArr(arr);\n  return ret;\n\n&#125;\nconsole.log(reduceDimension(arr))\n</code></pre>\n<p>输出结果:<code>[ 1, 2, 3, 4, 5, 6 ]</code></p>\n<h3 id=\"数组对象去重\"><a href=\"#数组对象去重\" class=\"headerlink\" title=\"数组对象去重\"></a>数组对象去重</h3><pre><code class=\"javascript\">// let arr = [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;, &#123; a: 1 &#125;, &#123; a: 4 &#125;, &#123; a: 2 &#125;]\n\nlet arr = [\n  &#123;\n    key: &#39;1&#39;,\n    name: &#39;林青霞&#39;\n  &#125;,\n  &#123;\n    key: &#39;2&#39;,\n    name: &#39;张三丰&#39;\n  &#125;,\n  &#123;\n    key: &#39;1&#39;,\n    name: &#39;段誉&#39;\n  &#125;,\n]\nlet obj = &#123;&#125;\nlet res = arr.reduce(function (preValue, item) &#123;\n  console.log(preValue, &#39;--&#39;)//上一次调用回调返回的值，或者是提供的初始值\n  console.log(item, &#39;++&#39;)//下一个要遍历的数组成员\n  // 下面这句话是首先是判断当前数组成员的key是否存在于obj中，如果已经存在，将这个obj中的key设置为空，并且值设置为true，再将当前数组成员添加到返回值中\n  // 如果不存在，obj中的key为当前数组成员的key，并且值设置为true，再将当前数组成员添加到返回值中\n  obj[item.key] ? &#39;&#39; : obj[item.key] = true &amp;&amp; preValue.push(item);\n  console.log(obj, &#39;obj2&#39;)\n  return preValue\n&#125;, [])//将返回值的初始值定义为空数组\nconsole.log(res, &#39;===&#39;)//打印去重之后的数组\n</code></pre>\n<p>打印结果&#96;[] –</p>\n<p>{ key: ‘1’, name: ‘林青霞’ } ++</p>\n<p>{ ‘1’: 1 } obj2</p>\n<p>[ { key: ‘1’, name: ‘林青霞’ } ] –</p>\n<p>{ key: ‘2’, name: ‘张三丰’ } ++</p>\n<p>{ ‘1’: 1, ‘2’: 2 } obj2</p>\n<p>[ { key: ‘1’, name: ‘林青霞’ }, { key: ‘2’, name: ‘张三丰’ } ] –</p>\n<p>{ key: ‘1’, name: ‘段誉’ } ++</p>\n<p>{ ‘1’: 1, ‘2’: 2 } obj2</p>\n<p>[ { key: ‘1’, name: ‘林青霞’ }, { key: ‘2’, name: ‘张三丰’ } ] &#x3D;&#x3D;&#x3D;&#96;</p>\n<h3 id=\"验证括号合法性\"><a href=\"#验证括号合法性\" class=\"headerlink\" title=\"验证括号合法性:\"></a>验证括号合法性:</h3><pre><code class=\"js\">function fn(str) &#123;\n  let zhan = []\n  for (let i = 0; i &lt; str.length; i++) &#123;\n    if (str[i] === &quot;(&quot; || str[i] === &quot;[&quot; || str[i] === &quot;&#123;&quot;) &#123; zhan.push(str[i]) &#125; else &#123;\n      if (str[i] === &quot;&#125;&quot; &amp;&amp; &quot;&#123;&quot; === zhan.pop()) &#123; continue &#125; if (str[i] === &quot;)&quot; &amp;&amp; &quot;(&quot; === zhan.pop()) &#123; continue &#125; if (str[i] === &quot;]&quot;\n        &amp;&amp; &quot;[&quot; === zhan.pop()) &#123; ; continue &#125; return false;\n    &#125;\n  &#125; return zhan.length &gt; 0 ? false : true;\n&#125;\n\nconst s1 = &quot;()&quot;\nconst s2 = &quot;()[]&#123;&#125;&quot;;\nconst s3 = &quot;(]&quot;\nconst s4 = &quot;([)]&quot;\nconst s5 = &quot;([])&quot;\nconst s6 = &quot;&#123;([&#123;&#125;])&#125;&quot;\n\nconsole.log(fn(s1));\nconsole.log(fn(s2));\nconsole.log(fn(s3));\nconsole.log(fn(s4));\nconsole.log(fn(s5));\nconsole.log(fn(s6));\n</code></pre>\n<p>打印结果:&#96;true</p>\n<p>true</p>\n<p>false</p>\n<p>false</p>\n<p>true</p>\n<p>true&#96;</p>\n<h3 id=\"分糖果问题\"><a href=\"#分糖果问题\" class=\"headerlink\" title=\"分糖果问题:\"></a>分糖果问题:</h3><pre><code class=\"js\">\nfunction candy2(arr) &#123;\n  let res = new Array(arr.length).fill(1)\n  for (let i = 0; i &lt; arr.length; i++) &#123;\n    if (arr[i + 1] &gt; arr[i]) &#123;\n      res[i + 1] = res[i] + 1\n    &#125;\n  &#125;\n  for (let j = arr.length - 1; j &gt; 0; j--) &#123;\n    res[j - 1] = Math.max(res[j - 1], res[j] + 1)\n    res[j - 1] = res[j] + 1\n  &#125;\n\n  return res.reduce((a, b) =&gt; a + b);\n&#125;\n\nconsole.log(candy2([1, 1, 2]));//4\n</code></pre>\n<h3 id=\"兔子问题-（斐波那契数列）\"><a href=\"#兔子问题-（斐波那契数列）\" class=\"headerlink\" title=\"兔子问题:（斐波那契数列）\"></a>兔子问题:（斐波那契数列）</h3><pre><code class=\"js\">function rabbit(n) &#123;\n  if (n &lt;= 0)\n    return 0;\n  if (n == 1 || n == 2)\n    return 1;\n  return rabbit(n - 1) + rabbit(n - 2);\n&#125;\n\nconsole.log(\n  rabbit(6)\n)\n</code></pre>\n<p>打印结果<code>8</code></p>\n",
            "tags": [
                "面试用",
                "js",
                "面试"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/react-study/8/",
            "url": "https://www.yexingcheng.com/react-study/8/",
            "title": "React学习第八天",
            "date_published": "2022-08-07T16:00:00.000Z",
            "content_html": "<h1 id=\"十八、Redux\"><a href=\"#十八、Redux\" class=\"headerlink\" title=\"十八、Redux\"></a>十八、Redux</h1><h2 id=\"18-1-理解Flux架构\"><a href=\"#18-1-理解Flux架构\" class=\"headerlink\" title=\"18.1 理解Flux架构\"></a>18.1 理解Flux架构</h2><p>在2013年，Facebook让<code>React</code>亮相的同时推出了Flux框架，<code>React</code>的初衷实际上是用来替代<code>jQuery</code>的，<code>Flux</code>实际上就可以用来替代<code>Backbone.js</code>，<code>Ember.js</code>等一系列<code>MVC</code>架构的前端JS框架。</p>\n<p>其实<code>Flux</code>在<code>React</code>里的应用就类似于<code>Vue</code>中的<code>Vuex</code>的作用，但是在<code>Vue</code>中，<code>Vue</code>是完整的<code>mvvm</code>框架，而<code>Vuex</code>只是一个全局的插件。</p>\n<p><code>React</code>只是一个MVC中的V(视图层)，只管页面中的渲染，一旦有数据管理的时候，<code>React</code>本身的能力就不足以支撑复杂组件结构的项目，在传统的<code>MVC</code>中，就需要用到Model和Controller。Facebook对于当时世面上的<code>MVC</code>框架并不满意，于是就有了<code>Flux</code>, 但<code>Flux</code>并不是一个<code>MVC</code>框架，他是一种新的思想。</p>\n<p><img data-src=\"/react-study/8/flux.png\" alt=\"image-20220812002755397\"></p>\n<ul>\n<li>View： 视图层</li>\n<li>ActionCreator（动作创造者）：视图层发出的消息（比如mouseClick）</li>\n<li>Dispatcher（派发器）：用来接收Actions、执行回调函数</li>\n<li>Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</li>\n</ul>\n<p>Flux的流程：</p>\n<ol>\n<li>组件获取到store中保存的数据挂载在自己的状态上</li>\n<li>用户产生了操作，调用actions的方法</li>\n<li>actions接收到了用户的操作，进行一系列的逻辑代码、异步操作</li>\n<li>然后actions会创建出对应的action，action带有标识性的属性</li>\n<li>actions调用dispatcher的dispatch方法将action传递给dispatcher</li>\n<li>dispatcher接收到action并根据标识信息判断之后，调用store的更改数据的方法</li>\n<li>store的方法被调用后，更改状态，并触发自己的某一个事件</li>\n<li>store更改状态后事件被触发，该事件的处理程序会通知view去获取最新的数据</li>\n</ol>\n<h2 id=\"18-2-理解Redux单向数据流流程\"><a href=\"#18-2-理解Redux单向数据流流程\" class=\"headerlink\" title=\"18.2 理解Redux单向数据流流程\"></a>18.2 理解Redux单向数据流流程</h2><p>React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</p>\n<ul>\n<li>代码结构 </li>\n<li>组件之间的通信</li>\n</ul>\n<p>2013年 Facebook 提出了 Flux 架构的思想，引发了很多的实现。2015年，Redux 出现，将 Flux 与<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sbGg5MTEwMDEuZ2l0Ym9va3MuaW8vbW9zdGx5LWFkZXF1YXRlLWd1aWRlLWNoaW5lc2UvY29udGVudC8=\">函数式编程</span>结合一起，很短时间内就成为了最热门的前端架构。</p>\n<p>如果你不知道是否需要 Redux，那就是不需要它</p>\n<p>只有遇到 React 实在解决不了的问题，你才需要 Redux</p>\n<p>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</p>\n<ul>\n<li>用户的使用方式非常简单</li>\n<li>用户之间没有协作</li>\n<li>不需要与服务器大量交互，也没有使用 WebSocket</li>\n<li>视图层（View）只从单一来源获取数据</li>\n</ul>\n<p><strong>需要使用Redux的项目:</strong></p>\n<ul>\n<li>用户的使用方式复杂</li>\n<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>\n<li>多个用户之间可以协作</li>\n<li>与服务器大量交互，或者使用了WebSocket</li>\n<li>View要从多个来源获取数据</li>\n</ul>\n<p><strong>从组件层面考虑，什么样子的需要Redux：</strong></p>\n<ul>\n<li>某个组件的状态，需要共享</li>\n<li>某个状态需要在任何地方都可以拿到</li>\n<li>一个组件需要改变全局状态</li>\n<li>一个组件需要改变另一个组件的状态</li>\n</ul>\n<p><strong>Redux的设计思想：</strong></p>\n<ol>\n<li>Web 应用是一个状态机，视图与状态是一一对应的。</li>\n<li>所有的状态，保存在一个对象里面（唯一数据源）。</li>\n</ol>\n<blockquote>\n<p>注意：flux、redux都不是必须和react搭配使用的，因为flux和redux是完整的架构，在学习react的时候，只是将react的组件作为redux中的视图层去使用了。</p>\n</blockquote>\n<p><img data-src=\"/image%5Credux\" alt=\"image-20220812002936378\"></p>\n<h2 id=\"18-3-redux使用三大原则\"><a href=\"#18-3-redux使用三大原则\" class=\"headerlink\" title=\"18.3 redux使用三大原则\"></a>18.3 redux使用三大原则</h2><ul>\n<li>Single Source of Truth(唯一的数据源)</li>\n<li>State is read-only(状态是只读的) - 无法直接修改状态</li>\n<li>Changes are made with pure function(数据的改变必须通过纯函数完成)</li>\n</ul>\n<pre><code class=\"sh\">$ cnpm i redux -S\n</code></pre>\n<p><code>src/13_redux/store.js</code> 创建状态管理器</p>\n<pre><code class=\"js\">// createStore 方法在新版本中已经被弃用\nimport &#123; createStore &#125; from &#39;redux&#39;\n\n// 2.创建所有操作 reducer 以及定义初始化的状态 - 纯函数\n// 第一个参数为管理的状态，需要在此处书写 初始的状态\nconst reducer = (state = &#123;\n  msg: &#39;hello redux&#39;,\n  count: 10\n&#125;, action) =&gt; &#123; // action中type代表动作的标识，用于触发行为，payload代表传递的参数\n  switch (action.type) &#123;\n    case &#39;CAHNGE_MSG&#39;: // type的名字可以根据自己公司的需求进行更改\n      // 必须返回最新的状态\n      return &#123; ...state, msg: action.payload &#125;\n    case &#39;INCREMENT_COUNT&#39;:\n      return &#123; ...state, count: state.count + action.payload &#125;\n    case &#39;DECREMENT_COUNT&#39;:\n      return Object.assign(&#123;&#125;, state, &#123; count: state.count - action.payload &#125;)\n    default:\n      return state\n  &#125;\n&#125;\n\n// 创建状态管理器\nconst store = createStore(reducer)\n\nexport default store\n</code></pre>\n<p><code>src/index.js</code> 配置状态管理器 - 状态管理器修改订阅视图的更新</p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport store from &#39;./13_redux/store&#39;\n\nimport App from &#39;./13_redux/App&#39; \n\nconsole.log(store)\n// dispatch 可以触发reducer的更改\n// getState 可以用来获取状态管理器的数据\n// replaceReducer 替换reducer\n// subscribe 订阅数据的变化\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n\n// 订阅数据的变化，重新渲染视图\nstore.subscribe(() =&gt; &#123;\n  // 一旦检测到数据发生改变，此处代码就会执行\n  root.render(\n    &lt;App/&gt;\n  )\n&#125;)\n</code></pre>\n<p><code>src/13_redux/App.jsx</code>使用状态管理器</p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport Child1 from &#39;./Child1&#39;;\nimport Child2 from &#39;./Child2&#39;;\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;使用redux&lt;/h1&gt;\n      &lt;Child1 /&gt;\n      &lt;hr/&gt;\n      &lt;Child2 /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/13_redux/Child1.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport store from &#39;./store&#39;\nconst Child1 = () =&gt; &#123;\n  const state = store.getState() // 获取状态管理器中的状态\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;child1&lt;/h3&gt;\n      &lt;div&gt;\n        &#123; state.msg &#125; - &#123; state.count &#125;\n        &lt;button onClick=&#123;() =&gt; &#123;\n          store.dispatch(&#123;\n            type: &#39;CAHNGE_MSG&#39;,\n            payload: &#39;hello child1 redux&#39;\n          &#125;)\n        &#125;&#125;&gt;修改msg&lt;/button&gt;\n        &lt;button onClick=&#123; () =&gt; &#123;\n          store.dispatch(&#123;\n            type: &#39;INCREMENT_COUNT&#39;,\n            payload: 10\n          &#125;)\n        &#125; &#125;&gt;加10&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Child1;\n</code></pre>\n<p><code>src/13_redux/Child2.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport store from &#39;./store&#39;\nconst Child2 = () =&gt; &#123;\n  const state = store.getState() // 获取状态管理器中的状态\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;child2&lt;/h3&gt;\n      &#123; state.msg &#125; - &#123; state.count &#125;\n      &lt;button onClick=&#123;() =&gt; &#123;\n          store.dispatch(&#123;\n            type: &#39;CAHNGE_MSG&#39;,\n            payload: &#39;hello child2 redux&#39;\n          &#125;)\n        &#125;&#125;&gt;修改msg&lt;/button&gt;\n         &lt;button onClick=&#123; () =&gt; &#123;\n          store.dispatch(&#123;\n            type: &#39;DECREMENT_COUNT&#39;,\n            payload: 10\n          &#125;)\n        &#125; &#125;&gt;减10&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Child2;\n</code></pre>\n<p>以上代码是最最最最最最最基本的redux的使用，现在企业里基本上不使用这种原始的方法</p>\n<h2 id=\"18-4-redux-react-redux配合使用\"><a href=\"#18-4-redux-react-redux配合使用\" class=\"headerlink\" title=\"18.4 redux + react-redux配合使用\"></a>18.4 redux + react-redux配合使用</h2><blockquote>\n<p>redux是属于js的状态管理模式，不独属于react，在react中需要结合 react-redux 模块使用</p>\n</blockquote>\n<p>react-redux提供两个核心的api：</p>\n<ul>\n<li><p>Provider: 提供store <code>&lt;Provider store = &#123; store &#125;&gt;&lt;App /&gt;&lt;/store&gt;</code></p>\n</li>\n<li><p>connect: 用于连接容器组件和展示组件</p>\n<ul>\n<li><p>Provider</p>\n<p>根据单一store原则 ，一般只会出现在整个应用程序的最顶层。</p>\n</li>\n<li><p>connect</p>\n<p>语法格式为</p>\n<p><code>connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)(component)</code></p>\n<p>一般来说只会用到前面两个，它的作用是：</p>\n<ul>\n<li>把<code>store.getState()</code>的状态转化为展示组件的<code>props</code></li>\n<li>把<code>actionCreators</code>转化为展示组件<code>props</code>上的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>只要上层中有<code>Provider</code>组件并且提供了<code>store</code>, 那么，子孙级别的任何组件，要想使用<code>store</code>里的状态，都可以通过<code>connect</code>方法进行连接。如果只是想连接<code>actionCreators</code>，可以第一个参数传递为<code>null</code></p>\n<pre><code class=\"sh\">$ cnpm i react-redux -S\n</code></pre>\n<h3 id=\"18-4-1-创建状态管理器\"><a href=\"#18-4-1-创建状态管理器\" class=\"headerlink\" title=\"18.4.1 创建状态管理器\"></a>18.4.1 创建状态管理器</h3><p><code>src/14_redux-react_redux/store.js</code></p>\n<pre><code class=\"js\">import &#123; createStore &#125; from &#39;redux&#39;\n\nconst reducer = (state = &#123;\n  proList: [],\n  kindList: []\n&#125;, &#123; type, payload &#125;) =&gt; &#123; // action  解构了 &#123; type, payload &#125;\n  switch (type) &#123;\n    case &#39;CHANGE_PRO_LIST&#39;:\n      return &#123; ...state, proList: payload &#125;\n    case &#39;CHANGE_KIND_LIST&#39;:\n      return &#123; ...state, kindList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nconst store = createStore(reducer)\n\nexport default store\n</code></pre>\n<blockquote>\n<p>1.引入 createStore 方法（新版本中建议使用rtk）</p>\n<p>2.创建reducer（包含初始化状态，包含了修改状态的标识，返回了新的状态（对象合并））</p>\n<p>3.创建store</p>\n<p>4.暴露store</p>\n</blockquote>\n<h3 id=\"18-4-2-使用react-redux\"><a href=\"#18-4-2-使用react-redux\" class=\"headerlink\" title=\"18.4.2  使用react-redux\"></a>18.4.2  使用react-redux</h3><p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./14_redux_react-redux/store&#39;\nimport App from &#39;./14_redux_react-redux/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<blockquote>\n<p>使用了  react-redux 提供的组件组件 Provider 配合 store 完成传递数据</p>\n</blockquote>\n<p><code>src/14_redux_react-redux/App.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport Home from &#39;./Home&#39;;\nimport Kind from &#39;./Kind&#39;;\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;redux + react-redux&lt;/h1&gt;\n      &lt;Home /&gt;\n      &lt;hr /&gt;\n      &lt;Kind /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/14_redux_react-redux/Home.jsx</code> 业务逻辑写到了组件中</p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\n// 引入 connect 高阶组件 实际上 connect() 返回值才是高阶组件\nimport &#123; connect &#125; from &#39;react-redux&#39;;\n\n// 展示组件   ---- 理想情况：  负责数据的展示以及发起指令\nconst Home = (props) =&gt; &#123;\n  console.log(props) // &#123; proList: [], dispatch: function()&#125;\n  const &#123; proList, dispatch &#125; = props\n  useEffect(() =&gt; &#123;\n    // 在展示组件内 写业务逻辑\n    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      console.log(res.data) \n      // 修改状态\n      dispatch(&#123;\n        type: &#39;CHANGE_PRO_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n  &#125;, [dispatch]) // 依赖项最好 不要直接使用props，先将props进行解构，后添加依赖项\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;home&lt;/h3&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\n// mapStateToProps 负责给展示组件提供数据，提供给展示组件的props属性\nconst mapStateToProps = (state) =&gt; &#123; // state 参数即为管理的所有的状态\n  return &#123; // 必须含有返回值，返回什么取决于你的展示组件需要什么数据\n    proList: state.proList\n  &#125;\n&#125;\n// 返回的是一个 容器组件  ---- 理想情况： 负责给展示组件提供数据 以及执行 业务逻辑\nexport default connect(mapStateToProps)(Home);\n</code></pre>\n<p><code>src/14_redux_react-redux/Kind.jsx</code> 业务逻辑写到容器组件中</p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\nconst Kind = (props) =&gt; &#123;\n  const &#123; kindList, getKindListData &#125; = props\n  useEffect(() =&gt; &#123;\n    // 展示组件发起指令，后续交给容器组件处理\n    getKindListData()\n  &#125;, [getKindListData])\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;kind&lt;/h3&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\nconst mapStateToProps = (state) =&gt; &#123;\n  return &#123;\n    kindList: state.kindList\n  &#125;\n&#125;\n\n// 将业务逻辑交给容器组件组件处理\nconst mapDispatchToProps = (dispatch) =&gt; &#123; // dispatch 为默认参数，可以通过此 触发 reducer 中状态的更新\n  return &#123;\n    getKindListData () &#123; // 返回自定义函数，供 展示组件调用，展示组件通过 props 访问即可\n      fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n        console.log(res.data) \n        // 修改状态\n        dispatch(&#123;\n          type: &#39;CHANGE_KIND_LIST&#39;,\n          payload: res.data\n        &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;\nexport default connect(mapStateToProps, mapDispatchToProps)(Kind);\n</code></pre>\n<blockquote>\n<p>vuex中 可以把异步操作提取到vuex中的actions中，react中异步操作方式会有很多，最常见的就是 redux-thunk</p>\n</blockquote>\n<h2 id=\"18-5-redux-react-redux分模块使用\"><a href=\"#18-5-redux-react-redux分模块使用\" class=\"headerlink\" title=\"18.5 redux+react-redux分模块使用\"></a>18.5 redux+react-redux分模块使用</h2><blockquote>\n<p>如果项目很大，或者项目划分比较明确，需要将状态管理器也分模块去处理</p>\n<p>假设现在有一个home模块，管理 bannerList 以及 proList</p>\n<p>还有一个模块 kind 模块，管理 kindList </p>\n</blockquote>\n<p><code>src/15_redux_react-redux_combine/store/modules/home.js</code></p>\n<pre><code class=\"js\">// 单独管理home模块的状态管理器\nconst reducer = (state = &#123;\n  bannerList: [],\n  proList: []\n&#125;, &#123; type, payload &#125;) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_BANNER_LIST&#39;:\n      return &#123; ...state, bannerList: payload &#125;\n    case &#39;CHANGE_PRO_LIST&#39;:\n      return &#123; ...state, proList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nexport default reducer\n</code></pre>\n<p><code>src/15_redux_react-redux_combine/store/modules/kind.js</code></p>\n<pre><code class=\"js\">// 单独管理kind模块的状态管理器\nconst reducer = (state = &#123;\n  kindList: []\n&#125;, &#123; type, payload &#125;) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_KIND_LIST&#39;:\n      return &#123; ...state, kindList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nexport default reducer\n</code></pre>\n<blockquote>\n<p>整合多个reducer 为一个，因为 有一个原则 ： 单一数据源 的原则</p>\n</blockquote>\n<p><code>src/15_redux_react-redux_combine/store/index.js</code></p>\n<pre><code class=\"js\">import &#123; combineReducers, createStore &#125; from &#39;redux&#39;\nimport home from &#39;./modules/home&#39;\nimport kind from &#39;./modules/kind&#39;\n\nconst reducer = combineReducers(&#123;\n  home,\n  kind\n&#125;)\n\nconst store = createStore(reducer)\n\nexport default store\n</code></pre>\n<blockquote>\n<p>入口文件处引入状态管理器</p>\n</blockquote>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./15_redux_react-redux_combine/store/index&#39;\nimport App from &#39;./15_redux_react-redux_combine/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<blockquote>\n<p>组件中使用状态管理器</p>\n</blockquote>\n<p><code>src/15_redux_react-redux_combine/App.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport Home from &#39;./views/Home&#39;\nimport Kind from &#39;./views/Kind&#39;\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;Home /&gt;\n\n      &lt;hr&gt;&lt;/hr&gt;\n\n      &lt;Kind /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/15_redux_react-redux_combine/views/Home.jsx</code> 业务逻辑在展示型组件中</p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\nconst Home = (&#123; bannerList, proList, dispatch &#125;) =&gt; &#123;\n\n  useEffect(() =&gt; &#123;\n    fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_BANNER_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_PRO_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;div&gt;\n        &#123; \n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125; src=&#123; item.img &#125; alt=&#123;item.alt&#125; style=&#123;&#123; height: 100 &#125;&#125; /&gt;\n          ))\n        &#125;\n      &lt;/div&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default connect(\n  // (state) =&gt; (&#123; bannerList: state.home.bannerList, proList: state.home.proList &#125;)\n  // (&#123; home &#125;) =&gt; (&#123; bannerList: home.bannerList, proList: home.proList &#125;)\n  // (&#123; home: &#123; bannerList, proList &#125; &#125;) =&gt; (&#123; bannerList: bannerList, proList: proList &#125;)\n  (&#123; home: &#123; bannerList, proList &#125; &#125;) =&gt; (&#123; bannerList, proList &#125;)\n)(Home);\n</code></pre>\n<p><code>src/15_redux_react-redux_combine/views/Kind.jsx </code> 业务逻辑在容器组件中</p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\n// const Kind = connect(\n//   (&#123; kind: &#123; kindList &#125;&#125;) =&gt; (&#123; kindList &#125;), // state =&gt; &#123; return &#123; kindList: state.kind.kindList &#125;&#125;\n//   (dispatch) =&gt; (&#123;\n//     getKindListData () &#123;\n//       fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n//         dispatch(&#123;\n//           type: &#39;CHANGE_KIND_LIST&#39;,\n//           payload: res.data\n//         &#125;)\n//       &#125;)\n//     &#125;\n//   &#125;)\n// )((&#123; kindList, getKindListData &#125;) =&gt; &#123;\n//   useEffect(() =&gt; &#123;\n//     getKindListData()\n//   &#125;, [getKindListData])\n//   return (\n//     &lt;div&gt;\n//       &lt;h1&gt;Kind&lt;/h1&gt;\n//       &#123;\n//         kindList &amp;&amp; kindList.map(item =&gt; &#123;\n//           return (\n//             &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n//           )\n//         &#125;)\n//       &#125;\n//     &lt;/div&gt;\n//   );\n// &#125;);\n// export default Kind;\nconst Kind = (&#123; kindList, getKindListData &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    getKindListData()\n  &#125;, [getKindListData])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Kind&lt;/h1&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\nexport default connect(\n  (&#123; kind: &#123; kindList &#125;&#125;) =&gt; (&#123; kindList &#125;), // state =&gt; &#123; return &#123; kindList: state.kind.kindList &#125;&#125;\n  (dispatch) =&gt; (&#123;\n    getKindListData () &#123;\n      fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n        dispatch(&#123;\n          type: &#39;CHANGE_KIND_LIST&#39;,\n          payload: res.data\n        &#125;)\n      &#125;)\n    &#125;\n  &#125;)\n)(Kind);\n</code></pre>\n<blockquote>\n<p>细心的你发现，虽然展示组件的代码变少了，但是容器组件中还有 异步相关操作，能否把这些异步操作提取出去</p>\n</blockquote>\n<h2 id=\"18-6-redux-react-redux-分模块-异步操作\"><a href=\"#18-6-redux-react-redux-分模块-异步操作\" class=\"headerlink\" title=\"18.6 redux + react-redux + 分模块+ 异步操作\"></a>18.6 redux + react-redux + 分模块+ 异步操作</h2><blockquote>\n<p>配合redux 常用的异步模块 为 <code>redux-thunk</code>,  <code>redux-saga</code></p>\n</blockquote>\n<h3 id=\"18-6-1-redux-thunk\"><a href=\"#18-6-1-redux-thunk\" class=\"headerlink\" title=\"18.6.1 redux-thunk\"></a>18.6.1 redux-thunk</h3><pre><code class=\"sh\">$ cnpm i redux-thunk -S\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/store/modules/home.js</code></p>\n<pre><code class=\"js\">const reducer = (\n  state = &#123;\n    bannerList: [],\n    proList: []\n  &#125;,\n  &#123; type, payload &#125;\n) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_BANNER_LIST&#39;:\n      return &#123; ...state, bannerList: payload &#125;\n    case &#39;CHANGE_PRO_LIST&#39;:\n      return &#123; ...state, proList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nexport default reducer\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/store/modules/kind.js</code></p>\n<pre><code class=\"js\">const reducer = (\n  state = &#123;\n    kindList: []\n  &#125;,\n  &#123; type, payload &#125;\n) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_KIND_LIST&#39;:\n      return &#123; ...state, kindList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nexport default reducer\n</code></pre>\n<blockquote>\n<p>整合多个reducer 为一个，因为 有一个原则 ： 单一数据源 的原则</p>\n<p>并且后续需要使用 异步操作，将异步操作模块 使用进来</p>\n</blockquote>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/store/index.js</code></p>\n<pre><code class=\"jsx\">import &#123; createStore, combineReducers, applyMiddleware &#125; from &#39;redux&#39;\nimport thunk from &#39;redux-thunk&#39;\n\nimport home from &#39;./modules/home&#39;\nimport kind from &#39;./modules/kind&#39;\n\nconst reducer = combineReducers(&#123;\n  home,\n  kind\n&#125;)\n\n// 第二个参数表示代码中含有异步操作，且异步操作需要提取出 容器组件\nconst store = createStore(reducer, applyMiddleware(thunk))\n\nexport default store\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./16_redux_react-redux_redux-thunk_combine/store&#39;\nimport App from &#39;./16_redux_react-redux_redux-thunk_combine/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/App.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport Home from &#39;./views/Home&#39;\nimport Kind from &#39;./views/Kind&#39;\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;Home /&gt;\n      &lt;hr /&gt;\n      &lt;Kind /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>上一个案例 异步操作在组件，现在需要将其放到 异步操作模块中去 actionCreator</p>\n</blockquote>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/api/home.js</code></p>\n<pre><code class=\"js\">export function getBannerList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json())\n&#125;\n\nexport function getProList (params) &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/list?limitNum=&#39; + params.limitNum).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/api/kind.js</code></p>\n<pre><code class=\"js\">export function getKindList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/store/actions/home.js</code></p>\n<pre><code class=\"js\">// 容器组件抽离的异步操作都写在这里\n// 每一个action的函数记住一个原则，默认的参数为dispatch\n// 如果接口调用不需要传递参数，直接给函数写默认参数 dispatch\n// 如果接口调用需要传递参数，一般在返回一个函数，返回函数的 参数为 dispatch\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\n\n// actionCreator 本质是一个带有 dispatch 参数的函数\nconst action = &#123;\n  getBannerListAction (dispatch) &#123; // 因为此接口不需要参数，所有拥有了默认参数 dispatch\n    getBannerList().then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_BANNER_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n  &#125;,\n  getProListAction (params) &#123; // 组件调用需要传递参数\n    return (dispatch) =&gt; &#123;\n      getProList(params).then(res =&gt; &#123;\n        dispatch(&#123;\n          type: &#39;CHANGE_PRO_LIST&#39;,\n          payload: res.data\n        &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\nexport default action\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/store/actions/kind.js</code></p>\n<pre><code class=\"jsx\">import &#123; getKindList &#125; from &#39;../../api/kind&#39;\n\nconst action = &#123;\n  getKindListAction (dispatch) &#123;\n    getKindList().then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_KIND_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n  &#125;\n&#125;\n\nexport default action \n</code></pre>\n<blockquote>\n<p>记住接口有无参数影响 action 的写法，还影响其调用</p>\n</blockquote>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/views/Home.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\n\nimport action from &#39;../store/actions/home&#39;\nconst Home = connect((state) =&gt; &#123;\n  return &#123;\n    bannerList: state.home.bannerList,\n    proList: state.home.proList\n  &#125;\n&#125;, (dispatch) =&gt; &#123;\n  return &#123;\n    getBannerList () &#123;\n      dispatch(action.getBannerListAction) // 因为没有参数，所以不加()\n    &#125;,\n    getProList () &#123;\n      dispatch(action.getProListAction(&#123; count: 2, limitNum: 3 &#125;))  // 因为有参数，所以加()\n    &#125;\n  &#125;\n&#125;)((&#123; bannerList, proList, getBannerList, getProList &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    getBannerList()\n    getProList()\n  &#125;, [getBannerList, getProList])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;首页&lt;/h1&gt;\n      &lt;ul&gt;\n        &#123;\n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img src = &#123; item.img &#125; key = &#123; item.bannerid &#125; alt=&quot;&quot; style=&#123;&#123; height: 60 &#125;&#125;&gt;&lt;/img&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; (\n            &lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;);\n\nexport default Home;\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/views/Home.jsx</code> 异步在组件</p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\n// import &#123; getBannerList, getProList &#125; from &#39;../api/home&#39;\nimport action from &#39;../store/actions/home&#39; // 异步操作\nconst Home = (&#123; bannerList, proList, getBannerListData, getProListData &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    getBannerListData()\n    getProListData()\n  &#125;, [getBannerListData, getProListData])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;div&gt;\n        &#123; \n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125; src=&#123; item.img &#125; alt=&#123;item.alt&#125; style=&#123;&#123; height: 100 &#125;&#125; /&gt;\n          ))\n        &#125;\n      &lt;/div&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default connect(\n  (&#123; home: &#123; bannerList, proList &#125;&#125;) =&gt; (&#123; bannerList, proList &#125;),\n  (dispatch) =&gt; (&#123;\n    getBannerListData () &#123;\n      // getBannerList().then(res =&gt; &#123;\n      //   dispatch(&#123;\n      //     type: &#39;CHANGE_BANNER_LIST&#39;,\n      //     payload: res.data\n      //   &#125;)\n      // &#125;)\n      // 根据生成的actionCreate 规则去写，午餐不加（）\n      dispatch(action.getBannerListAction)\n      \n    &#125;,\n    getProListData () &#123;\n      // getProList().then(res =&gt; &#123;\n      //   dispatch(&#123;\n      //     type: &#39;CHANGE_PRO_LIST&#39;,\n      //     payload: res.data\n      //   &#125;)\n      // &#125;)\n      dispatch(action.getProListAction(&#123; limitNum: 2 &#125;))\n    &#125;\n  &#125;)\n)(Home);\n</code></pre>\n<p><code>src/16_redux_react-redux_redux-thunk_combine/views/Kind.jsx</code> 异步在store</p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\n// import &#123; getKindList &#125; from &#39;../api/kind&#39;\nimport action from &#39;../store/actions/kind&#39;\nconst Kind = (&#123; kindList, getKindListData &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    getKindListData()\n  &#125;, [getKindListData])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Kind&lt;/h1&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default connect(\n  (&#123; kind: &#123; kindList &#125; &#125;) =&gt; (&#123; kindList &#125;),\n  (dispatch) =&gt; (&#123;\n    getKindListData () &#123;\n      // getKindList().then(res =&gt; &#123;\n      //   dispatch(&#123;\n      //     type: &#39;CHANGE_KIND_LIST&#39;,\n      //     payload: res.data\n      //   &#125;)\n      // &#125;)\n      dispatch(action.getKindListAction)\n    &#125;\n  &#125;)\n)(Kind);\n</code></pre>\n<blockquote>\n<p>虽然引入了redux-thunk，但是仍然可以把 异步放在组件中，具体根据项目的需求而定</p>\n</blockquote>\n<blockquote>\n<p>创建状态模块</p>\n<p>整合模块</p>\n<p>创建异步的 actionCreator</p>\n<p>组件触发 actionCreator</p>\n<p>传递数据以及修改界面</p>\n</blockquote>\n<h3 id=\"18-6-2-redux-saga\"><a href=\"#18-6-2-redux-saga\" class=\"headerlink\" title=\"18.6.2 redux-saga\"></a>18.6.2 redux-saga</h3><blockquote>\n<p>先要了解解决异步操作方案：回调函数、promise、async await、generator yield</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lczYucnVhbnlpZmVuZy5jb20vI2RvY3MvZ2VuZXJhdG9yLWFzeW5j\">https://es6.ruanyifeng.com/#docs/generator-async</span></p>\n<pre><code class=\"sh\">$ cnpm i redux-saga -S\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/store/modules/home.js</code></p>\n<pre><code class=\"jsx\">const reducer =  (state = &#123;\n  bannerList: [],\n  proList: []\n&#125;, &#123; type, payload &#125;) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_BANNER_LIST&#39;:\n      return &#123; ...state, bannerList: payload &#125;\n    case &#39;CHANGE_PRO_LIST&#39;:\n      return &#123; ...state, proList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nexport default reducer\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/store/modules/kind.js</code></p>\n<pre><code class=\"js\">const reducer = (state = &#123;\n  kindList: []\n&#125;, &#123; type, payload &#125;) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;CHANGE_KIND_LIST&#39;:\n      return &#123; ...state, kindList: payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\nexport default reducer\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/api/home.js</code></p>\n<pre><code class=\"js\">export function getBannerList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json())\n&#125;\n\nexport function getProList (params) &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/list?limitNum=&#39; + params.limitNum).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/api/kind.js</code></p>\n<pre><code class=\"js\">export function getKindList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/store/mySaga.js</code></p>\n<pre><code class=\"js\">// put 类似 dispatch put(&#123; type: &#39;&#39;, payload: &#39;&#39;&#125;) 触发状态的修改\n// call 用来调用数据请求   call(getBannerList)  ===&gt;    getBannerList()\n// takeLatest 用来响应触发哪一个异步操作\nimport &#123; put, call, takeLatest &#125; from &#39;redux-saga/effects&#39;\n\nimport &#123; getBannerList, getProList &#125; from &#39;../api/home&#39;\nimport &#123; getKindList &#125; from &#39;../api/kind&#39;\n\n// 异步操作\nfunction * getBannerListAction () &#123;\n  const res = yield call(getBannerList)\n  console.log(&#39;banner&#39;, res.data)\n  // 修改状态\n  yield put(&#123;\n    type: &#39;CHANGE_BANNER_LIST&#39;,\n    payload: res.data\n  &#125;)\n&#125;\n\nfunction * getProListAction (action) &#123;\n  console.log(111, action)\n  const res = yield call(getProList, action.payload)\n  console.log(&#39;pro&#39;, res.data)\n  yield put(&#123;\n    type: &#39;CHANGE_PRO_LIST&#39;,\n    payload: res.data\n  &#125;)\n&#125;\n\nfunction * getKindListAction () &#123;\n  const res = yield call(getKindList)\n  console.log(&#39;kind&#39;, res.data)\n  yield put(&#123;\n    type: &#39;CHANGE_KIND_LIST&#39;,\n    payload: res.data\n  &#125;)\n&#125;\n\n// 定义异步触发的条件\nfunction * mySaga () &#123;\n  // 组件触发 REQUEST_BANNER 即可执行 getBannerListAction 异步行为\n  yield takeLatest(&#39;REQUEST_BANNER&#39;, getBannerListAction)\n  // 组件触发 REQUEST_PRO 即可执行 getProListAction 异步行为\n  yield takeLatest(&#39;REQUEST_PRO&#39;, getProListAction)\n   // 组件触发 REQUEST_KIND 即可执行 getKindListAction 异步行为\n  yield takeLatest(&#39;REQUEST_KIND&#39;, getKindListAction)\n&#125;\n\nexport default mySaga\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/store/index.js</code></p>\n<pre><code class=\"jsx\">import &#123; createStore, combineReducers, applyMiddleware &#125; from &#39;redux&#39;\nimport createSagaMiddleWare from &#39;redux-saga&#39; // 导入生成中间件的函数\n\nimport mySaga from &#39;./mySaga&#39; // 异步行为\n\n// 分模块\nimport home from &#39;./modules/home&#39;\nimport kind from &#39;./modules/kind&#39;\n\nconst reducer = combineReducers(&#123; home, kind &#125;) // 整合reducer\n\nconst middleware = createSagaMiddleWare() // 生成中间件\n\nconst store = createStore(reducer, applyMiddleware(middleware)) // 创建状态管理器\n\nmiddleware.run(mySaga) // 中间件使用异步，放到store创建之后\n\nexport default store\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./17_redux_react-redux_redux-saga_combine/store/index&#39;\nimport App from &#39;./17_redux_react-redux_redux-saga_combine/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/views/Home.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\nconst Home = (&#123; bannerList, proList, dispatch &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    // 触发某个行为，从而触发 异步操作\n    dispatch(&#123; type: &#39;REQUEST_BANNER&#39; &#125;)\n    dispatch(&#123; type: &#39;REQUEST_PRO&#39;, payload: &#123; limitNum: 3 &#125; &#125;)\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;div&gt;\n        &#123; \n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125; src=&#123; item.img &#125; alt=&#123;item.alt&#125; style=&#123;&#123; height: 100 &#125;&#125; /&gt;\n          ))\n        &#125;\n      &lt;/div&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default connect(\n  (&#123; home: &#123; bannerList, proList &#125;&#125;) =&gt; (&#123; bannerList, proList &#125;)\n)(Home);\n</code></pre>\n<p><code>src/17_redux_react-redux_redux-saga_combine/views/Kind.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; connect &#125; from &#39;react-redux&#39;\nconst Kind = (&#123; kindList, getKindListData &#125;) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    getKindListData()\n  &#125;, [getKindListData])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Kind&lt;/h1&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default connect(\n  (&#123; kind: &#123; kindList &#125;&#125;) =&gt; (&#123;kindList&#125;),\n  (dispatch) =&gt; (&#123;\n    getKindListData () &#123;\n      dispatch(&#123; type: &#39;REQUEST_KIND&#39; &#125;)\n    &#125;\n  &#125;)\n)(Kind);\n</code></pre>\n<h2 id=\"18-7-使用immutable不可变数据数据结构\"><a href=\"#18-7-使用immutable不可变数据数据结构\" class=\"headerlink\" title=\"18.7 使用immutable不可变数据数据结构\"></a>18.7 使用immutable不可变数据数据结构</h2><p>immutable不可变的数据解构，意思就是一旦数据被创建，需要使用特殊的方法进行修改（修改过后的数据也是符合immutable数据解构的，他是一个全新的对象）</p>\n<p>学习immutable： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1tdXRhYmxl\">https://www.npmjs.com/package/immutable</span></p>\n<pre><code>$ cnpm i immutable redux-immutable -S\n</code></pre>\n<p>重点就是修改 reducer 的数据机构以及组件中获取状态的方式（整合reducer时使用 redux-immutable 提供的 combineReducers）</p>\n<p>拷贝17文件，修改 store&#x2F;modules&#x2F;home.js    store&#x2F;modules&#x2F;kind.js    store&#x2F;index.js  </p>\n<p>views&#x2F;Home.jsx  views&#x2F;Kind.jsx</p>\n<h1 id=\"十九、redux-toolkit\"><a href=\"#十九、redux-toolkit\" class=\"headerlink\" title=\"十九、redux toolkit\"></a>十九、redux toolkit</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5yZWR1eC5qcy5vcmcv\">https://cn.redux.js.org/</span></p>\n<h2 id=\"19-1-什么是Redux-Toolkit\"><a href=\"#19-1-什么是Redux-Toolkit\" class=\"headerlink\" title=\"19.1 什么是Redux Toolkit\"></a>19.1 什么是Redux Toolkit</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5yZWR1eC5qcy5vcmcvcmVkdXgtdG9vbGtpdC9vdmVydmlldy8=\">https://cn.redux.js.org/redux-toolkit/overview/</span></p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy8=\">Redux Toolkit</span></strong> 是我们官方的，有观点的，开箱即用的高效 Redux 开发工具集。它旨在成为标准的 Redux 逻辑开发方式，我们强烈建议您使用它。</p>\n<p>它包括几个实用程序功能，这些功能可以简化最常见场景下的 Redux 开发，包括配置 store、定义 reducer，不可变的更新逻辑、甚至可以立即创建整个状态的 “切片 slice”，而无需手动编写任何 action creator 或者 action type。它还包括使用最广泛的 Redux 插件，例如 Redux Thunk 用于异步逻辑，而 Reselect 用于编写选择器 selector 函数，因此你可以立即使用它们。</p>\n<h2 id=\"19-2-如何使用redux-toolkit\"><a href=\"#19-2-如何使用redux-toolkit\" class=\"headerlink\" title=\"19.2 如何使用redux-toolkit\"></a>19.2 如何使用redux-toolkit</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL3F1aWNrLXN0YXJ0\">https://cn.redux.js.org/tutorials/quick-start</span></p>\n<pre><code class=\"sh\">$ cnpm i @reduxjs/toolkit redux react-redux redux-devtools -S\n</code></pre>\n<h3 id=\"19-2-1-创建状态管理器\"><a href=\"#19-2-1-创建状态管理器\" class=\"headerlink\" title=\"19.2.1 创建状态管理器\"></a>19.2.1 创建状态管理器</h3><p><code>src/19_rtk/store/index.js</code></p>\n<pre><code class=\"js\">import &#123; configureStore &#125; from &#39;@reduxjs/toolkit&#39;\n\nconst store = configureStore(&#123;\n  reducer: &#123; // 此处可以设置多模块\n\n  &#125;\n&#125;)\n\nexport default store\n</code></pre>\n<h3 id=\"19-2-2-入口文件配置状态管理器\"><a href=\"#19-2-2-入口文件配置状态管理器\" class=\"headerlink\" title=\"19.2.2 入口文件配置状态管理器\"></a>19.2.2 入口文件配置状态管理器</h3><p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./19_rtk/store&#39;\nimport App from &#39;./19_rtk/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<h3 id=\"19-2-3-创建分模块切片\"><a href=\"#19-2-3-创建分模块切片\" class=\"headerlink\" title=\"19.2.3 创建分模块切片\"></a>19.2.3 创建分模块切片</h3><p>创建 slice 需要一个字符串名称来标识切片、一个初始 state 以及一个或多个定义了该如何更新 state 的 reducer 函数。slice 创建后 ，我们可以导出 slice 中生成的 Redux action creators 和 reducer 函数。</p>\n<p><code>src/19_rtk/store/modules/home.js</code></p>\n<pre><code class=\"js\">import &#123; createSlice &#125; from &#39;@reduxjs/toolkit&#39;\n// 创建 slice 需要一个字符串名称来标识切片、一个初始 state 以及一个或多个定义了该如何更新 state 的 reducer 函数。\n// slice 创建后 ，我们可以导出 slice 中生成的 Redux action creators 和 reducer 函数。\nexport const homeSlice = createSlice(&#123;\n  name: &#39;home&#39;, // vuex namespaced: true\n  initialState: &#123; // vuex state\n    bannerList: [],\n    proList: []\n  &#125;,\n  reducers: &#123; // vuex mutations\n    changeBannerList (state, action) &#123;\n      state.bannerList = action.payload\n    &#125;,\n    changeProList (state, action) &#123;\n      state.proList = action.payload\n    &#125;\n  &#125;\n&#125;)\nconsole.log(&#39;home&#39;, homeSlice)\n// 每个 case reducer 函数会生成对应的 Action creators\nexport const &#123; changeBannerList, changeProList &#125; = homeSlice.actions\n\nexport default homeSlice.reducer // redux时 管理状态都是 reducer\n</code></pre>\n<p><code>src/19_rtk/store/modules/kind.js</code></p>\n<pre><code class=\"js\">import &#123; createSlice &#125; from &#39;@reduxjs/toolkit&#39;\n\nexport const kindSlice = createSlice(&#123;\n  name: &#39;kind&#39;,\n  initialState: &#123;\n    kindList: []\n  &#125;,\n  reducers: &#123;\n    changeKindList (state, action) &#123;\n      state.kindList = action.payload\n    &#125;\n  &#125;\n&#125;)\n\nexport const &#123; changeKindList &#125; = kindSlice.actions\n\nexport default kindSlice.reducer\n</code></pre>\n<h3 id=\"19-2-4-整合切片\"><a href=\"#19-2-4-整合切片\" class=\"headerlink\" title=\"19.2.4 整合切片\"></a>19.2.4 <strong>整合切片</strong></h3><p><code>src/19_rtk/store/index.js</code></p>\n<pre><code class=\"js\">import &#123; configureStore &#125; from &#39;@reduxjs/toolkit&#39;\nimport home from &#39;./modules/home&#39;\nimport kind from &#39;./modules/kind&#39;\nconst store = configureStore(&#123;\n  reducer: &#123; // 所有的模块都可以配置到此\n    home, kind\n  &#125;\n&#125;)\n\nexport default store\n</code></pre>\n<h3 id=\"19-2-5-组件中使用状态管理器\"><a href=\"#19-2-5-组件中使用状态管理器\" class=\"headerlink\" title=\"19.2.5 组件中使用状态管理器\"></a>19.2.5 组件中使用状态管理器</h3><p><code>src/19_rtk/views/Home.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\n// useSelector 用来获取状态管理器的状态\n// useDispatch 用来修改状态\nimport &#123; useSelector, useDispatch &#125; from &#39;react-redux&#39;\n\nimport &#123; changeBannerList, changeProList &#125; from &#39;./../store/modules/home&#39;\nimport &#123; getBannerList, getProList  &#125; from &#39;../api/home&#39;\nconst Home = () =&gt; &#123;\n  const bannerList = useSelector(state =&gt; state.home.bannerList)\n  const proList = useSelector(state =&gt; state.home.proList)\n  const dispatch = useDispatch()\n  useEffect(() =&gt; &#123;\n    getBannerList().then(res =&gt; &#123; \n      dispatch(changeBannerList(res.data))\n    &#125;)\n    getProList(&#123; limitNum: 5 &#125;).then(res =&gt; &#123; \n      dispatch(changeProList(res.data))\n    &#125;)\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;div&gt;\n        &#123; \n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125; src=&#123; item.img &#125; alt=&#123;item.alt&#125; style=&#123;&#123; height: 100 &#125;&#125; /&gt;\n          ))\n        &#125;\n      &lt;/div&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Home;\n</code></pre>\n<p><code>src/19_rtk/views/Kind.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useDispatch, useSelector &#125; from &#39;react-redux&#39;\nimport &#123; getKindList &#125; from &#39;../api/kind&#39;\nimport &#123; changeKindList &#125; from &#39;../store/modules/kind&#39;\nconst Kind = () =&gt; &#123;\n  const kindList = useSelector(state =&gt; state.kind.kindList)\n\n  const dispatch = useDispatch()\n\n  useEffect(() =&gt; &#123;\n    getKindList().then(res =&gt; &#123;\n      dispatch(changeKindList(res.data))\n    &#125;)\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Kind&lt;/h1&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Kind;\n</code></pre>\n<blockquote>\n<ul>\n<li><p>使用<code>configureStore</code>创建 Redux store</p>\n<ul>\n<li><code>configureStore</code> 接受 <code>reducer</code> 函数作为命名参数</li>\n<li><code>configureStore</code> 使用的好用的默认设置自动设置 store</li>\n</ul>\n</li>\n<li><p>为 React 应用程序组件提供 Redux store</p>\n<ul>\n<li>使用 React-Redux <code>&lt;Provider&gt;</code> 组件包裹你的 <code>&lt;App /&gt;</code></li>\n<li>传递 Redux store 如 <code>&lt;Provider store=&#123;store&#125;&gt;</code></li>\n</ul>\n</li>\n<li><p>使用 <code>createSlice</code> 创建 Redux “slice” reducer</p>\n<ul>\n<li><p>使用字符串名称、初始状态和命名的 reducers 函数调用“createSlice”</p>\n</li>\n<li><p>Reducer 函数可以使用 Immer 来“改变”状态</p>\n</li>\n<li><p>导出生成的 slice reducer 和 action creators</p>\n</li>\n</ul>\n</li>\n<li><p>在 React 组件中使用 React-Redux <code>useSelector/useDispatch</code> 钩子</p>\n<ul>\n<li><p>使用 <code>useSelector</code> 钩子从 store 中读取数据</p>\n</li>\n<li><p>使用 <code>useDispatch</code> 钩子获取 <code>dispatch</code> 函数，并根据需要 dispatch actions</p>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>此时发现，组件中的异步操作在 组件内部调用，接下来需要研究如何将异步操作从组件提取出来</p>\n</blockquote>\n<h2 id=\"19-3-提取异步操作\"><a href=\"#19-3-提取异步操作\" class=\"headerlink\" title=\"19.3 提取异步操作\"></a>19.3 提取异步操作</h2><h3 id=\"19-3-1-自己定义请求函数\"><a href=\"#19-3-1-自己定义请求函数\" class=\"headerlink\" title=\"19.3.1 自己定义请求函数\"></a>19.3.1 自己定义请求函数</h3><p><code>src/20_rtk_async/api/home.js</code></p>\n<pre><code class=\"js\">export function getBannerList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json())\n&#125;\n\nexport function getProList (params) &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/list?limitNum=&#39; + params.limitNum).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/20_rtk_async/api/kind.js</code></p>\n<pre><code class=\"js\">export function getKindList () &#123;\n  return fetch(&#39;http://121.89.205.189:3001/api/pro/categorylist&#39;).then(res =&gt; res.json())\n&#125;\n</code></pre>\n<p><code>src/20_rtk_async/store/modules/home.js</code></p>\n<pre><code class=\"js\">import &#123; createSlice &#125; from &#39;@reduxjs/toolkit&#39;\nimport &#123; getBannerList, getProList &#125; from &#39;../../api/home&#39;\nexport const homeSlice = createSlice(&#123; // 主要定义模块，后期从模块中取值给组件以及整合状态管理器\n  name: &#39;home&#39;, // 模块名称\n  initialState: &#123; // 模块代表的初始化状态\n    bannerList: [],\n    proList: []\n  &#125;,\n  reducers: &#123; // 修改状态\n    changeBannerList (state, action) &#123;\n      state.bannerList = action.payload\n    &#125;,\n    changeProList (state, action) &#123;\n      state.proList = action.payload\n    &#125;\n  &#125;\n&#125;)\n// 取得数据之后，只需要 dispatch 触发此函数即可，参数即为修改时用的action的值\nexport const &#123; changeBannerList, changeProList &#125; = homeSlice.actions\n// 如果异步操作在状态管理器，写如下代码，参照 redux-thunk 写法\nexport function getBannerListAction (dispatch) &#123; // dispatch 为默认参数\n  getBannerList().then(res =&gt; &#123;\n    dispatch(changeBannerList(res.data))\n  &#125;)\n&#125;\nexport function getProListAction (params) &#123;\n  return (dispatch) =&gt; &#123; // dispatch 为默认参数\n    getProList(params).then(res =&gt; &#123;\n      dispatch(changeProList(res.data))\n    &#125;)\n  &#125;\n&#125;\nexport default homeSlice.reducer\n</code></pre>\n<p><code>src/20_rtk_async/store/index.js</code></p>\n<pre><code class=\"js\">import &#123; configureStore &#125; from &#39;@reduxjs/toolkit&#39;\nimport home from &#39;./modules/home&#39;\n\nconst store = configureStore(&#123;\n  reducer: &#123;\n    home\n  &#125;\n&#125;)\n\nexport default store\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n// 引入状态管理器\nimport &#123; Provider &#125; from &#39;react-redux&#39; // 提供Provier组件，可以添加store属性\nimport store from &#39;./20_rtk_async/store&#39;\nimport App from &#39;./20_rtk_async/App&#39;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;Provider store = &#123; store &#125;&gt;\n    &lt;App/&gt;\n  &lt;/Provider&gt;\n)\n</code></pre>\n<p><code>src/20_rtk_async/App.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport Home from &#39;./views/Home&#39;;\nimport Kind from &#39;./views/Kind&#39;;\n\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;Home /&gt;\n      &lt;hr /&gt;\n      &lt;Kind /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/20_rtk_async/views/Home.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useDispatch, useSelector &#125; from &#39;react-redux&#39;\nimport &#123; getBannerListAction, getProListAction &#125; from &#39;../store/modules/home&#39;\n\nconst Home = () =&gt; &#123;\n  const bannerList = useSelector(state =&gt; state.home.bannerList)\n  const proList = useSelector(state =&gt; state.home.proList)\n\n  const dispatch = useDispatch()\n\n  useEffect(() =&gt; &#123;\n    dispatch(getBannerListAction) // 无参不加（）\n    dispatch(getProListAction(&#123; limitNum: 8 &#125;)) // 有参加（）\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home20&lt;/h1&gt;\n      &lt;div&gt;\n        &#123; \n          bannerList &amp;&amp; bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125; src=&#123; item.img &#125; alt=&#123;item.alt&#125; style=&#123;&#123; height: 100 &#125;&#125; /&gt;\n          ))\n        &#125;\n      &lt;/div&gt;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; &#123;\n            return (&lt;li key = &#123; item.proid &#125;&gt;&#123; item.proname &#125;&lt;/li&gt;)\n          &#125;)\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Home;\n</code></pre>\n<h3 id=\"19-3-2-使用-createAsyncThunk-请求数据\"><a href=\"#19-3-2-使用-createAsyncThunk-请求数据\" class=\"headerlink\" title=\"19.3.2 使用 createAsyncThunk 请求数据\"></a>19.3.2 使用 <code>createAsyncThunk</code> 请求数据</h3><p>Redux Toolkit 的 <code>createAsyncThunk</code> API 生成 thunk，为您自动 dispatch 那些 “start&#x2F;success&#x2F;failure” action。</p>\n<p><code>src/20_rtk_async/store/modules/kind.js</code></p>\n<pre><code class=\"js\">import &#123; createSlice, createAsyncThunk &#125; from &#39;@reduxjs/toolkit&#39;\nimport &#123; getKindList &#125; from &#39;./../../api//kind&#39;\nexport const kindSlice = createSlice(&#123;\n  name: &#39;kind&#39;,\n  initialState: &#123;\n    kindList: []\n  &#125;,\n  reducers: &#123;\n    changeKindList (state, action) &#123; // 如果使用了 createAsyncThunk 此处修改状态失效\n      state.kindList = action.payload\n    &#125;\n  &#125;,\n  extraReducers: (builder) =&gt; &#123; // createAsyncThunk 在这里修改状态 下面可以看作固定的写法\n    builder\n      .addCase(getKindListAction.pending, state =&gt; &#123;\n        state.status = &#39;loading&#39;\n      &#125;)\n      .addCase(getKindListAction.fulfilled, (state, action) =&gt; &#123;\n        state.status = &#39;idle&#39;\n        state.kindList = action.payload\n      &#125;)\n      .addCase(getKindListAction.rejected, state =&gt; &#123;\n        state.status = &#39;failed&#39;\n      &#125;)\n      \n    &#125;\n&#125;)\n\n// kind/getKindListAction1123 可以自定义，但是最好有意义\nexport const getKindListAction = createAsyncThunk(&#39;kind/getKindListAction1123&#39;, async (num) =&gt; &#123;\n  console.log(&#39;num&#39;, num)\n  const res = await getKindList()\n  return res.data\n&#125;)\n\nexport const &#123; changeKindList &#125; = kindSlice.actions\n\nexport default kindSlice.reducer\n</code></pre>\n<p><code>src/20_rtk_async/views/Kind.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useDispatch, useSelector &#125; from &#39;react-redux&#39;\nimport &#123; getKindListAction &#125; from &#39;../store/modules/kind&#39;\nconst Kind = () =&gt; &#123;\n  const kindList = useSelector(state =&gt; state.kind.kindList)\n  const dispatch = useDispatch()\n  useEffect(() =&gt; &#123;\n    dispatch(getKindListAction(1000000))\n  &#125;, [dispatch])\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Kind20&lt;/h1&gt;\n      &#123;\n        kindList &amp;&amp; kindList.map(item =&gt; &#123;\n          return (\n            &lt;p key = &#123; item &#125;&gt; &#123; item &#125; &lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Kind;\n</code></pre>\n",
            "tags": [
                "react学习",
                "react"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/react-study/7/",
            "url": "https://www.yexingcheng.com/react-study/7/",
            "title": "React学习第七天",
            "date_published": "2022-08-06T16:00:00.000Z",
            "content_html": "<h1 id=\"十七、hooks\"><a href=\"#十七、hooks\" class=\"headerlink\" title=\"十七、hooks\"></a>十七、hooks</h1><h2 id=\"17-1-为什么使用hooks\"><a href=\"#17-1-为什么使用hooks\" class=\"headerlink\" title=\"17.1 为什么使用hooks\"></a>17.1 为什么使用hooks</h2><p>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 React 一段时间，你也许会熟悉一些解决此类问题的方案，比如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvcmVuZGVyLXByb3BzLmh0bWw=\">render props</span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaGlnaGVyLW9yZGVyLWNvbXBvbmVudHMuaHRtbA==\">高阶组件</span>。</p>\n<p><strong>Hook 使你在非 class 的情况下可以使用更多的 React 特性。</strong> 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。</p>\n<p><strong>react 18版本以前hooks</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYmFzaWMtaG9va3M=\">基础 Hook</span><ul>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#usestate\"><code>useState</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#useeffect\"><code>useEffect</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#usecontext\"><code>useContext</code></a></li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjYWRkaXRpb25hbC1ob29rcw==\">额外的 Hook</span><ul>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#usereducer\"><code>useReducer</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#usecallback\"><code>useCallback</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#usememo\"><code>useMemo</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#useref\"><code>useRef</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#useimperativehandle\"><code>useImperativeHandle</code></a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-reference.html#uselayouteffect\"><code>useLayoutEffect</code></a></li>\n<li><code>useDebugValue</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"17-2常见的hooks\"><a href=\"#17-2常见的hooks\" class=\"headerlink\" title=\"17.2常见的hooks\"></a>17.2常见的hooks</h2><h3 id=\"17-2-1-useState\"><a href=\"#17-2-1-useState\" class=\"headerlink\" title=\"17.2.1 useState\"></a>17.2.1 useState</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/01_App_hooks_useState&#39; // hooks useState\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App /&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/01_App_hooks_useState.jsx</code></p>\n<pre><code class=\"jsx\">// rsc\nimport React from &#39;react&#39;;\nimport &#123; useState &#125; from &#39;react&#39;;\n\n// 函数式组件内不要使用this\n// 如果想要 this 指向函数式组件，本身这个想法就是错误的\nconst App = () =&gt; &#123;\n  // 定义了一个初始化状态 为count\n  // 定义了一个修改初始化状态的函数 为 setCount\n  // 使用 useState 定义了初始化装 count 的值为 1\n  const [count, setCount] = useState(1)\n\n  const [name, setName] = useState(&#39;吴&#39;)\n\n  function add100 () &#123;\n    setCount(count + 100)\n  &#125;\n\n  const add1000 = () =&gt; &#123;\n    setCount(count + 1000)\n  &#125;\n\n  const add10000 = () =&gt; &#123;\n    setCount(prevCount =&gt; &#123; // 函数写法\n      console.log(prevCount) \n      return prevCount + 10000\n    &#125;)\n  &#125;\n  return (\n    &lt;div&gt;\n      &#123; count &#125;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        // 修改函数内部的值为 运算之后的结果\n        setCount(count + 1)\n      &#125; &#125;&gt;加1&lt;/button&gt;\n      &lt;button onClick=&#123; function () &#123;\n        // 修改函数内部的值为 运算之后的结果\n        setCount(count + 10)\n      &#125; &#125;&gt;加10&lt;/button&gt;\n\n      &lt;button onClick=&#123; add100 &#125;&gt;加100&lt;/button&gt;\n      &lt;button onClick=&#123; add1000 &#125;&gt;加1000&lt;/button&gt;\n      &lt;button onClick=&#123; add10000 &#125;&gt;加10000&lt;/button&gt;\n      &#123; name &#125;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        setName(&#39;吴大勋&#39;)\n      &#125; &#125;&gt;修改name&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/02_App_hooks_useState_obj&#39; // hooks useState  object\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App /&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/02_App_hooks_useState_obj.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useState &#125; from &#39;react&#39;;\n\nconst App = () =&gt; &#123;\n  const [obj, setObj] = useState(&#123;\n    w: 100,\n    h: 100,\n    x: 0,\n    y: 0\n  &#125;)\n\n  const mouseMove = (event) =&gt; &#123;\n    // 鼠标移动，发现 w 和 h 的数据丢失, &#123; x: 1, y: 1&#125; 代替了原来的对象 obj \n    // setObj(&#123;\n    //   x: event.clientX,\n    //   y: event.clientY\n    // &#125;)\n\n    // setObj(&#123; // 合并新数据到原来的 obj\n    //   ...obj,\n    //   x: event.clientX,\n    //   y: event.clientY\n    // &#125;)\n\n    setObj(prevObj =&gt; &#123;\n      // return &#123;\n      //   w: prevObj.w,\n      //   h: prevObj.h,\n      //   x: event.clientX,\n      //   y: event.clientY\n      // &#125;\n      return Object.assign(&#123;&#125;, prevObj, &#123; x: event.clientX &#125;, &#123; y: event.clientY&#125;)\n    &#125;)\n  &#125;\n\n  return (\n    &lt;div style=&#123; &#123; width: &#39;100vw&#39;, height: &#39;100vh&#39; &#125; &#125; onMouseMove = &#123; mouseMove &#125;&gt;\n      &lt;div&gt;元素的宽为: &#123; obj.w &#125;，元素的高为： &#123; obj.h &#125;&lt;/div&gt;\n      &lt;div&gt;元素的坐标点为： (&#123; obj.x &#125;,&#123;  obj.y&#125;)&lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/03_App_hooks_useState_state&#39; // hooks useState  拆分对象状态\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App /&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/03_App_hooks_useState_state.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useState &#125; from &#39;react&#39;;\n\nconst App = () =&gt; &#123;\n\n  // 如果不需要修改状态，那么可以不写解构的第二个值\n  const [ box ] = useState(&#123; w: 100, h: 100 &#125;)\n  const [position, setPosition] = useState(&#123; x: 0, y: 0 &#125;)\n\n  const mouseMove = (event) =&gt; &#123;\n    setPosition(&#123;\n      x: event.clientX,\n      y: event.clientY\n    &#125;)\n  &#125;\n\n  return (\n    &lt;div style=&#123; &#123; width: &#39;100vw&#39;, height: &#39;100vh&#39; &#125; &#125; onMouseMove = &#123; mouseMove &#125;&gt;\n      &lt;div&gt;元素的宽为: &#123; box.w &#125;，元素的高为： &#123; box.h &#125;&lt;/div&gt;\n      &lt;div&gt;元素的坐标点为： (&#123; position.x &#125;,&#123;  position.y&#125;)&lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<ul>\n<li><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。</p>\n</li>\n<li><p><strong>只在 React 函数中调用 Hook，</strong>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>\n<ul>\n<li>在 React 的函数组件中调用 Hook</li>\n<li>在自定义 Hook 中调用其他 Hook</li>\n</ul>\n</li>\n<li><p>如果遇到需要以对象的形式定义状态时，根据需求划分对象，因为修改状态使用的是替换</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"17-2-2-useEffect\"><a href=\"#17-2-2-useEffect\" class=\"headerlink\" title=\"17.2.2 useEffect\"></a>17.2.2 useEffect</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./12_hooks/04_App_hooks_useEffect&#39; // hooks useEffect  \n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App root=&#123;root&#125;/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/04_App_hooks_useEffect.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;\n\nconst App = (props) =&gt; &#123;\n  const [proList, setProList] = useState([])\n\n  const [count, setCount] = useState(1)\n  // 数据请求 --- 函数式组件没有 生命周期钩子函数\n  // useEffect 的第一个参数是一个回调函数 类似于类组件中的 componentDidMount 以及 componentDidUpdate\n  // useEffect 内的代码会自动执行\n  // useEffect 如果没有添加第二个依赖的参数，那么只要内部修改果状态，此部分代码就会一直执行\n  // useEffect(() =&gt; &#123;\n  //   fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n  //     console.log(res.data) // 第一次打印 - componentDidMount\n  //     setProList(res.data) // 发现上一句话一直在打印 - componentDidUpdate 且没有条件限制\n  //   &#125;)\n  // &#125;)\n\n  // 可以给useEffect添加第二个参数进行控制内部代码执行的次数\n  // useEffect(() =&gt; &#123;\n  //   fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n  //     console.log(res.data) \n  //     setProList(res.data) \n  //   &#125;)\n  // &#125;, []) // useEffect 第二个参数为空数组，代表useEffect 内部只会执行类似 componentDidMount 的操作\n  \n  // 依赖值发生改变，再次触发代码执行，类似于componentDidUpdate中特定条件下请求数据\n  useEffect(() =&gt; &#123;\n    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      console.log(res.data) \n      setProList(res.data) \n    &#125;)\n  &#125;, [count]) // 第二个参数写入值，代表只有当count的值发生改变时，才会再次触发useEffect，再次执行\n\n\n  // 如何模拟 组件的销毁呢？\n  // 在useEffect内部的回调函数中 返回一个函数\n  useEffect(() =&gt; &#123;\n\n    // 为防止内存泄漏，清除函数会在组件卸载前执行。\n    // 另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。\n    return () =&gt; &#123; // 类似于类组件中的componentWillUnmount\n      // 取消订阅的操作，销毁定时器，计时器等操作\n      console.log(&#39;组件销毁了&#39;)\n    &#125;\n  &#125;, [count])\n  return (\n    &lt;div&gt;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        setCount(count + 1)\n        if (count === 5) &#123;\n          props.root.unmount()\n        &#125;\n      &#125;&#125;&gt;加1&lt;/button&gt; &#123; count &#125;\n      &lt;ul&gt;\n        &#123;\n          proList &amp;&amp; proList.map(item =&gt; (\n            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<ol>\n<li>useEffect() 是个副作用函数。</li>\n<li>useEffect() 函数在每次组件重新渲染时，可再次被调用。</li>\n<li>在开发环境中，开启了 React.StrictMode 模式，组件开始时被渲染两次。</li>\n<li>useEffect() 通过返回函数来清理副作用。</li>\n<li>useEffect() 通过传递第二个参数数组来提高渲染性能，或者说实现 watch 效果。</li>\n</ol>\n</blockquote>\n<h3 id=\"17-2-3-useRef\"><a href=\"#17-2-3-useRef\" class=\"headerlink\" title=\"17.2.3 useRef\"></a>17.2.3 useRef</h3><p>利用 <code>useRef</code> 就可以绕过 Capture Value 的特性。<strong>可以认为</strong> <code>ref</code> <strong>在所有 Render 过程中保持着唯一引用，因此所有对</strong> <code>ref</code> <strong>的赋值或取值，拿到的都只有一个最终状态</strong>，而不会在每个 Render 间存在隔离。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/05_App_hooks_useRef&#39; // hooks useRef  \n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/05_App_hooks_useRef.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useRef &#125; from &#39;react&#39;;\n\nconst FunCom = React.forwardRef((props, ref) =&gt; &#123;\n  return (\n    &lt;div ref = &#123; ref &#125;&gt;函数式组件&lt;/div&gt;\n  )\n&#125;)\n\nclass Com extends React.Component &#123;\n  state = &#123; name: &#39;类组件&#39; &#125;\n  testFn = () =&gt; &#123;\n    console.log(this.state.name + &#39;!!&#39;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;类组件&lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst App = () =&gt; &#123;\n  const btnRef = useRef() // 类组件中  React.createRef()\n  const comRef = useRef()\n  const funRef = useRef()\n  useEffect(() =&gt; &#123;\n    console.log(btnRef.current)\n    console.log(comRef.current)\n    console.log(funRef.current)\n  &#125;, [])\n\n  return (\n    &lt;div&gt;\n      &lt;button ref = &#123; btnRef &#125;&gt;按钮ref&lt;/button&gt;\n      &lt;Com ref = &#123; comRef &#125;/&gt;\n      &lt;FunCom ref = &#123; funRef &#125;/&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<h3 id=\"17-2-4-useReducer\"><a href=\"#17-2-4-useReducer\" class=\"headerlink\" title=\"17.2.4 useReducer\"></a>17.2.4 useReducer</h3><p>useReducer 践行了 Flux&#x2F;Redux 思想。使用步骤：</p>\n<p>1、创建初始值initialState</p>\n<p>2、创建所有操作 reducer(state, action);</p>\n<p>3、传给 userReducer，得到读和写API</p>\n<p>4、调用写 ({type: ‘操作类型’})</p>\n<p>总的来说，useReducer 是 useState 的复杂版。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/06_App_hooks_useReducer&#39; // hooks useReducer  \n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/06_App_hooks_useReducer.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useReducer &#125; from &#39;react&#39;;\n// 1.创建初始化状态\nconst initialState = &#123;\n  bannerList: [],\n  proList: []\n&#125;\n\n// 2.创建所有操作 reducer(state, action)\nconst reducer = (state, action) =&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;CHANGE_BANNER_LIST&#39;:\n      // 返回一个新的状态 -- 当触发修改轮播图数据时，得到一个新的数据\n      // 如何保证得到一份新的数据  -- 推荐使用 对象的合并\n      // return &#123; ...state, bannerList: action.payload &#125;\n      return Object.assign(&#123;&#125;, state, &#123; bannerList: action.payload &#125;)\n    case &#39;CHANGE_PRO_LIST&#39;:\n      return &#123; ...state, proList: action.payload &#125;\n    default:\n      return state\n  &#125;\n&#125;\n\nconst App = () =&gt; &#123;\n  // 3.传给 userReducer，得到读和写API\n  // state代表所有的数据\n  // dispatch可以触发reducer的改变\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  useEffect(() =&gt; &#123;\n    fetch(&#39;http://121.89.205.189:3001/api/banner/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_BANNER_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      dispatch(&#123;\n        type: &#39;CHANGE_PRO_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;)\n  &#125;, [])\n  return (\n    &lt;div&gt;\n       &#123;\n          state.bannerList &amp;&amp; state.bannerList.map(item =&gt; (\n            &lt;img key = &#123; item.bannerid &#125;  alt=&#123; item.alt &#125; src = &#123; item.img &#125; style=&#123;&#123; height: 100 &#125;&#125;/&gt;\n          ))\n        &#125;\n\n      &lt;ul&gt;\n        &#123;\n          state.proList &amp;&amp; state.proList.map(item =&gt; (\n            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>如果遇到多个组件需要共享状态时，单纯useReducer就显得无能为力</p>\n</blockquote>\n<h3 id=\"17-2-5-useContext\"><a href=\"#17-2-5-useContext\" class=\"headerlink\" title=\"17.2.5 useContext\"></a>17.2.5 useContext</h3><p>1、使用 C &#x3D; createContext(initial) 创建上下文</p>\n<p>2、使用 &lt;C.Provider&gt; 圈定作用域</p>\n<p>3、在作用域内使用 useContext(C)来使用上下文</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/07_App_hooks_useContext&#39; // hooks useContext  \n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/07_App_hooks_useContext.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useContext &#125; from &#39;react&#39;;\nconst LangContext = React.createContext()\nconst ColorContext = React.createContext()\nconst Second = () =&gt; &#123;\n  const lang = useContext(LangContext)\n  const color = useContext(ColorContext)\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Second&lt;/h1&gt;\n      &#123; lang &#125; - &#123; color &#125;\n    &lt;/&gt;\n  )\n&#125;\n\nconst First = () =&gt; &#123;\n  return (\n    &lt;&gt;\n      &lt;h1&gt;first&lt;/h1&gt;\n      &lt;Second /&gt;\n    &lt;/&gt;\n  )\n&#125;\nconst App = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;LangContext.Provider value = &quot;中文&quot;&gt;\n        &lt;ColorContext.Provider value = &quot;red&quot;&gt;\n          &lt;First /&gt;\n        &lt;/ColorContext.Provider&gt;\n      &lt;/LangContext.Provider&gt;\n      \n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p> <strong>使用 useReducer 和 useContext 实现轻型Redux,可以让组件间共享状态</strong></p>\n<p>步骤：</p>\n<p>1、将数据集中在一个 store 对象</p>\n<p>2、将所有操作集中在 reducer</p>\n<p>3、创建一个 Context</p>\n<p>4、创建对数据的读取 API</p>\n<p>5、将第四步的内容放到第三步的 Context</p>\n<p>6、用 Context.Provider 将 Context 提供给所有组件</p>\n<p>7、各个组件用 useContext 获取读写API</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/08_App_hooks_redux&#39; // hooks useContext useReducer redux\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/09-App-redux.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useContext &#125; from &#39;react&#39;;\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useReducer &#125; from &#39;react&#39;;\n\nconst MyContext = React.createContext()\nconst intitalState = &#123;\n  userName: &#39;吴大勋&#39;,\n  count: 100,\n  proList: []\n&#125;\n\nconst reducer = (state, action) =&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;CHANGE_USER_NAME&#39;:\n      return &#123; ...state, userName: action.payload &#125;\n    case &#39;CHANGE_COUNT&#39;: \n      return &#123; ...state, count: action.payload&#125;\n    case &#39;CHANGE_PRO_LIST&#39;: \n      return &#123; ...state, proList: action.payload&#125;\n    default:\n      return state\n  &#125;\n&#125;\n\n\nconst Home = () =&gt; &#123;\n  // const [state, dispatch] = useReducer(reducer, intitalState)\n  const &#123; state, dispatch &#125;  = useContext(MyContext)\n  useEffect(() =&gt; &#123; // 不要直接在回调函数上使用async\n    const fetchData = async () =&gt; &#123;\n      const res = await  fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json())\n      dispatch(&#123;\n        type: &#39;CHANGE_PRO_LIST&#39;,\n        payload: res.data\n      &#125;)\n    &#125;\n    fetchData()\n\n  &#125;, [dispatch])\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;ul&gt;\n        &#123;\n          state.proList &amp;&amp; state.proList.map(item =&gt; (\n            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n    &lt;/&gt;\n  )\n&#125;\nconst List = () =&gt; &#123;\n  // const [state, dispatch] = useReducer(reducer, intitalState)\n  const &#123; state &#125;  = useContext(MyContext)\n  return (\n    &lt;&gt;\n      &lt;h1&gt;List&lt;/h1&gt;\n      &lt;ul&gt;\n        &#123;\n          state.proList &amp;&amp; state.proList.map(item =&gt; (\n            &lt;li key = &#123; item.proid &#125;&gt; &#123; item.proname &#125; &lt;/li&gt;\n          ))\n        &#125;\n      &lt;/ul&gt;\n    &lt;/&gt;\n  )\n&#125;\n\n// Home 组件  以及 List 组件共享 列表数据\nconst App = () =&gt; &#123;\n  const [state, dispatch] = useReducer(reducer, intitalState)\n  return (\n    &lt;div&gt;\n      &lt;MyContext.Provider value = &#123; &#123;\n        state,\n        dispatch\n      &#125;&#125; &gt;\n        &lt;Home /&gt;\n        &lt;List /&gt;\n      &lt;/MyContext.Provider&gt;\n      \n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>useContext + useReducer 可以实现轻型redux，但是不适合应用于多模块管理的大型项目</p>\n</blockquote>\n<h3 id=\"17-2-6-useMemo\"><a href=\"#17-2-6-useMemo\" class=\"headerlink\" title=\"17.2.6 useMemo\"></a>17.2.6 useMemo</h3><h3 id=\"17-2-7-useCallback\"><a href=\"#17-2-7-useCallback\" class=\"headerlink\" title=\"17.2.7 useCallback\"></a>17.2.7 useCallback</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/09_App_hooks_useCallback_useMemo&#39; // hooks useCallback useMemo 提升性能以及计算属性\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/09_App_hooks_useCallback_useMemo.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport &#123; useMemo &#125; from &#39;react&#39;;\nimport &#123; useCallback &#125; from &#39;react&#39;;\nimport &#123; useState &#125; from &#39;react&#39;;\n\n// const Child = (props) =&gt; &#123;\n//   console.log(&#39;child被执行了&#39;)\n//   return (\n//     &lt;div&gt;child - &#123; props.b &#125;&lt;/div&gt;\n//   )\n// &#125;\nconst Child = React.memo((props) =&gt; &#123;\n  console.log(&#39;child被执行了&#39;)\n  return (\n    &lt;div&gt;child - &#123; props.b &#125;&lt;/div&gt;\n  )\n&#125;)\n\nconst Com = React.memo((props) =&gt; &#123;\n  console.log(&#39;com被执行了&#39;)\n  return (\n    &lt;div&gt;com - &#123; props.b &#125;&lt;/div&gt;\n  )\n&#125;)\n\nconst App = () =&gt; &#123;\n  const [a, setA] = useState(0)\n  // const [b] = useState(100)\n  const [b, setB] = useState(100)\n\n  const [list, setList] = useState([1, 2, 3, 4, 5])\n\n  const add = () =&gt; &#123;\n    setA(a + 1)\n  &#125;\n\n  const addB = () =&gt; &#123;\n    setB(b + 1)\n  &#125;\n\n  // 每次更新生成一个新的引用，意味这属性发生改变\n  // const testFn = () =&gt; &#123;&#125;\n  // 如果记住这个函数 useCallback 以及 useMemo ，从而达到提升组件性能的目的\n  // const testFn = useCallback(() =&gt; &#123; // useCallback结构\n  //   return (event) =&gt; &#123; // 真正的函数实现\n  //   &#125;\n  // &#125;, []) // 依赖值的改变，重新生成新的引用\n  const testFn = useMemo((event) =&gt; &#123; // 真正的函数\n  &#125;, [])\n\n  // 函数式组件中，通常使用useMemo可以实现计算属性\n  // const doubleA = a * 2 // 不推荐\n  const doubleA = useMemo(() =&gt; &#123;\n    return a * 2\n  &#125;, [a])\n\n  const len = useMemo(() =&gt; &#123;\n    return list.length\n  &#125;, [list])\n  return (\n    &lt;div&gt;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        const arr = JSON.parse(JSON.stringify(list)) // 深拷贝\n        arr.push(len+1)\n        setList(arr)\n      &#125;&#125;&gt;追加数据&lt;/button&gt;&#123;list&#125;\n      &lt;button onClick=&#123; add &#125;&gt;a加1&lt;/button&gt; &#123; a &#125; - &#123; doubleA &#125; - &#123; len &#125;\n      &lt;button onClick=&#123; addB &#125;&gt;b加1&lt;/button&gt; &#123; b &#125;\n      &#123;/* 理想情况 b的值发生改变，Child 组件才被重新渲染 */&#125;\n      &#123;/* 可以使用高阶组件 React.memo() 包裹一下Child组件 */&#125;\n      &lt;Child b=&#123; b &#125;/&gt;\n\n      &#123;/* 组件的状态发生改变，组件重新渲染，重新渲染，就会给函数生成一个新的地址，意味着全新的一个属性 */&#125;\n      &lt;Com b = &#123; b &#125; testFn = &#123; testFn &#125;/&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>useCallback 应用于 组件的事件，使用useCallback 包裹组件   -  记忆函数</p>\n<p>useMemo 可以是计算属性， 也应用于 组件的事件，使用useMemo  包裹组件  - 记忆组件</p>\n</blockquote>\n<h3 id=\"17-2-8-useImperativeHandle\"><a href=\"#17-2-8-useImperativeHandle\" class=\"headerlink\" title=\"17.2.8 useImperativeHandle\"></a>17.2.8 useImperativeHandle</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/10_App_hooks_useImperativeHandle.jsx&#39; // useImperativeHandle 父组件操作子组件的方法\n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/10_App_hooks_useImperativeHandle.jsx.jsx</code></p>\n<pre><code class=\"jsx\">import React from &#39;react&#39;;\n\n// const Child = React.forwardRef((props, ref) =&gt; &#123;\n\n//   return (\n//     &lt;&gt;\n//       &lt;input ref = &#123; ref &#125;/&gt;\n//     &lt;/&gt;\n//   )\n// &#125;)\n\n// 可以实现子组件中多个 ref 的使用\nconst Child = React.forwardRef((props, ref) =&gt; &#123;\n  const inputRef = React.useRef()\n  const divRef = React.useRef()\n  // 父组件通过 ref 即可 调用 内部自定义的函数 通过透传ref解决问题\n  React.useImperativeHandle(ref, () =&gt; &#123;\n    return &#123;\n      inputFocus: () =&gt; &#123;\n        inputRef.current.focus()\n      &#125;,\n      wirteVal (str) &#123;\n        divRef.current.innerHTML = str\n      &#125;\n    &#125;\n  &#125;)\n  return (\n    &lt;&gt;\n      &lt;input ref = &#123; inputRef &#125;/&gt;\n      &lt;div ref = &#123; divRef &#125;&gt;&lt;/div&gt;\n    &lt;/&gt;\n  )\n&#125;)\n\nconst App = () =&gt; &#123;\n  const childRef = React.useRef()\n  return (\n    &lt;div&gt;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        // childRef.current.focus()\n        childRef.current.inputFocus()\n      &#125;&#125; style=&#123;&#123; marginRight: 30 &#125;&#125;&gt;获取焦点&lt;/button&gt;\n      &lt;button onClick=&#123; () =&gt; &#123;\n        // childRef.current.focus()\n        childRef.current.wirteVal(&#39;hello hooks!!&#39;)\n      &#125;&#125; style=&#123;&#123; marginRight: 30 &#125;&#125;&gt;写入内容&lt;/button&gt;\n      &lt;Child ref = &#123; childRef &#125;/&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p>上面这个例子中与直接转发 ref 不同，直接转发 ref 是将 <code>React.forwardRef</code> 中函数上的 ref 参数直接应用在了返回元素的 ref 属性上，其实父、子组件引用的是同一个 ref 的 current 对象，官方不建议使用这样的 ref 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 ref，通过 <code>React.forwardRef</code> 将父组件的 ref 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 current。</p>\n<p><code>useImperativeHandle </code>的第一个参数是定义 current 对象的 ref，第二个参数是一个函数，返回值是一个对象，即这个 ref 的 current 对象，这样可以像上面的案例一样，通过自定义父组件的 ref 来使用子组件 ref 的某些方法。</p>\n<p><code>useImperativeHandle</code> 和<code>React.forwardRef</code>必须是配合使用的，这也是为什么在开头要介绍 ref 的转发。</p>\n<h3 id=\"17-2-9-useLayoutEffect\"><a href=\"#17-2-9-useLayoutEffect\" class=\"headerlink\" title=\"17.2.9 useLayoutEffect\"></a>17.2.9 useLayoutEffect</h3><p>useLayoutEffect 与 useEffect的区别：</p>\n<ul>\n<li><code>useEffect</code> 是异步执行的，而<code>useLayoutEffect</code>是同步执行的。</li>\n<li><code>useEffect</code> 的执行时机是浏览器完成渲染之后，而 <code>useLayoutEffect</code> 的执行时机是浏览器把内容真正渲染到界面之前</li>\n</ul>\n<p>举个例子：</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./12_hooks/11_App_hooks_useLayoutEffect&#39; // useLayoutEffect \n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/13-App-useLayoutEffect.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect, useLayoutEffect, useState &#125; from &#39;react&#39;;\n\n// const App = () =&gt; &#123;\n//   const [count, setCount] = useState(1)\n//   useEffect(() =&gt; &#123; // 副作用操作- 异步操作\n//     console.log(&#39;useEffect&#39;) // 后执行\n//     document.title = count + &#39;!!&#39;\n\n//   &#125;)\n//   useLayoutEffect(() =&gt; &#123; // 同步操作 - DOM相关\n//     console.log(&#39;useLayoutEffect&#39;) // 先执行\n//     document.title = count\n//   &#125;) \n//   return (\n//     &lt;div&gt;\n//       &lt;h1&gt;useLayoutEffect&lt;/h1&gt;\n//       &#123; count &#125;\n//       &lt;button onClick=&#123; () =&gt; &#123;\n//         setCount(count + 1)\n//       &#125;&#125;&gt;加1&lt;/button&gt;\n//     &lt;/div&gt;\n//   );\n// &#125;;\n\nfunction App() &#123;\n  const [ state1, setState1 ] = useState(&#39;hello&#39;)\n  const [ state2, setState2 ] = useState(&#39;hi&#39;)\n\n  useEffect(() =&gt; &#123;\n    let i = 0\n    while (i &lt; 1000000000) &#123;\n      i++\n    &#125;\n    setState1(&#39;world&#39;)\n  &#125;, [])\n  useLayoutEffect(() =&gt; &#123;\n    let i = 0\n    while (i &lt; 1000000000) &#123;\n      i++\n    &#125;\n    setState2(&#39;world&#39;)\n  &#125;, [])\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;&#123;state1&#125;&lt;/h1&gt;\n      &lt;h1&gt;&#123;state2&#125;&lt;/h1&gt;\n    &lt;/&gt;\n  )\n&#125;\n\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>注意观察 useEffect 抖动现象</p>\n<p>useLayoutEffect 做DOM操作</p>\n<p>useEffect 中 副作用执行</p>\n</blockquote>\n<h3 id=\"17-2-10-useDebugValue\"><a href=\"#17-2-10-useDebugValue\" class=\"headerlink\" title=\"17.2.10 useDebugValue\"></a>17.2.10 useDebugValue</h3><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/12_App_hooks_useDebugValue&#39; // useDebugValue \n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/12_App_hooks_useDebugValue.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useEffect, useState, useDebugValue &#125; from &#39;react&#39;;\n\n// const App = () =&gt; &#123;\n//   const [count, setCount] = useState(1)\n//   const add = () =&gt; &#123;\n//     setCount(count + 1)\n//   &#125;\n\n//   useEffect(() =&gt; &#123;\n//     document.title = `点击了$&#123;count&#125;次`\n//   &#125;)\n//   return (\n//     &lt;div&gt;\n//       &lt;button onClick=&#123; add &#125;&gt;加1&lt;/button&gt;\n//     &lt;/div&gt;\n//   );\n// &#125;;\n// 自定义hook\nconst useCount = () =&gt; &#123;\n  const [count, setCount] = useState(1)\n  const add = () =&gt; &#123;\n    setCount(count + 1)\n  &#125;\n  useDebugValue(&#39;myCount&#39;) // 自定义Hook起名\n  return &#123;\n    count,\n    add\n  &#125;\n&#125;\n\nconst useTitle = (count) =&gt; &#123;\n  useEffect(() =&gt; &#123;\n    document.title = `点击了$&#123;count&#125;次`\n  &#125;) \n  useDebugValue(&#39;myTitle&#39;) // 自定义Hook起名\n&#125;\n\n\nconst App = () =&gt; &#123;\n  // const [count, setCount] = useState(1)\n  // const add = () =&gt; &#123;\n  //   setCount(count + 1)\n  // &#125;\n\n  const &#123; count, add &#125; = useCount()\n\n  // useEffect(() =&gt; &#123;\n  //   document.title = `点击了$&#123;count&#125;次`\n  // &#125;)\n\n  useTitle(count)\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick=&#123; add &#125;&gt;加1&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<p>接下来的hooks是属于react18版本新增的hooks</p>\n<h3 id=\"17-2-11-useId\"><a href=\"#17-2-11-useId\" class=\"headerlink\" title=\"17.2.11 useId\"></a>17.2.11 useId</h3><p><code>useId</code>是一个钩子，用于生成唯一的ID，在服务器和客户端之间是稳定的，同时避免hydration 不匹配。</p>\n<blockquote>\n<p>注意：</p>\n<p><code>useId</code>不是用来生成列表中的键的。<code>Keys</code> 应该从你的数据中生成。</p>\n<p>不能用于列表渲染的key值</p>\n</blockquote>\n<p>对于一个基本的例子，直接将id传递给需要它的元素。</p>\n<p>对于同一组件中的多个ID，使用相同的ID附加一个后缀。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/13_App_hooks_useId&#39; // useId \n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/13_App_hooks_useId.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; useId &#125; from &#39;react&#39;;\n\n//React Hook &quot;useId&quot; cannot be called inside a callback. \n// React Hooks must be called in a React function component or a custom React Hook function\n// useId不能在回调函数中使用，\n// react hooks 必须包裹在函数式组件或者自定义hooks中使用\nconst App = () =&gt; &#123;\n  // const [list] = useState([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n  const useNameId = useId()\n  const passwordId = useId()\n  return (\n    &lt;div&gt;\n      &#123;\n        // list &amp;&amp; list.map((item) =&gt; &#123;\n        //   const id = useId() // 这样的写法是错误的\n        //   return (\n        //     &lt;p key = &#123; id &#125;&gt; &#123; item &#125; &lt;/p&gt;\n        //   )\n        // &#125;)\n      &#125;\n      &#123;/* HTML 中使用for，react中使用HtmlFor */&#125;\n      &lt;div&gt;\n        &lt;label htmlFor=&#123; useNameId &#125;&gt;用户名&lt;/label&gt;\n        &lt;input type=&quot;text&quot; id = &#123; useNameId &#125; /&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label htmlFor = &#123; passwordId &#125;&gt;密码&lt;/label&gt;\n        &lt;input type=&quot;password&quot; id = &#123; passwordId &#125; /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p><code>useId</code> 会生成一个包含 : token的字符串。这有助于确保令牌是唯一的，但在CSS选择器或API（如<code>querySelectorAll</code>）中不支持。</p>\n<p><code>useId</code>支持一个<code>identifierPrefix</code>，以防止在多根应用程序中发生碰撞。要配置，请参阅 <code>hydrateRoot</code> 和 <code>ReactDOMServer </code>的选项。</p>\n<p>hooks需要在函数式组件以及自定义hook的顶级使用（返回jsx代码之前），不要在jsx代码中使用hooks</p>\n</blockquote>\n<h3 id=\"17-2-12-useDeferredValue\"><a href=\"#17-2-12-useDeferredValue\" class=\"headerlink\" title=\"17.2.12 useDeferredValue\"></a>17.2.12 useDeferredValue</h3><blockquote>\n<p>真实需求其实不需要实时渲染所有的数据</p>\n</blockquote>\n<p><code>useDeferredValue</code> 需要接收一个值, 返回这个值的副本, 副本的更新会在值更新渲染之后进行更新, 以此来避免一些不必要的重复渲染. 打个比方页面中有输入框, 输入框下的内容依赖于输入框的值, 但是输入框是一个高频操作, 如果输入10次, 可能用户只想看到最终的结果那么中途的实时渲染就显得不那么重要了, 页面元素少点还好, 一旦元素过多页面就会及其的卡顿, 渲染引擎堵得死死的, 用户就会骂娘了, 此时使用useDeferredValue是一个很好的选择</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./12_hooks/14_App_hooks_useDeferredValue&#39; // useDeferredValue \n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/14_App_hooks_useDeferredValue.jsx</code> 数据量必须过大，否则看不到效果</p>\n<pre><code class=\"jsx\">import React, &#123; useDeferredValue, useEffect, useState, useMemo, memo &#125; from &#39;react&#39;\nconst List = memo(function List(&#123;count&#125;) &#123;\n  const [data, setData] = useState([])\n\n  useEffect(() =&gt; &#123;\n    const data = []\n    data.length = 50000\n    for (let i = 0; i &lt; data.length; i++) &#123;\n      data.fill(i+1, i)\n    &#125;\n    setData(data)\n\n  &#125;, [count])\n\n  return (\n    &lt;div&gt;\n      &#123;\n        data.map((item) =&gt; &#123;\n          return (\n            &lt;p key=&#123;item&#125;&gt;&#123;count&#125;&lt;/p&gt;\n          )\n        &#125;)\n      &#125;\n    &lt;/div&gt;\n  )\n&#125;)\n\nexport default function UseDeferredValueDemo() &#123;\n  const [inpVal, setInpVal] = useState(&#39;&#39;)\n  const deferredValue = useDeferredValue(inpVal) // 备份数据\n  const memoList = useMemo(() =&gt; &lt;List count=&#123;deferredValue&#125;&gt;&lt;/List&gt;, [deferredValue])\n  return (\n    &lt;&gt;\n      &lt;h1&gt;UseDeferredValue&lt;/h1&gt;\n      &lt;input type=&quot;text&quot; value=&#123;inpVal&#125;  onChange=&#123;(e) =&gt; setInpVal(e.target.value)&#125;/&gt;\n      &#123;memoList&#125;\n    &lt;/&gt;\n  )\n&#125;\n</code></pre>\n<h3 id=\"17-2-13-useTransition\"><a href=\"#17-2-13-useTransition\" class=\"headerlink\" title=\"17.2.13 useTransition\"></a>17.2.13 useTransition</h3><p><code>useTransition</code> 又叫过渡, 他的作用就是标记非紧急更新, 这些被标记非紧急更新会在紧急更新完之后进行更新, <code>useTransition</code> 使用场景在应对渲染量很大的页面，需要及时响应某些事件的情况。</p>\n<p>举个例子，准备一个进度条, 通过滑动进度条来显示进度条的进度并且渲染相同进度数量的div, 如果我们不对渲染进行优化那无疑页面会很卡, 此时使用过渡配合useMemo来缓存页面结构, diffing算法就会对比出少量的变化进行局部修改。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./12_hooks/15_App_hooks_useTransition&#39; // useTransition \n\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App/&gt;\n)\n</code></pre>\n<p><code>src/12_hooks/15_App_hooks_useTransition</code></p>\n<pre><code class=\"jsx\">import React, &#123; useTransition, useState, useMemo &#125; from &#39;react&#39;\n \nexport default function UseTransition() &#123;\n  const [isPending, startTransition] = useTransition()\n \n  const [rangeValue, setRangeValue] = useState(1)\n  const [renderData, setRenderData] = useState([1])\n  const [isStartTransition, setIsStartTransition] = useState(false)\n  const handleChange = (e) =&gt; &#123;\n    setRangeValue(e.target.value)\n    const arr = []\n    arr.length = e.target.value\n    for (let i = 0; i &lt;= arr.length; i++) &#123;\n      arr.fill(i, i + 1)\n    &#125;\n    if (isStartTransition) &#123;\n      startTransition(() =&gt; &#123;\n        setRenderData(arr)\n      &#125;)\n    &#125; else &#123;\n      setRenderData(arr)\n    &#125;\n  &#125;\n  const jsx = useMemo(() =&gt; &#123;\n    return renderData.map((item, index) =&gt; &#123;\n      return (\n        &lt;div\n          style=&#123;&#123;\n            width: 50,\n            height: 50,\n            backgroundColor: `#$&#123;Math.floor(Math.random() * 16777215).toString(\n              16\n            )&#125;`,\n            margin: 10,\n            display: 'inline-block',\n          &#125;&#125;\n          key=&#123;&#39;item&#39;+index&#125;\n        &gt;\n          &#123;item&#125;\n        &lt;/div&gt;\n      )\n    &#125;)\n  &#125;, [renderData])\n  return (\n    &lt;div&gt;\n      &lt;div style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt;\n        &lt;label&gt;\n          &lt;input\n            type=&quot;checkbox&quot;\n            checked=&#123;isStartTransition&#125;\n            onChange=&#123;(e) =&gt; &#123;\n              setIsStartTransition(e.target.checked)\n            &#125;&#125;\n          /&gt;\n          useTransition\n        &lt;/label&gt;\n        &lt;input\n          type=&quot;range&quot;\n          value=&#123;rangeValue&#125;\n          min=&#123;0&#125;\n          max=&#123;10000&#125;\n          style=&#123;&#123; width: 120 &#125;&#125;\n          onChange=&#123;handleChange&#125;\n        /&gt;\n        &lt;span&gt;进度条 &#123;rangeValue&#125;&lt;/span&gt;\n        &lt;hr /&gt;\n      &lt;/div&gt;\n      &#123;jsx&#125;\n    &lt;/div&gt;\n  )\n&#125;\n</code></pre>\n<h3 id=\"17-2-14-useSyncExternalStore\"><a href=\"#17-2-14-useSyncExternalStore\" class=\"headerlink\" title=\"17.2.14 useSyncExternalStore\"></a>17.2.14 useSyncExternalStore</h3><p>React18的beta版本将<code>useMutableSource</code>更新为了<code>useSyncExternalStore</code>，这个新的api将会对React的各种状态管理库产生非常大的影响，下面我来介绍<code>useSyncExternalStore</code>的用法和场景。</p>\n<p>我们可以通过这个api自行设计一个redux + react-redux的数据方案：</p>\n<p><strong>1、设计store</strong></p>\n<p>首先我们要设计一个store，它必须有如下属性：</p>\n<ul>\n<li>currentState:当前状态</li>\n<li>subscribe:提供状态发生变化时的订阅能力</li>\n<li>getSnapshot: 获取当前状态</li>\n</ul>\n<p>以及改变state的方法，这里参考redux，设计了dispatch、reducer</p>\n<pre><code class=\"jsx\">const store = &#123;\n    currentState:&#123;data:0&#125;,\n    listeners:[],\n    reducer(action)&#123;\n        switch(action.type) &#123;\n            case &#39;ADD&#39;:\n                return &#123;data:store.currentState.data+1&#125;\n            default:\n                return store.state\n        &#125;\n    &#125;,\n    subscribe(l)&#123;\n        store.listeners.push(l)\n    &#125;,\n    getSnapshot() &#123;\n        return store.currentState\n    &#125;,\n    dispatch(action) &#123;\n        store.currentState = store.reducer(action)\n        store.listeners.forEach(l=&gt;l())\n        return action;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>2、应用 store 同步组件状态</strong></p>\n<pre><code class=\"jsx\">import React, &#123; useSyncExternalStore &#125; from &#39;react&#39;\nimport store from &#39;./store&#39;\n\nexport default function UseSyncExternalStoreDemo() &#123;\n  const state = useSyncExternalStore(store.subscribe, () =&gt; store.getSnapshot().data);\n    \n    return (\n      &lt;div&gt;\n        &lt;div&gt;count: &#123;state&#125;&lt;/div&gt;\n        &lt;div&gt;\n            &lt;button onClick=&#123;()=&gt;store.dispatch(&#123;type:&#39;ADD&#39;&#125;)&#125;&gt;add+&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    )\n&#125;\n</code></pre>\n<h3 id=\"17-2-15-useInsertionEffect\"><a href=\"#17-2-15-useInsertionEffect\" class=\"headerlink\" title=\"17.2.15 useInsertionEffect\"></a>17.2.15 useInsertionEffect</h3><p><code>useInsertionEffect</code> 与useEffect相同，在所有DOM变更之前同步触发。在使用 useLayoutEffect 读取布局之前，使用这个函数将样式注入到DOM中。因为这个钩子的作用域是有限的，所以这个钩子不能访问 refs，也不能调度更新。</p>\n<pre><code class=\"jsx\">import React, &#123; useInsertionEffect, useEffect, useLayoutEffect &#125; from &#39;react&#39;\n \nexport default function UseInsertionEffect() &#123;\n\n  useInsertionEffect(() =&gt; &#123;\n    console.log(&#39;useInsertionEffect&#39;) // 1\n    // const style = document.createElement(&#39;style&#39;)\n    // style.innerHTML = &#39;.box &#123; color: red &#125;&#39;\n    // document.head.appendChild(style)\n  &#125;)\n\n  useEffect(() =&gt; &#123;\n    console.log(&#39;useEffect&#39;) // 3\n  &#125;)\n\n  useLayoutEffect(() =&gt; &#123;\n    console.log(&#39;useLayoutEffect&#39;) // 2\n  &#125;)\n\n  return (\n    &lt;div className=&quot;box&quot;&gt;UseInsertionEffect&lt;/div&gt;\n  )\n&#125;\n</code></pre>\n<h2 id=\"17-3-自定义hooks\"><a href=\"#17-3-自定义hooks\" class=\"headerlink\" title=\"17.3 自定义hooks\"></a>17.3 自定义hooks</h2><p>以use开头的小驼峰式的函数</p>\n",
            "tags": [
                "react学习",
                "react"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/react-study/6/",
            "url": "https://www.yexingcheng.com/react-study/6/",
            "title": "React学习第六天",
            "date_published": "2022-08-05T16:00:00.000Z",
            "content_html": "<h1 id=\"十四、上下文Context\"><a href=\"#十四、上下文Context\" class=\"headerlink\" title=\"十四、上下文Context\"></a>十四、上下文Context</h1><h2 id=\"14-1-理解上下文、作用及其特点\"><a href=\"#14-1-理解上下文、作用及其特点\" class=\"headerlink\" title=\"14.1 理解上下文、作用及其特点\"></a>14.1 理解上下文、作用及其特点</h2><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>\n<p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>\n<p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p>\n<h2 id=\"14-2-使用React-createContext\"><a href=\"#14-2-使用React-createContext\" class=\"headerlink\" title=\"14.2 使用React.createContext()\"></a>14.2 使用React.createContext()</h2><h3 id=\"14-2-1-逐层传递数据\"><a href=\"#14-2-1-逐层传递数据\" class=\"headerlink\" title=\"14.2.1 逐层传递数据\"></a>14.2.1 逐层传递数据</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./09_context/01_App_next_value&#39; // 逐层传递数据\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/01_App_next_value.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n        &lt;div&gt;&#123; this.props.val &#125;&lt;/div&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nconst Second = (props) =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;second&lt;/h2&gt;\n      &lt;Third val = &#123; props.val &#125;/&gt;\n    &lt;/div&gt;\n  )\n&#125;\nconst First = (props) =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;first&lt;/h1&gt;\n      &lt;Second val=&#123; props.val &#125;/&gt;\n    &lt;/div&gt;\n  )\n&#125;\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;First val=&quot;传家宝&quot; /&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h3 id=\"14-2-2-使用Context传值\"><a href=\"#14-2-2-使用Context传值\" class=\"headerlink\" title=\"14.2.2 使用Context传值\"></a>14.2.2 使用Context传值</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./09_context/02_App_context&#39; // 上下文对象Context传值\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/02_App_context.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n// 1.创建上下文对象 - 首字母大写，大驼峰式命名\nconst LangContext = React.createContext()\n// 3.3 使用上下文对象的 Consumer 组件来获取值,需要组件内容写一个回调函数，回调函数参数即为祖先组件传递的值\n// 发现第三种写法看似麻烦，但是如果祖先组件给后代组件通过多个上下文对象传递很多个数据时就很有用了，而前两种方法显得无能为力\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n        &lt;LangContext.Consumer&gt;\n          &#123;\n            (val) =&gt; &#123;\n              return (\n                &lt;div&gt;语言为： &#123; val &#125;&lt;/div&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/LangContext.Consumer&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst Second = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Second&lt;/h2&gt;\n      &lt;Third/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nconst First = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;First&lt;/h1&gt;\n      &lt;Second/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    lang: &#39;zh&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;zh&#39;&#125;)&#125;&gt;中文&lt;/button&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;en&#39;&#125;)&#125;&gt;英文&lt;/button&gt;\n        &#123;/* 2.祖先组件通过 上下文对象的Provider 组件 配合value进行传值 */&#125;\n        &lt;LangContext.Provider value=&#123;this.state.lang&#125;&gt;\n          &lt;First/&gt;\n        &lt;/LangContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h3 id=\"14-2-3-传递多个值\"><a href=\"#14-2-3-传递多个值\" class=\"headerlink\" title=\"14.2.3 传递多个值\"></a>14.2.3 传递多个值</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./09_context/03_App_context_multiple_value&#39; // 上下文对象Context传值 多个上下文对象传递数据\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/03_App_context_multiple_value.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n// 1.创建上下文对象 - 首字母大写，大驼峰式命名\nconst LangContext = React.createContext()\nconst ColorContext = React.createContext()\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n\n        &lt;ColorContext.Consumer&gt;\n          &#123;\n            (color) =&gt; &#123;\n              return (\n                &lt;&gt;\n                  &lt;LangContext.Consumer&gt;\n                    &#123;\n                      (val) =&gt; &#123;\n                        return (\n                          &lt;div style = &#123;&#123; color: color &#125;&#125;&gt;语言为： &#123; val &#125;&lt;/div&gt;\n                        )\n                      &#125;\n                    &#125;\n                  &lt;/LangContext.Consumer&gt;\n                &lt;/&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/ColorContext.Consumer&gt;\n        \n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst Second = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Second&lt;/h2&gt;\n      &lt;Third/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nconst First = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;First&lt;/h1&gt;\n      &lt;Second/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    lang: &#39;zh&#39;,\n    color: &#39;#f66&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;zh&#39;&#125;)&#125;&gt;中文&lt;/button&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;en&#39;&#125;)&#125;&gt;英文&lt;/button&gt;\n        &lt;input type=&quot;color&quot;  value=&#123; this.state.color &#125; onChange= &#123; (event) =&gt; &#123;\n          this.setState(&#123;\n            color: event.target.value\n          &#125;)\n        &#125;&#125;/&gt;\n        &#123;/* 2.祖先组件通过 上下文对象的Provider 组件 配合value进行传值 */&#125;\n        &lt;LangContext.Provider value=&#123;this.state.lang&#125;&gt;\n          &lt;ColorContext.Provider value = &#123; this.state.color &#125;&gt;\n            &lt;First/&gt;\n          &lt;/ColorContext.Provider&gt;\n        &lt;/LangContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<p>上述案例，还可以通过一个上下文对象传递多个值</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./09_context/04_App_one_context_multiple_value&#39; // 上下文对象Context传值 1个上下文对象传递多个数据\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/04_App_one_context_multiple_value.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n// 1.创建上下文对象 - 首字母大写，大驼峰式命名\nconst MyContext = React.createContext()\n\n\n\n// 3.3 使用上下文对象的 Consumer 组件来获取值,需要组件内容写一个回调函数，回调函数参数即为祖先组件传递的值\n// 发现第三种写法看似麻烦，但是如果祖先组件给后代组件通过多个上下文对象传递很多个数据时就很有用了，而前两种方法显得无能为力\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n        &lt;MyContext.Consumer&gt;\n          &#123;\n            (val) =&gt; &#123;\n              return (\n                &lt;div style = &#123;&#123; color:val.color &#125;&#125;&gt;3语言为： &#123; val.lang &#125;&lt;/div&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/MyContext.Consumer&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst Second = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Second&lt;/h2&gt;\n      &lt;Third/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nconst First = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;First&lt;/h1&gt;\n      &lt;Second/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    lang: &#39;zh&#39;,\n    color: &#39;#f66&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;zh&#39;&#125;)&#125;&gt;中文&lt;/button&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;en&#39;&#125;)&#125;&gt;英文&lt;/button&gt;\n        &lt;input type=&quot;color&quot;  value=&#123; this.state.color &#125; onChange= &#123; (event) =&gt; &#123;\n          this.setState(&#123;\n            color: event.target.value\n          &#125;)\n        &#125;&#125;/&gt;\n        &#123;/* 2.祖先组件通过 上下文对象的Provider 组件 配合value进行传值 */&#125;\n        &lt;MyContext.Provider value=&#123; &#123;\n          lang: this.state.lang,\n          color: this.state.color\n        &#125; &#125;&gt;\n          &lt;First/&gt;\n        &lt;/MyContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<p>如果遇到函数式组件如何获取Context的值</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./09_context/05_App_function_context_value&#39; // 上下文对象Context传值 函数式组件获取值\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/05_App_function_context_value.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nimport &#123; useContext &#125; from &#39;react&#39;;\n// 1.创建上下文对象 - 首字母大写，大驼峰式命名\nconst LangContext = React.createContext()\n\n\n// 3.3 使用上下文对象的 Consumer 组件来获取值,需要组件内容写一个回调函数，回调函数参数即为祖先组件传递的值\n// 发现第三种写法看似麻烦，但是如果祖先组件给后代组件通过多个上下文对象传递很多个数据时就很有用了，而前两种方法显得无能为力\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n        &lt;LangContext.Consumer&gt;\n          &#123;\n            (val) =&gt; &#123;\n              return (\n                &lt;div&gt;语言为： &#123; val &#125;&lt;/div&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/LangContext.Consumer&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\n// 4.如果后代组件是函数式组件，可以有两种写法\n// 4.1 使用上下文对象.Consumer完成传值\nconst Second = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Second&lt;/h2&gt;\n      &lt;LangContext.Consumer&gt;\n          &#123;\n            (val) =&gt; &#123;\n              return (\n                &lt;div &gt;Second - 语言为： &#123; val &#125;&lt;/div&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/LangContext.Consumer&gt;\n      &lt;Third/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\n// 4.2 可以使用 useContext hooks 来获取值\nconst First = () =&gt; &#123;\n  const lang = useContext(LangContext)\n  // const color = useContext(ColorContext)\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;First&lt;/h1&gt;\n      &lt;div &gt;First - 语言为： &#123; lang &#125;&lt;/div&gt;\n      &lt;Second/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    lang: &#39;zh&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;zh&#39;&#125;)&#125;&gt;中文&lt;/button&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;en&#39;&#125;)&#125;&gt;英文&lt;/button&gt;\n        &#123;/* 2.祖先组件通过 上下文对象的Provider 组件 配合value进行传值 */&#125;\n        &lt;LangContext.Provider value=&#123;this.state.lang&#125;&gt;\n          &lt;First/&gt;\n        &lt;/LangContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>如果浏览器安装过 react的开发者工具,打开之后发现上述代码，都显示为 <code>Context.Provider</code> 和 <code>Context.Consumer</code>,不好区分</p>\n<p>加入 上下文对象的 <code>displayName</code></p>\n</blockquote>\n<h3 id=\"14-2-4-displayName\"><a href=\"#14-2-4-displayName\" class=\"headerlink\" title=\"14.2.4 displayName\"></a>14.2.4 displayName</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./09_context/06_App_context_displayName&#39; // 上下文对象Context传值 开发者工具显示Context名称\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/09_context/06_App_context_displayName.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n// 1.创建上下文对象 - 首字母大写，大驼峰式命名\nconst LangContext = React.createContext()\nconst ColorContext = React.createContext()\n\nLangContext.displayName = &#39;LangContext&#39;\nColorContext.displayName = &#39;ColorContext&#39;\n\n// 3.如果后代组件是类组件，可以有三种方式接收祖先组件的传递的值\n//   3.1 定义好组件后 通过  组件.contextType = 上下文对象，这样就可以在组件中通过 this.context 获取到 组件组件的数据\n//   3.2 使用类的静态属性contextType 等于上下文对象，然后通过 this.context 获取值\n//   3.3 使用上下文对象的 Consumer 组件来获取值,需要组件内容写一个回调函数，回调函数参数即为祖先组件传递的值\n// 发现第三种写法看似麻烦，但是如果祖先组件给后代组件通过多个上下文对象传递很多个数据时就很有用了，而前两种方法显得无能为力\nclass Third extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;third&lt;/h3&gt;\n\n        &lt;ColorContext.Consumer&gt;\n          &#123;\n            (color) =&gt; &#123;\n              return (\n                &lt;&gt;\n                  &lt;LangContext.Consumer&gt;\n                    &#123;\n                      (val) =&gt; &#123;\n                        return (\n                          &lt;div style = &#123;&#123; color: color &#125;&#125;&gt;语言为： &#123; val &#125;&lt;/div&gt;\n                        )\n                      &#125;\n                    &#125;\n                  &lt;/LangContext.Consumer&gt;\n                &lt;/&gt;\n              )\n            &#125;\n          &#125;\n        &lt;/ColorContext.Consumer&gt;\n        \n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst Second = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Second&lt;/h2&gt;\n      &lt;Third/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nconst First = () =&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;First&lt;/h1&gt;\n      &lt;Second/&gt;\n    &lt;/div&gt;\n  )\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    lang: &#39;zh&#39;,\n    color: &#39;#f66&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;zh&#39;&#125;)&#125;&gt;中文&lt;/button&gt;\n        &lt;button onClick=&#123;() =&gt; this.setState(&#123; lang: &#39;en&#39;&#125;)&#125;&gt;英文&lt;/button&gt;\n        &lt;input type=&quot;color&quot;  value=&#123; this.state.color &#125; onChange= &#123; (event) =&gt; &#123;\n          this.setState(&#123;\n            color: event.target.value\n          &#125;)\n        &#125;&#125;/&gt;\n        &#123;/* 2.祖先组件通过 上下文对象的Provider 组件 配合value进行传值 */&#125;\n        &lt;LangContext.Provider value=&#123;this.state.lang&#125;&gt;\n          &lt;ColorContext.Provider value = &#123; this.state.color &#125;&gt;\n            &lt;First/&gt;\n          &lt;/ColorContext.Provider&gt;\n        &lt;/LangContext.Provider&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"14-3-常见应用场景解读\"><a href=\"#14-3-常见应用场景解读\" class=\"headerlink\" title=\"14.3 常见应用场景解读\"></a>14.3 常见应用场景解读</h2><ul>\n<li>共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言</li>\n<li>配合<code>react hooks</code>中的<code>useReducer</code>可以实现轻量的 <code>redux</code></li>\n</ul>\n<h1 id=\"十五、高阶组件\"><a href=\"#十五、高阶组件\" class=\"headerlink\" title=\"十五、高阶组件\"></a>十五、高阶组件</h1><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。</p>\n<p>HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>\n<p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p>\n<h2 id=\"15-1-理解高阶组件、作用及其特点\"><a href=\"#15-1-理解高阶组件、作用及其特点\" class=\"headerlink\" title=\"15.1 理解高阶组件、作用及其特点\"></a>15.1 理解高阶组件、作用及其特点</h2><p>一个高阶组件只是一个包装了另外一个 React 组件的 函数。<br>这种形式通常实现为一个函数，本质上是一个类工厂。</p>\n<p>.实现了对原有组件的<code>增强和优化</code>。</p>\n<p>可以对原有<code>组件</code>中的state, props和逻辑执行增删改操作, 一般用于代码<code>重用</code>和组件<code>增强优化</code></p>\n<h2 id=\"15-2-高阶组件语法详解\"><a href=\"#15-2-高阶组件语法详解\" class=\"headerlink\" title=\"15.2 高阶组件语法详解\"></a>15.2 高阶组件语法详解</h2><p>我们想要我们的组件通过自动注入一个版权信息</p>\n<h3 id=\"15-2-1-组件嵌套\"><a href=\"#15-2-1-组件嵌套\" class=\"headerlink\" title=\"15.2.1 组件嵌套\"></a>15.2.1 组件嵌套</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./10_hoc/01_App-more-use&#39; // 高阶组件 多个组件引入同一个组件\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/10_hoc/01_App-more-use.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass Footer extends Component &#123;\n  render () &#123;\n    return (\n      &lt;footer&gt;\n        Copyright © 2022 Meta Platforms, Inc.\n      &lt;/footer&gt;\n    )\n  &#125;\n&#125;\nclass Page1 extends Component &#123;\n  state = &#123; userName: &#39;&#39;&#125;\n  componentDidMount () &#123;\n    this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;page1&lt;/h1&gt;\n        &lt;Footer /&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nclass Page2 extends Component &#123;\n  state = &#123; userName: &#39;&#39;&#125;\n  componentDidMount () &#123;\n    this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;page2&lt;/h1&gt;\n        &lt;Footer /&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nclass Page3 extends Component &#123;\n  state = &#123; userName: &#39;&#39;&#125;\n  componentDidMount () &#123;\n    this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;page3&lt;/h1&gt;\n        &lt;Footer /&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Page1/&gt;\n        &lt;hr /&gt;\n        &lt;Page2 /&gt;\n        &lt;hr /&gt;\n        &lt;Page3 /&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>通过<code>Footer</code>组件可以复用jsx代码，但是其余的业务逻辑代码显得无能为力，可以通过高阶组件来实现</p>\n</blockquote>\n<h3 id=\"15-2-2-高阶组件\"><a href=\"#15-2-2-高阶组件\" class=\"headerlink\" title=\"15.2.2 高阶组件\"></a>15.2.2 高阶组件</h3><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./10_hoc/02_App-more-use-hoc&#39; // 高阶组件 高阶组件\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/10_hoc/02_App-more-use-hoc.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nlocalStorage.setItem(&#39;userName&#39;, &#39;吴大勋&#39;)\nclass Footer extends Component &#123;\n  render () &#123;\n    return (\n      &lt;footer&gt;\n        Copyright © 2022 Meta Platforms, Inc.\n      &lt;/footer&gt;\n    )\n  &#125;\n&#125;\n\n// 高阶组件的本质是一个函数，将一个组件作为参数，返回一个新的组件\nconst withFooter = (Com) =&gt; &#123;\n  return class extends Component &#123; // 此处可以省略新组件的名称\n    // 写公共部分的业务逻辑\n    state = &#123; userName: &#39;&#39;&#125;\n    componentDidMount () &#123;\n      console.log(&#39;0000&#39;)\n      this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n    &#125;\n    render () &#123; // 实际上此操作相当于完成父组件给子组件传值\n      return (\n        &lt;&gt;\n          &lt;Com userName = &#123; this.state.userName &#125;/&gt;\n          &lt;Footer /&gt;\n        &lt;/&gt;\n      )\n    &#125;\n  &#125;\n&#125;\n\nclass Page1 extends Component &#123;\n  // state = &#123; userName: &#39;&#39;&#125;\n  // componentDidMount () &#123;\n  //   this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  // &#125;\n\n  componentDidMount () &#123;\n    console.log(&#39;1111&#39;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &#123;/* &lt;h1&gt;page1 - &#123; this.state.userName &#125;&lt;/h1&gt; */&#125;\n        &lt;h1&gt;page1 - &#123; this.props.userName &#125;&lt;/h1&gt;\n        &#123;/* &lt;Footer /&gt; */&#125;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nPage1 = withFooter(Page1)\n\nclass Page2 extends Component &#123;\n  // state = &#123; userName: &#39;&#39;&#125;\n  // componentDidMount () &#123;\n  //   this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  // &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &#123;/* &lt;h1&gt;page2 - &#123; this.state.userName &#125;&lt;/h1&gt; */&#125;\n        &lt;h1&gt;page2 - &#123; this.props.userName &#125;&lt;/h1&gt;\n        &#123;/* &lt;Footer /&gt; */&#125;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nPage2 = withFooter(Page2)\n\nclass Page3 extends Component &#123;\n  // state = &#123; userName: &#39;&#39;&#125;\n  // componentDidMount () &#123;\n  //   this.setState(&#123; userName: localStorage.getItem(&#39;userName&#39;) &#125;)\n  // &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &#123;/* &lt;h1&gt;page3 - &#123; this.state.userName &#125;&lt;/h1&gt; */&#125;\n        &lt;h1&gt;page3 - &#123; this.props.userName &#125;&lt;/h1&gt;\n        &#123;/* &lt;Footer /&gt; */&#125;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nPage3 = withFooter(Page3)\n\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Page1/&gt;\n        &lt;hr /&gt;\n        &lt;Page2 /&gt;\n        &lt;hr /&gt;\n        &lt;Page3 /&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>先执行了 组件的生命周期，后执行了高阶组件的生命周期</p>\n<p>但是以后再复用组件的业务时，可以选用函数式组件的自定义hooks</p>\n</blockquote>\n<h2 id=\"15-3-常见应用场景解读\"><a href=\"#15-3-常见应用场景解读\" class=\"headerlink\" title=\"15.3 常见应用场景解读\"></a>15.3 常见应用场景解读</h2><p>1.需要代码重用时, react如果有多个组件都用到了<code>同一段逻辑</code>, 这时,就可以把共同的逻辑部分提取出来,利用高阶组件的形式将这段逻辑整合到每一个组件中, 从而减少代码的逻辑重复</p>\n<p>2.需要组件<code>增强优化时</code>, 比如我们在项目中使用的组件有些不是自己写的, 而是从网上撸下来的,但是<code>第三方</code>写的组件可能比较复杂, 有时不能完全满足需求, 但第三方组件不易修改, 此时也可以用高阶组件,在不修改原始组件的前提下, 对组件添加满足实际开发需求的功能</p>\n<p> 3.可以对原有<code>组件</code>中的state, props和逻辑执行增删改操作, 一般用于代码<code>重用</code>和组件<code>增强优化</code></p>\n<p> 4.也可以用来替换 <code>mixins</code> 混入</p>\n<blockquote>\n<p>父组件和高阶组件有什么区别？</p>\n<ul>\n<li>首先从逻辑的执行流程上来看，高阶组件确实和父组件比较相像</li>\n<li>但是<code>高阶</code>组件强调的是<code>逻辑</code>的抽象。高阶组件是一个<code>函数</code>，函数关注的是逻辑；</li>\n<li><code>父组件</code>是一个组件，组件主要关注的是<code>UI/DOM</code>。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；</li>\n<li>如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。</li>\n</ul>\n</blockquote>\n<h1 id=\"十六、ref\"><a href=\"#十六、ref\" class=\"headerlink\" title=\"十六、ref\"></a>十六、ref</h1><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>\n<h2 id=\"16-1-ref访问DOM\"><a href=\"#16-1-ref访问DOM\" class=\"headerlink\" title=\"16.1 ref访问DOM\"></a>16.1 ref访问DOM</h2><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./11_ref/01_App_ref&#39; // ref的使用以及严格模式\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  // 开启React的严格模式\n  // https://react.docschina.org/docs/strict-mode.html\n  &lt;React.StrictMode&gt;\n    &lt;App /&gt;\n  &lt;/React.StrictMode&gt;\n)\n// react 18 为严格模式引入了一个全新的仅用于开发环境的检查操作。\n// 每当第一次安装组件时，这个新的检查将自动卸载并重新安装每个组件，并在第二次挂载时恢复之前的 state。\n// 慎用严格模式\n</code></pre>\n<p><code>src/11_ref/01_App_ref.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\n  state = &#123;\n    count: 1\n  &#125;\n  componentDidMount () &#123;\n    console.log(this.state.count)\n    // this.setState(&#123; // Object.assign(&#123;&#125;)\n    //   count: this.state.count + 1\n    // &#125;)\n    this.setState((state) =&gt; &#123; // state 拿到的最新的值\n      return &#123;\n        count: state.count + 1\n      &#125;\n    &#125;)\n    console.log(&#39;id&#39;, document.getElementById(&#39;btn1&#39;))\n    console.log(&#39;refs&#39;, this.refs.btn2) // refs已经被废弃，但是没有移除,严格模式下会报警告信息\n  &#125;\n  // componentWillMount () &#123;&#125; // 警告：被重命名\n  // UNSAFE_componentWillMount () &#123;&#125; // 严格模式下识别不安全的生命周期\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &#123;/* 如果开启严格模式并且使用函数形式修改状态，输出结果为3 */&#125;\n        &#123; this.state.count &#125;\n        &lt;button id=&#39;btn1&#39;&gt;按钮1-id&lt;/button&gt;\n        &lt;button ref=&#39;btn2&#39;&gt;按钮2-refs - 废弃&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./11_ref/02_App_ref&#39; // ref的使用以及严格模式\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App /&gt;\n)\n</code></pre>\n<p><code>src/11_ref/02_App_ref.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass Com extends Component &#123;\n  state = &#123;\n    name: &#39;类组件&#39;\n  &#125;\n  testFn = () =&gt; &#123;\n    console.log(this.state.name + &#39;!!!!!!!&#39;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;类组件ref的使用&lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst FunCom = () =&gt; &#123;\n  return (\n    &lt;div&gt;函数式组件ref&lt;/div&gt;\n  )\n&#125;\nclass App extends Component &#123;\n  btn3Ref = React.createRef() // 创建一个唯一的 ref\n  comRef = React.createRef()\n  funRef = React.createRef()\n  componentDidMount () &#123;\n    console.log(&#39;id&#39;, document.getElementById(&#39;btn1&#39;))\n    console.log(&#39;refs&#39;, this.refs.btn2) // refs已经被废弃，但是没有移除,严格模式下会报警告信息\n    console.log(&#39;domCreateRef&#39;, this.btn3Ref.current) \n    console.log(&#39;comCreateRef&#39;, this.comRef.current) \n    console.log(&#39;FuncomCreateRef&#39;, this.funRef.current) // null\n\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button id=&#39;btn1&#39;&gt;按钮1-id&lt;/button&gt;\n        &lt;button ref=&#39;btn2&#39;&gt;按钮2-refs - 废弃&lt;/button&gt;\n        &lt;button ref=&#123; this.btn3Ref &#125;&gt;按钮2 - createRef &lt;/button&gt;\n        &#123;/* 父组件可以直接通过ref 获取 子组件的实例 */&#125;\n        &lt;Com ref = &#123; this.comRef &#125;&gt;&lt;/Com&gt;\n        &#123;/* 函数式组件没有实例，获取不到子组件实例 */&#125;\n        &lt;FunCom ref = &#123; this.funRef &#125;&gt;&lt;/FunCom&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>如果在上述案例中，在<code>FunCom</code>组件中上使用ref，发现报了警告信息</p>\n<p>Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</p>\n<p>其原因是，函数式组件使用ref，<strong>必须使用React.forwardRef()方法二次包装</strong></p>\n</blockquote>\n<h2 id=\"16-2-详解ref转发\"><a href=\"#16-2-详解ref转发\" class=\"headerlink\" title=\"16.2 详解ref转发\"></a>16.2 详解ref转发</h2><p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong></p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\n\nimport App from &#39;./11_ref/03_App_ref_forward&#39; // 转发ref\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(\n  &lt;App /&gt;\n)\n</code></pre>\n<p><code>src/11_ref/03_App_ref_forward.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\n\nclass Com extends Component &#123;\n  state = &#123;\n    name: &#39;类组件&#39;\n  &#125;\n  testFn = () =&gt; &#123;\n    console.log(this.state.name + &#39;!!!!!!!&#39;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;类组件ref的使用&lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nconst FunCom = React.forwardRef((props, ref) =&gt; &#123;\n  return (\n    &lt;div ref=&#123;ref&#125;&gt;函数式组件ref&lt;/div&gt;\n  )\n&#125;)\nconst Form = React.forwardRef((props, ref) =&gt; &#123;\n  return (\n    &lt;form ref=&#123;ref&#125;&gt;\n      &lt;input type=&quot;text&quot; name=&#39;userName&#39; /&gt;\n      &lt;input type=&quot;text&quot; name=&#39;password&#39; /&gt;\n      &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;\n      &#123;/* &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt; */&#125;\n    &lt;/form&gt;\n  )\n&#125;)\nclass App extends Component &#123;\n  btn3Ref = React.createRef() // 创建一个唯一的 ref\n  comRef = React.createRef()\n  funRef = React.createRef()\n  formRef = React.createRef()\n  componentDidMount () &#123;\n    console.log(&#39;id&#39;, document.getElementById(&#39;btn1&#39;))\n    console.log(&#39;refs&#39;, this.refs.btn2) // refs已经被废弃，但是没有移除,严格模式下会报警告信息\n    console.log(&#39;domCreateRef&#39;, this.btn3Ref.current) \n    console.log(&#39;comCreateRef&#39;, this.comRef.current) \n    console.log(&#39;FuncomCreateRef&#39;, this.funRef.current) // \n\n    // 直接给form表单设置初始值\n    console.log(this.formRef.current.children) // \n    this.setFieldValue(&#123;\n      userName: &#39;吴大勋&#39;,\n      password: &#39;123456&#39;\n    &#125;)\n  &#125;\n  setFieldValue = (obj) =&gt; &#123;\n    this.formRef.current.children[0].value = obj.userName \n    this.formRef.current.children[1].value = obj.password \n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button id=&#39;btn1&#39;&gt;按钮1-id&lt;/button&gt;\n        &lt;button ref=&#39;btn2&#39;&gt;按钮2-refs - 废弃&lt;/button&gt;\n        &lt;button ref=&#123; this.btn3Ref &#125;&gt;按钮2 - createRef &lt;/button&gt;\n        &#123;/* 父组件可以直接通过ref 获取 子组件的实例 */&#125;\n        &lt;Com ref = &#123; this.comRef &#125;&gt;&lt;/Com&gt;\n        &#123;/* 函数式组件没有实例，获取不到子组件实例 */&#125;\n        &lt;FunCom ref = &#123; this.funRef &#125;&gt;&lt;/FunCom&gt;\n        &lt;Form ref=&#123;this.formRef&#125;&gt;&lt;/Form&gt;\n        &lt;button onClick=&#123; () =&gt; &#123;\n          console.log(this.formRef.current)\n          this.formRef.current.reset()\n        &#125;&#125;&gt;重置表单&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"16-3-使用ref注意事项\"><a href=\"#16-3-使用ref注意事项\" class=\"headerlink\" title=\"16.3 使用ref注意事项\"></a>16.3 使用ref注意事项</h2><ul>\n<li><p>当 <code>ref</code> 属性用于 HTML 元素时，使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</p>\n</li>\n<li><p>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</p>\n</li>\n<li><p><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。如果非要使用，实际上是转发ref（父组件中获取到了子组件的某个DOM）</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlZGVidWd2YWx1ZQ==\">https://react.docschina.org/docs/hooks-reference.html#usedebugvalue</span>)</p>\n</li>\n</ul>\n",
            "tags": [
                "react学习",
                "react"
            ]
        },
        {
            "id": "https://www.yexingcheng.com/react-study/5/",
            "url": "https://www.yexingcheng.com/react-study/5/",
            "title": "React学习第五天",
            "date_published": "2022-08-04T16:00:00.000Z",
            "content_html": "<h1 id=\"九、条件渲染\"><a href=\"#九、条件渲染\" class=\"headerlink\" title=\"九、条件渲染\"></a>九、条件渲染</h1><p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后还可以根据应用的状态变化只渲染其中的一部分。</p>\n<p>React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。</p>\n<h2 id=\"9-1-amp-amp\"><a href=\"#9-1-amp-amp\" class=\"headerlink\" title=\"9.1 &amp;&amp;\"></a>9.1 &amp;&amp;</h2><p>你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &amp;&amp;，它可以方便地条件渲染一个元素。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n/\nimport App from &#39;./04_condition/01_App_condition_yu&#39; // 条件渲染 &amp;&amp;\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/04_condition/01_App_condition_yu.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass MainBox extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &#123; \n          this.props.unReadMessage.length &gt; 0 &amp;&amp; &lt;span&gt;还有&#123; this.props.unReadMessage.length &#125;条未读消息&lt;/span&gt;\n        &#125;&lt;/div&gt;\n    )\n  &#125;\n&#125;\n\nclass App extends Component &#123;\n  state = &#123;\n    message: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &#123;\n          this.state.message.map((item, index) =&gt; &#123;\n            return (\n              &lt;p key = &#123; index &#125;&gt;\n                &#123; item &#125;\n                &lt;button onClick=&#123; () =&gt; &#123;\n                  const arr = this.state.message // 获取数据\n                  arr.splice(index, 1) // 处理数据\n                  this.setState(&#123; // 修改状态\n                    message: arr\n                  &#125;)\n                &#125;&#125;&gt;已读&lt;/button&gt;\n              &lt;/p&gt;\n            )\n          &#125;)\n        &#125;\n        &lt;MainBox unReadMessage = &#123; this.state.message &#125; &gt;&lt;/MainBox&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"9-2-三元运算符\"><a href=\"#9-2-三元运算符\" class=\"headerlink\" title=\"9.2 三元运算符\"></a>9.2 三元运算符</h2><p>条件渲染的另一种方法是使用 JavaScript 的条件运算符:</p>\n<pre><code>condition ? true : false。\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./04_condition/02_App_condition_san&#39; // 条件渲染 三元运算符\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/04_condition/02_App_condition_san.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\n  state = &#123;\n    loginState: false\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &#123; this.state.loginState + &#39;&#39; &#125;\n        &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123; loginState: !this.state.loginState &#125;) &#125; &#125;&gt;切换&lt;/button&gt;\n        &#123;\n          this.state.loginState ? &lt;button&gt;退出&lt;/button&gt; : &lt;button&gt;登录&lt;/button&gt;\n        &#125;\n      &lt;/div&gt;\n    );\n  &#125;\n  // render() &#123;\n  //   if (this.state.loginState) &#123;\n  //     return (\n  //       &lt;div&gt;\n  //         &#123; this.state.loginState + &#39;&#39; &#125;\n  //         &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123; loginState: !this.state.loginState &#125;) &#125; &#125;&gt;切换&lt;/button&gt;\n  //          &lt;button&gt;退出&lt;/button&gt;\n  //       &lt;/div&gt;\n  //     );\n  //   &#125; else &#123;\n  //     return (\n  //       &lt;div&gt;\n  //         &#123; this.state.loginState + &#39;&#39; &#125;\n  //         &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123; loginState: !this.state.loginState &#125;) &#125; &#125;&gt;切换&lt;/button&gt;\n  //          &lt;button&gt;登录&lt;/button&gt;\n  //       &lt;/div&gt;\n  //     )\n  //   &#125;\n  // &#125;\n  // render () &#123;\n  //   // let test = null\n  //   // if (this.state.loginState) &#123;\n  //   //   test = &lt;button&gt;退出&lt;/button&gt;\n  //   // &#125; else &#123;\n  //   //   test = &lt;button&gt;登录&lt;/button&gt;\n  //   // &#125;\n  //   const test = this.state.loginState ? &lt;button&gt;退出&lt;/button&gt; : &lt;button&gt;登录&lt;/button&gt;\n  //   return (\n  //     &lt;div&gt;\n  //       &#123; this.state.loginState + &#39;&#39; &#125;\n  //       &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123; loginState: !this.state.loginState &#125;) &#125; &#125;&gt;切换&lt;/button&gt;\n  //       &#123; test &#125;\n  //     &lt;/div&gt;\n  //   )\n  // &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"9-3-动态className\"><a href=\"#9-3-动态className\" class=\"headerlink\" title=\"9.3 动态className\"></a>9.3 动态className</h2><p>Vue中有很方便的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlOEElQTglRTYlODAlODElRTclQkIlOTElRTUlQUUlOUEmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">动态绑定</span>class属性的方式，v-bind:class,那么react怎么实现这样的效果呢？</p>\n<blockquote>\n<p><code>&lt;button class=&quot;btn btn-success btn-sm&quot;&gt;&lt;/button&gt;</code></p>\n<p><code>&lt;button class=&quot;btn btn-danger btn-sm&quot;&gt;&lt;/button&gt;</code></p>\n<p><code>&lt;button class=&quot;btn btn-warning btn-sm&quot;&gt;&lt;/button&gt;</code></p>\n</blockquote>\n<p><code>&#123; this.state.type === &#39;success&#39; ? &#39;btn btn-success btn-sm&#39; : &#39;btn btn-sm&#39;&#125;</code></p>\n<p>通过classnames这个插件可以实现</p>\n<pre><code class=\"sh\">$ cnpm i classnames -S\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./04_condition/03_App_condition_classname&#39; // 条件渲染 动态的class\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/04_condition/03_App_condition_classname.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nimport classnames from &#39;classnames&#39;\nclass App extends Component &#123;\n  state = &#123;\n    type: &#39;default&#39;,\n    size: &#39;sm&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button className=&#123;\n          classnames(&#123;\n            &#39;btn&#39;: true,\n            &#39;btn-sm&#39;: this.state.size === &#39;sm&#39;,\n            &#39;btn-success&#39;: this.state.type === &#39;default&#39;\n          &#125;)\n        &#125;&gt;default&lt;/button&gt;\n        &lt;button className=&#123;\n          classnames(&#123;\n            &#39;btn&#39;: true,\n            &#39;btn-md&#39;: this.state.size === &#39;md&#39;,\n            &#39;btn-success&#39;: this.state.type === &#39;success&#39;\n          &#125;)\n        &#125;&gt;success md&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>补充：</p>\n<ul>\n<li><strong>css-in-js</strong></li>\n</ul>\n<pre><code>$ cnpm i styled-components -S\n</code></pre>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>import App from ‘.&#x2F;04_condition&#x2F;04_App_condition_cssinjs’ &#x2F;&#x2F; cssInJs</p>\n<p>const root &#x3D; ReactDOM.createRoot(document.getElementById(‘root’))</p>\n<p>&#x2F;&#x2F; 标签形式调用<br>root.render(<App>)</App></p>\n<pre><code>\n`src/04_condition/04_App_condition_cssinjs.jsx`\n\n```jsx\nimport React, &#123; Component &#125; from &#39;react&#39;;\nimport styled from &#39;styled-components&#39;\n\n// css-in-js 内部写的都是纯css\nconst ODiv = styled.div`\n  font-size: 30px;\n  color: #f66\n`\nconst Button = styled.button`\n  padding: 10px 30px;\n\n`\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;ODiv&gt;你好&lt;/ODiv&gt;\n        &lt;Button&gt;按钮&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<ul>\n<li><strong>模块化css</strong></li>\n</ul>\n<blockquote>\n<p>可以解决类似于 vue中 scoped </p>\n</blockquote>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./04_condition/05_App_module_css&#39; // 模块化css\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/04_condition/05_App_module_css.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n// import &#39;./style.module.css&#39;\nimport style from &#39;./style.module.css&#39;\n\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      // &lt;div className=&#39;container&#39;&gt;\n      //   &lt;div className=&quot;header&quot;&gt;&lt;/div&gt;\n      //   &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;\n      //   &lt;div className=&quot;footer&quot;&gt;&lt;/div&gt;\n      // &lt;/div&gt;\n      &lt;div className=&#123; style.container &#125;&gt;\n        &lt;div className=&#123; style.header &#125;&gt;&lt;/div&gt;\n        &lt;div className=&#123; style.box &#125;&gt;&lt;/div&gt;\n        &lt;div className=&#123; style.footer &#125;&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<p><code>src/04_condition/style.module.css</code></p>\n<pre><code class=\"css\">.container &#123;\n  width: 100%;\n  height: 600px;\n  display: flex;\n  flex-direction: column;\n&#125;\n\n.header &#123;\n  width: 100%;\n  height: 50px;\n  background-color: #f66;\n&#125;\n\n.box &#123;\n  width: 100%;\n  flex: 1;\n&#125;\n\n.footer &#123;\n  width: 100%;\n  height: 50px;\n  background-color: #ccc;\n&#125;\n</code></pre>\n</blockquote>\n<h2 id=\"9-4-动态style\"><a href=\"#9-4-动态style\" class=\"headerlink\" title=\"9.4 动态style\"></a>9.4 动态style</h2><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./04_condition/06_App_style&#39; // 动态style\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/04_condition/06_App_style.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\n  state = &#123;\n    size: 12,\n    color: &#39;#333&#39;\n  &#125;\n  render() &#123;\n    return (\n      &lt;&gt;\n        &lt;button onClick=&#123; () =&gt; &#123;\n          this.setState(&#123;\n            size: this.state.size + 2\n          &#125;)\n        &#125;&#125;&gt;字号+2&lt;/button&gt;\n        &lt;input type=&quot;color&quot; value=&#123;this.state.color&#125; onChange=&#123;(event) =&gt; &#123;\n          this.setState(&#123;\n            color: event.target.value\n          &#125;)\n        &#125;&#125; /&gt;\n        &lt;div style = &#123; &#123; fontSize: this.state.size, color: this.state.color &#125; &#125;&gt;\n          中国共产党第十九届中央委员会第七次全体会议9日上午在京召开。中央委员会总书记习近平代表中央政治局向全会作工作报告，并就十九届中央委员会向中国共产党第二十次全国代表大会的报告讨论稿向全会作了说明。王沪宁就《中国共产党章程（修正案）》讨论稿向全会作了说明。\n        &lt;/div&gt;\n      &lt;/&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h1 id=\"十、列表渲染\"><a href=\"#十、列表渲染\" class=\"headerlink\" title=\"十、列表渲染\"></a>十、列表渲染</h1><ul>\n<li>map()方法、key</li>\n</ul>\n<p>使用 map() 方法遍历数组</p>\n<blockquote>\n<p>组件接收数组参数，每个列表元素分配一个 key，不然会出现警告 <strong>a key should be provided for list items</strong>，意思就是需要包含 key：</p>\n</blockquote>\n<p>Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>\n<p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的<code>id</code>作为元素的 key</p>\n<p>当元素没有确定的 id 时，你可以使用他的序列号索引<code> index</code> 作为<code> key</code></p>\n<blockquote>\n<p>如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢。</p>\n</blockquote>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./05_list/01_App_map&#39; // 列表渲染 使用map\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/05_list/01_App_map.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\n  state = &#123;\n    proList: []\n  &#125;\n\n  componentDidMount () &#123;\n    fetch(&#39;http://121.89.205.189:3001/api/pro/list&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n      console.log(res.data)\n      this.setState(&#123;\n        proList: res.data\n      &#125;)\n    &#125;)\n  &#125;\n  // 边遍历边渲染\n  // render() &#123;\n  //   const &#123; proList &#125; = this.state\n  //   return (\n  //     &lt;div&gt;\n  //       &#123;\n  //         // proList &amp;&amp; proList.forEach((item, index) =&gt; &#123; // forEach没有返回值\n  //         //   return (\n  //         //     &lt;p key=&#123; item.proid &#125;&gt;&#123;index + 1&#125; - &#123; item.proname &#125;&lt;/p&gt;\n  //         //   )\n  //         // &#125;)\n  //         proList &amp;&amp; proList.map((item, index) =&gt; &#123; // map没有返回值\n  //           return (\n  //             &lt;p key=&#123; item.proid &#125;&gt;&#123;index + 1&#125; - &#123; item.proname &#125;&lt;/p&gt;\n  //           )\n  //         &#125;)\n  //       &#125;\n  //     &lt;/div&gt;\n  //   );\n  // &#125;\n\n  // 先遍历后渲染 - 利用数组装填jsx代码思想\n  render() &#123;\n    const arr = []\n    this.state.proList.forEach((item, index) =&gt; &#123;\n      arr.push(&lt;p key=&#123; item.proid &#125;&gt;&#123; index + 1 &#125; --- &#123; item.proname &#125;&lt;/p&gt;)\n    &#125;)\n    return (\n      &lt;div&gt;\n        &#123; arr &#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>接口 <code>http://121.89.205.189:3001/api/city/sortCity</code></p>\n<p>实现多层遍历</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"js\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n</code></pre>\n</blockquote>\n<blockquote>\n<p>import App from ‘.&#x2F;05_list&#x2F;02_App_mutiple_map’ &#x2F;&#x2F; 列表渲染 多层遍历</p>\n<p>const root &#x3D; ReactDOM.createRoot(document.getElementById(‘root’))</p>\n<p>&#x2F;&#x2F; 标签形式调用<br>root.render(<App>)</App></p>\n<pre><code>\n`src/05_list/02_App_mutiple_map.jsx`\n\n```jsx\nimport React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\nstate = &#123;\n cityList: []\n&#125;\n\ncomponentDidMount () &#123;\n fetch(&#39;http://121.89.205.189:3001/api/city/sortCity&#39;).then(res =&gt; res.json()).then(res =&gt; &#123;\n   console.log(JSON.parse(res.data))\n   this.setState(&#123;\n     cityList: JSON.parse(res.data)\n   &#125;)\n &#125;)\n&#125;\nrender() &#123;\n const &#123; cityList &#125; = this.state\n return (\n   &lt;div&gt;\n     &lt;ul&gt;\n       &#123;\n         cityList &amp;&amp; cityList.map(item =&gt; &#123;\n           return (\n             &lt;li key = &#123; item.letter &#125;&gt;\n               &#123; item.letter &#125;\n               &lt;ol&gt;\n                 &#123;\n                   item.data &amp;&amp; item.data.map(itm =&gt; (\n                     &lt;li key = &#123; itm.cityId &#125;&gt; &#123; itm.name &#125;&lt;/li&gt;\n                   ))\n                 &#125;\n               &lt;/ol&gt;\n             &lt;/li&gt;\n           )\n         &#125;)\n       &#125;\n     &lt;/ul&gt;\n   &lt;/div&gt;\n );\n&#125;\n&#125;\n\nexport default App;\n</code></pre>\n</blockquote>\n<h1 id=\"十一、表单绑定\"><a href=\"#十一、表单绑定\" class=\"headerlink\" title=\"十一、表单绑定\"></a>十一、表单绑定</h1><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p>\n<pre><code class=\"html\">&lt;form&gt;\n  &lt;label&gt;\n    名字:\n    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;\n  &lt;/label&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;\n&lt;/form&gt;\n</code></pre>\n<blockquote>\n<p>此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。</p>\n<p>表单元素的value值受 state的控制</p>\n</blockquote>\n<h2 id=\"11-1-各种表单的绑定与取值\"><a href=\"#11-1-各种表单的绑定与取值\" class=\"headerlink\" title=\"11.1 各种表单的绑定与取值\"></a>11.1 各种表单的绑定与取值</h2><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./06_form/01_App_form&#39; // 表单绑定 受控组件\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/06_form/01_App_form.jsx</code></p>\n<pre><code class=\"JSX\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass App extends Component &#123;\n  state = &#123;\n    userName: &#39;&#39;,\n    password: &#39;&#39;,\n    sex: &#39;女&#39;,\n    hobby: [],\n    lesson: 1,\n    note: &#39;&#39;,\n    flag: false\n  &#125;\n  // handlerUserNameChange = (event) =&gt; &#123;\n  //   this.setState(&#123; userName: event.target.value &#125;)\n  // &#125;\n  // handlerPasswordChange = (event) =&gt; &#123;\n  //   this.setState(&#123; password: event.target.value &#125;)\n  // &#125;\n\n  // handlerChange = (type, event) =&gt; &#123;\n  //   this.setState(&#123; [type]: event.target.value &#125;)\n  // &#125;\n\n  handlerChange = (event) =&gt; &#123;\n    console.log(event.target.name)\n    this.setState(&#123; [event.target.name]: event.target.value &#125;)\n  &#125;\n\n  handlerHobbyChange = (event) =&gt; &#123;\n    const checked = event.target.checked\n    const value = event.target.value\n    const arr = this.state.hobby\n    // checked 为真选中，加入数组，为假 删除\n    if (checked) &#123;\n      arr.push(value)\n    &#125; else &#123;\n      const index = arr.findIndex(item =&gt; item === value)\n      arr.splice(index, 1)\n    &#125;\n    console.log(arr)\n    this.setState(&#123; hobby: arr &#125;)\n  &#125;\n\n  handlerFlagChange = (event) =&gt; &#123;\n    this.setState(&#123; flag: event.target.checked &#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;\n          &#123;/* &lt;input type=&quot;text&quot; placeholder=&#39;用户名&#39; value=&#123; this.state.userName &#125; onChange = &#123; this.handlerUserNameChange &#125;/&gt; &#123; this.state.userName &#125; */&#125;\n          &#123;/* &lt;input type=&quot;text&quot; placeholder=&#39;用户名&#39; value=&#123; this.state.userName &#125; onChange = &#123; this.handlerChange.bind(this, &#39;userName&#39;) &#125;/&gt; &#123; this.state.userName &#125; */&#125;\n          &lt;input type=&quot;text&quot; placeholder=&#39;用户名&#39; name=&quot;userName&quot; value=&#123; this.state.userName &#125; onChange = &#123; this.handlerChange &#125;/&gt; &#123; this.state.userName &#125;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &#123;/* &lt;input type=&quot;password&quot; placeholder=&#39;密码&#39; value=&#123; this.state.password &#125; onChange = &#123; this.handlerPasswordChange &#125;/&gt; &#123; this.state.password &#125; */&#125;\n          &#123;/* &lt;input type=&quot;password&quot; placeholder=&#39;密码&#39; value=&#123; this.state.password &#125; onChange = &#123; this.handlerChange.bind(this, &#39;password&#39;) &#125;/&gt; &#123; this.state.password &#125; */&#125;\n          &lt;input type=&quot;password&quot; placeholder=&#39;密码&#39; name=&quot;password&quot; value=&#123; this.state.password &#125; onChange = &#123; this.handlerChange &#125;/&gt; &#123; this.state.password &#125;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; checked=&#123; this.state.sex === &#39;男&#39;&#125; onChange = &#123; this.handlerChange &#125;/&gt;男\n          &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; checked=&#123; this.state.sex === &#39;女&#39;&#125; onChange = &#123; this.handlerChange &#125;/&gt;女 --- &#123; this.state.sex &#125;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;🏀&quot; onChange=&#123; this.handlerHobbyChange &#125;/&gt;🏀\n          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;⚽&quot; onChange=&#123; this.handlerHobbyChange &#125;/&gt;⚽\n          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;🏐&quot; onChange=&#123; this.handlerHobbyChange &#125;/&gt;🏐\n          &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;🏓&quot; onChange=&#123; this.handlerHobbyChange &#125;/&gt;🏓 --- \n          &#123; \n            this.state.hobby &amp;&amp; this.state.hobby.map(item =&gt; &#123;\n              return &lt;span key = &#123; item &#125;&gt;&#123;item&#125;&lt;/span&gt;\n            &#125;) \n          &#125;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &lt;select name=&quot;lesson&quot; value=&#123;this.state.lesson&#125; onChange=&#123; this.handlerChange &#125;&gt;\n            &lt;option value=&#123;1&#125;&gt;1阶段&lt;/option&gt;\n            &lt;option value=&#123;2&#125;&gt;2阶段&lt;/option&gt;\n            &lt;option value=&#123;3&#125;&gt;3阶段&lt;/option&gt;\n          &lt;/select&gt; --- &#123; this.state.lesson &#125;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &lt;textarea name=&#39;note&#39; value=&#123; this.state.note &#125; onChange = &#123; this.handlerChange &#125;&gt;&lt;/textarea&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n          &lt;input type=&quot;checkbox&quot; checked = &#123; this.state.flag &#125; onChange = &#123; this.handlerFlagChange &#125; /&gt; ***** 用户协议 -- &#123; this.state.flag + &#39;&#39;&#125;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"11-2-受控表单以及受控组件\"><a href=\"#11-2-受控表单以及受控组件\" class=\"headerlink\" title=\"11.2 受控表单以及受控组件\"></a>11.2 受控表单以及受控组件</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href=\"https://react.docschina.org/docs/react-component.html#setstate\"><code>setState()</code></a>来更新。</p>\n<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>\n<blockquote>\n<p><code>input</code>、<code>textarea</code>、<code>select</code> 受控组件： value的属性受了 <code>state</code> 的控制</p>\n<ul>\n<li>使用了受控组件，一定要写 <code>value</code> 属性以及<code>onChange</code>事件</li>\n</ul>\n<p><code>radio</code>、’checkbox’ 受控组件: checked 的属性受了<code>state</code>的控制</p>\n<p>如果需要设置默认值，那么需要通过 <code>defaultValue</code> 以及<code>defaultChecked</code>设置</p>\n</blockquote>\n<p>案例如上</p>\n<h1 id=\"十二、状态提升\"><a href=\"#十二、状态提升\" class=\"headerlink\" title=\"十二、状态提升\"></a>十二、状态提升</h1><p>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。</p>\n<h2 id=\"12-1-父子组件通信\"><a href=\"#12-1-父子组件通信\" class=\"headerlink\" title=\"12.1 父子组件通信\"></a>12.1 父子组件通信</h2><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./07_state_up/01_App-parent-child-value&#39; // 状态提升 多组件数据共享\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/07_state_up/01_App-parent-child-value.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass Child1 extends Component &#123;\n  state = &#123; count: 1 &#125;\n  render () &#123;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;child1组件&lt;/h1&gt;\n        &#123; this.state.count &#125;\n        &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125; ) &#125;&#125;&gt;加1&lt;/button&gt;\n      &lt;/&gt;\n    )\n  &#125;\n&#125;\nclass Child2 extends Component &#123;\n  state = &#123; count: 1 &#125;\n  render () &#123;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;child2组件&lt;/h1&gt;\n        &#123; this.state.count &#125;\n        &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125; ) &#125;&#125;&gt;加1&lt;/button&gt;\n      &lt;/&gt;\n    )\n  &#125;\n&#125;\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Child1 &gt;&lt;/Child1&gt;\n        &lt;hr&gt;&lt;/hr&gt;\n        &lt;Child2 &gt;&lt;/Child2&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>我们发现Child1和Child2都是两个独立的个体，并没有实现数据共享</p>\n</blockquote>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./07_state_up/02_App_state_up&#39; // 状态提升 多组件数据共享\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/07_state_up/02_App_state_up.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass Child1 extends Component &#123;\n  // state = &#123; count: 1 &#125;\n  render () &#123;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;child1组件&lt;/h1&gt;\n        &#123;/* &#123; this.state.count &#125; */&#125;\n        &#123; this.props.count &#125;\n        &#123;/* &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125; ) &#125;&#125;&gt;加1&lt;/button&gt; */&#125;\n        &lt;button onClick=&#123; this.props.onClick &#125;&gt;加1&lt;/button&gt; \n      &lt;/&gt;\n    )\n  &#125;\n&#125;\nclass Child2 extends Component &#123;\n  // state = &#123; count: 1 &#125;\n  render () &#123;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;child2组件&lt;/h1&gt;\n       &#123;/* &#123; this.state.count &#125; */&#125;\n       &#123; this.props.count &#125;\n        &#123;/* &lt;button onClick=&#123; () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125; ) &#125;&#125;&gt;加1&lt;/button&gt; */&#125;\n        &lt;button onClick=&#123; this.props.onClick &#125;&gt;加1&lt;/button&gt; \n      &lt;/&gt;\n    )\n  &#125;\n&#125;\nclass App extends Component &#123;\n  state = &#123; count: 1 &#125;\n  add = () =&gt; &#123;\n    this.setState(&#123;count: this.state.count + 1&#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Child1 count = &#123; this.state.count &#125; onClick = &#123; this.add &#125;&gt;&lt;/Child1&gt;\n        &lt;hr&gt;&lt;/hr&gt;\n        &lt;Child2 count = &#123; this.state.count &#125; onClick = &#123; this.add &#125;&gt;&lt;/Child2&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<h2 id=\"12-2-状态提升解读\"><a href=\"#12-2-状态提升解读\" class=\"headerlink\" title=\"12.2 状态提升解读\"></a>12.2 状态提升解读</h2><p>实现方式是 利用最近的共同的父级组件中，用<code>props</code>的方式传过去到两个子组件，<code>props</code>中传的是一个<code>setState</code>的方法，通过子组件触发<code>props</code>传过去的方法，进而调用父级组件的<code>setState</code>的方法，改变了父级组件的<code>state</code>，调用父级组件的<code>add</code>方法，进而同时改变了两个子级组件的<code>数据</code>。</p>\n<p>这是 两个有关连的<strong>同级组件</strong>的传值，因为<code>react</code>的单项数据流，所以不在两个组件中进行传值，而是提升到 最近的共同的父级组件中，改变父级的<code>state</code>,进而影响了两个子级组件的<code>render</code>。</p>\n<blockquote>\n<p>注意如果两个组件是同级组件（这两个组件的父组件是同一个）才考虑状态提升共享数据</p>\n</blockquote>\n<h1 id=\"十三、组合vs继承\"><a href=\"#十三、组合vs继承\" class=\"headerlink\" title=\"十三、组合vs继承\"></a>十三、组合vs继承</h1><p>React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。</p>\n<h2 id=\"13-1-理解组件化\"><a href=\"#13-1-理解组件化\" class=\"headerlink\" title=\"13.1 理解组件化\"></a>13.1 理解组件化</h2><p><strong>组件化是React的核心思想</strong>：</p>\n<ul>\n<li><p>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</p>\n</li>\n<li><p>任何的应用都会被抽象成一颗组件树。</p>\n</li>\n</ul>\n<p><strong>组件化思想的应用</strong>：</p>\n<ul>\n<li><p>有了组件化的思想，我们在之后的开发中就要充分的利用它。</p>\n</li>\n<li><p>尽可能的将页面拆分成一个个小的、可复用的组件。</p>\n</li>\n<li><p>这样让我们的代码更加方便组织和管理，并且扩展性也更强。</p>\n</li>\n</ul>\n<p><strong>React的组件相对于Vue更加的灵活和多样，按照不同的方式可以分成很多类 组件</strong>：</p>\n<ul>\n<li>根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；</li>\n</ul>\n<blockquote>\n<p>vue 中有没有类组件和函数式组件？vue2中有</p>\n<pre><code class=\"vue\">&lt;template&gt;\n\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\nprops:[],\ndata () &#123;\n    return &#123;&#125;\n&#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>vue中的函数式组件 - 无状态组件，所有的数据来源均来自父组件</li>\n</ul>\n<pre><code class=\"jsx\">&lt;template functional&gt;\n  &lt;div&gt;&#123;&#123;props.msg&#125;&#125;&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<ul>\n<li>vue 中的类组件 - 兼容ts时</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;hello vue&lt;/div&gt;\n&lt;/template&gt;\n\nclass Home extends Vue &#123;&#125; // export default &#123;&#125;\n</code></pre>\n</blockquote>\n<ul>\n<li><p>根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；</p>\n</li>\n<li><p>根据组件的不同职责，可以分成：展示型组件(Presentational Component - 只做数据的展示，一般不需要写更多的业务逻辑-数据请求不出现在展示型组件-顶多发出请求的指令-具体的请求交给容器型组件)和容器型组件(Container Component - 负责给展示性组件提供数据以及处理展示型组件需要的具体的业务逻辑) - 状态管理器-更容易理解；</p>\n</li>\n</ul>\n<p>这些概念有很多重叠，但是他们最主要是关注数据逻辑和UI展示的分离：</p>\n<ul>\n<li>函数组件、无状态组件、展示型组件主要关注UI的展示；</li>\n<li>类组件、有状态组件、容器型组件主要关注数据逻辑；</li>\n</ul>\n<h2 id=\"13-2-使用组合而非继承实现React组件化\"><a href=\"#13-2-使用组合而非继承实现React组件化\" class=\"headerlink\" title=\"13.2 使用组合而非继承实现React组件化\"></a>13.2 使用组合而非继承实现React组件化</h2><p>有些组件无法提前知晓它们子组件的具体内容，建议这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中。</p>\n<p><code>参照5.3章节</code></p>\n<p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code>，而是自行约定：将所需内容传入 props，并使用相应的 prop。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./08_com/01_App_props_slot&#39; // 组合VS继承\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/08_com/01_App_props_slot.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\n\nclass Header extends Component &#123;\n  render () &#123;\n    return (\n      &lt;header&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&#123; this.props.left &#125;&lt;/li&gt;\n          &lt;li&gt;&#123; this.props.default &#125;&lt;/li&gt;\n          &lt;li&gt;&#123; this.props.right &#125;&lt;/li&gt;\n        &lt;/ul&gt;\n        &#123; this.props.children &#125;\n      &lt;/header&gt;\n    )\n  &#125;\n&#125;\n\nclass Header1 extends Component &#123;\n  render () &#123;\n    return (\n      &lt;header&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&#123; this.props.children[0] &#125;&lt;/li&gt;\n          &lt;li&gt;&#123; this.props.children[1] &#125;&lt;/li&gt;\n          &lt;li&gt;&#123; this.props.children[2] &#125;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/header&gt;\n    )\n  &#125;\n&#125;\n\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Header \n          left = &#123; &lt;span&gt;logo&lt;/span&gt; &#125;\n          default = &#123; &lt;span&gt;搜索框&lt;/span&gt; &#125;\n          right = &#123; &lt;span&gt;登录&lt;/span&gt; &#125;\n        &gt;\n          1111111111\n        &lt;/Header&gt;\n\n        &lt;Header \n          left = &#123; &lt;span&gt;返回&lt;/span&gt; &#125;\n          default = &#123; &lt;span&gt;标题&lt;/span&gt; &#125;\n          right = &#123; &lt;span&gt;更多&lt;/span&gt; &#125;\n        &gt;&lt;/Header&gt;\n        &lt;hr /&gt;\n        &lt;Header1\n        &gt;\n          &lt;span&gt;logo&lt;/span&gt;\n          &lt;span&gt;搜索框&lt;/span&gt;\n          &lt;span&gt;登录&lt;/span&gt;\n        &lt;/Header1&gt;\n        &lt;Header1\n        &gt;\n          &lt;span&gt;返回&lt;/span&gt;\n          &lt;span&gt;标题&lt;/span&gt;\n          &lt;span&gt;更多&lt;/span&gt;\n        &lt;/Header1&gt;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>像 App组件中的<code>left</code> 和<code>default</code>以及 right  的  属性对应的之类的<code>React</code> 元素本质就是对象（<code>object</code>），所以你可以把它们当作 <code>props</code>，像其他数据一样传递。这种方法可能使你想起vue中“插槽”（<code>slot</code>）的概念，但在 <code>React</code> 中没有“插槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</p>\n</blockquote>\n<h2 id=\"13-3-封装Modal弹窗\"><a href=\"#13-3-封装Modal弹窗\" class=\"headerlink\" title=\"13.3 封装Modal弹窗\"></a>13.3 封装Modal弹窗</h2><p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\n\nimport App from &#39;./08_com/02_App_modal&#39; // 组合VS继承\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/08_com/02_App_modal.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nclass Modal extends Component &#123;\n  render () &#123;\n    return (\n      &lt;div style=&#123; &#123;\n        position: &#39;fixed&#39;,\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        backgroundColor: &#39;rgba(0,0,0, 0.4)&#39;,\n        display: &#39;flex&#39;,\n        justifyContent: &#39;center&#39;,\n        alignItems: &#39;center&#39;\n        \n      &#125; &#125;&gt;\n        &lt;div style=&#123; &#123;\n          width: &#39;50%&#39;,\n          minHeight: &#39;300px&#39;,\n          backgroundColor: &#39;#fff&#39;\n        &#125; &#125;&gt;\n          这里是一个模态框\n          &lt;button onClick=&#123; this.props.onClick &#125;&gt;关闭&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    )\n  &#125;\n&#125;\nclass App extends Component &#123;\n  state = &#123; show: false &#125;\n  close = () =&gt; &#123;\n    this.setState(&#123;\n      show: false\n    &#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123; () =&gt; this.setState(&#123; show: true &#125;)&#125;&gt;打开模态框&lt;/button&gt;\n        &#123;\n          this.state.show ? &lt;Modal onClick = &#123; this.close &#125;/&gt; : null\n        &#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>审查元素发现 Modal 组件是渲染在原来的组件的位置的，如果想要让它渲染到不同的位置怎么办呢？</p>\n</blockquote>\n<h2 id=\"13-4-ReactDOM-createPortal\"><a href=\"#13-4-ReactDOM-createPortal\" class=\"headerlink\" title=\"13.4 ReactDOM.createPortal()\"></a>13.4 ReactDOM.createPortal()</h2><p>普通的组件，子组件的元素将挂载到父组件的DOM节点中。</p>\n<p>有时需要将元素渲染到DOM中的不同位置上去，这是就用到的portal的方法。</p>\n<p><code>src/index.js</code></p>\n<pre><code class=\"jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom/client&#39;\n\nimport App from &#39;./08_com/03_App_portal&#39; // 封装模态框 portal\n\nconst root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))\n\n// 标签形式调用\nroot.render(&lt;App /&gt;)\n</code></pre>\n<p><code>src/08_com/03_App_portal.jsx</code></p>\n<pre><code class=\"jsx\">import React, &#123; Component &#125; from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39; // 这里不要使用 &#39;react-dom/client&#39; 引入\nclass Modal extends Component &#123;\n  modalRef = React.createRef()\n  render () &#123;\n    return ReactDOM.createPortal(\n      // &lt;div id=&#39;modal&#39; ref=&quot;modal&quot; style=&#123; &#123;\n      &lt;div id=&#39;modal&#39; ref= &#123; this.modalRef &#125; style=&#123; &#123;\n        position: &#39;fixed&#39;,\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        backgroundColor: &#39;rgba(0,0,0, 0.4)&#39;,\n        display: &#39;flex&#39;,\n        justifyContent: &#39;center&#39;,\n        alignItems: &#39;center&#39;\n      &#125; &#125;\n        // onClick = &#123; this.props.onClick &#125;\n        onClick = &#123; (event) =&gt; &#123;\n          console.log(event.target)\n          console.log(document.getElementById(&#39;modal&#39;))\n          console.log(this.modalRef)\n          // if (event.target === document.getElementById(&#39;modal&#39;)) &#123; // ? id ?\n          // if (event.target === this.refs.modal) &#123; // ? ref 删除线？\n          if (event.target === this.modalRef.current) &#123; // ref的使用\n            // 如何判断当前点击的是自身而不是子元素\n            this.props.onClick()\n          &#125;\n          \n        &#125; &#125;\n      &gt;\n        &lt;div style=&#123; &#123;\n          width: &#39;50%&#39;,\n          minHeight: &#39;300px&#39;,\n          backgroundColor: &#39;#fff&#39;\n        &#125; &#125;\n          // onClick = &#123; event =&gt; &#123;\n          //   event.stopPropagation()\n          // &#125; &#125;\n        &gt;\n          这里是一个模态框\n          &lt;button onClick=&#123; this.props.onClick &#125;&gt;关闭&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;,\n      document.getElementsByTagName(&#39;body&#39;)[0]\n    )\n  &#125;\n&#125;\nclass App extends Component &#123;\n  state = &#123; show: false &#125;\n  close = () =&gt; &#123;\n    this.setState(&#123;\n      show: false\n    &#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick=&#123; () =&gt; this.setState(&#123; show: true &#125;)&#125;&gt;打开模态框&lt;/button&gt;\n        &#123;\n          this.state.show ? &lt;Modal onClick = &#123; this.close &#125;/&gt; : null\n        &#125;\n      &lt;/div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n</code></pre>\n<blockquote>\n<p>一个 portal 的典型用例是当父组件有 <code>overflow: hidden</code> 或 <code>z-index</code> 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p>\n</blockquote>\n",
            "tags": [
                "react学习",
                "react"
            ]
        }
    ]
}